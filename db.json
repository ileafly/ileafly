{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"6260d4d29aa1e7e1ce123a56008d80824b50be6f","modified":1560221602763},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1560327102254},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1560327102255},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1560327102255},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1560327102255},{"_id":"themes/maupassant/_config.yml","hash":"9b06a5da3e475aaead873df62d7d23ec75c46da0","modified":1560327719400},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1560327102260},{"_id":"source/about/index.md","hash":"59a9c4f7206f54a39a03f6ff2198c8ca64ea9c3a","modified":1560326376042},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1560327102250},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1560327102251},{"_id":"source/categories/index.md","hash":"1264dc90ef1aa2fa525dcb18c26989bf3f3207f8","modified":1560221602768},{"_id":"source/img/avatar.jpeg","hash":"d2aa8e646ac5c63dea059226c381cdc0caa10ae3","modified":1560221602769},{"_id":"source/tags/index.md","hash":"597f8d6c8358e7412ead9e0ef886c09c8f848118","modified":1560221602769},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1560327097212},{"_id":"themes/maupassant/.git/index","hash":"0867e60be5e192bd0b763fa88464a1b83cc0b2ba","modified":1560328293967},{"_id":"themes/maupassant/.git/packed-refs","hash":"6aa82cbab8eae86de4682fb0c8931456c470dca5","modified":1560327102248},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1560327102255},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1560327102255},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1560327102256},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1560327102256},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1560327102256},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1560327102256},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1560327102256},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1560327102256},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1560327102259},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1560327102259},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1560327102259},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1560327102259},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1560327102259},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1560327102259},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1560327102260},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1560327102260},{"_id":"source/_posts/yuque/Github+Hexo搭建个人博客详细教程.md","hash":"edfddc922c9547992fcc0c240ad3eb83b09ed066","modified":1560328522205},{"_id":"source/_posts/yuque/xopen快捷脚本.md","hash":"a9f28141ae86426ec77ad0ff03ca92a93d95f695","modified":1560328590863},{"_id":"source/_posts/yuque/使用语雀管理博客.md","hash":"c8bf3317d7f00220d99e26d017ae4282287f85ce","modified":1560328522205},{"_id":"source/_posts/yuque/弄透Block.md","hash":"20b45872feed0ca255e79c0371a97c3ff96d2d69","modified":1560328522203},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1560327097213},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1560327097213},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1560327097212},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1560327097212},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1560327097214},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1560327097214},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1560327097214},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1560327097213},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1560327097212},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1560327097213},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1560327097211},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1560327097214},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"8bae6bf10c27f10dba09c0076722c24dbb045d67","modified":1560327102250},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1560327102256},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ff14baa25f6db34dedfb5e029c25687a335ad430","modified":1560327102256},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1560327102257},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1560327102258},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1560327102258},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1560327102258},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1560327102258},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1560327102258},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1560327102258},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1560327102258},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1560327102259},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1560327102262},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1560327102261},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1560327102261},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1560327102262},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1560327102263},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1560327102263},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1560327102263},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1560327102263},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1560327102264},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1560327102264},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1560327102264},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1560327102265},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1560327102265},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1560327102265},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1560327102266},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1560327102266},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1560327102267},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1560327102267},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1560327102267},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1560327102267},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"166458305b16424499927a509c874860afee76b4","modified":1560327102250},{"_id":"themes/maupassant/.git/objects/pack/pack-f799ed1b2f961451d291bec64cd0d8578ab30651.idx","hash":"074f00dbf5ba9e371cd13794f80e6067247054a2","modified":1560327102242},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1560327102267},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"8bae6bf10c27f10dba09c0076722c24dbb045d67","modified":1560327102251},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1560327102250},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"8bae6bf10c27f10dba09c0076722c24dbb045d67","modified":1560327102250},{"_id":"themes/maupassant/.git/objects/pack/pack-f799ed1b2f961451d291bec64cd0d8578ab30651.pack","hash":"d2768c214009eade300ea6d49142905f3f7f87d1","modified":1560327102241},{"_id":"public/about/index.html","hash":"807ce637ac38a0a7a4365fef57abc58cf4d7c8f1","modified":1560328529178},{"_id":"public/categories/index.html","hash":"ffd0bc8e4b0c35fd3380d25b2318731843228045","modified":1560328529178},{"_id":"public/tags/index.html","hash":"7e2a6a29b042f8a6249bbbccc05db124a5120158","modified":1560328529178},{"_id":"public/2019/06/11/yuque/xopen快捷脚本/index.html","hash":"151c53e97bf79091ee9d184858f48f867224ddc1","modified":1560328595882},{"_id":"public/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/index.html","hash":"5775738ddde6c0eca9c22bfd23140448c9aa1a9b","modified":1560328529178},{"_id":"public/2018/11/09/yuque/使用语雀管理博客/index.html","hash":"073669fe4ea419844a001e59d81992bee8d17ac8","modified":1560328529178},{"_id":"public/archives/index.html","hash":"873b251417a8e097ab9e25b17b0e302634512075","modified":1560328529178},{"_id":"public/archives/2018/index.html","hash":"95c5ca625849c3c3fcf083dfcc66e134783912ee","modified":1560328529179},{"_id":"public/archives/2018/11/index.html","hash":"95c5ca625849c3c3fcf083dfcc66e134783912ee","modified":1560328529179},{"_id":"public/archives/2019/index.html","hash":"21d41dc8407c51e2802e03f39bf7d74358b532b4","modified":1560328529179},{"_id":"public/categories/Hexo/index.html","hash":"7d78b4750293701e6d6f6c741095d672450185e4","modified":1560328529179},{"_id":"public/archives/2019/06/index.html","hash":"21d41dc8407c51e2802e03f39bf7d74358b532b4","modified":1560328529179},{"_id":"public/categories/iOS/index.html","hash":"3caf71f86bdcaf8c7825c5fbadbcf931b966bb58","modified":1560328529179},{"_id":"public/2019/06/11/yuque/弄透Block/index.html","hash":"5911cb603092337b302f564d32e997a99df7db77","modified":1560328529179},{"_id":"public/tags/iOS/index.html","hash":"3caf71f86bdcaf8c7825c5fbadbcf931b966bb58","modified":1560328529181},{"_id":"public/index.html","hash":"a478fc6389c3c80619b09d99339a0296dc802c2a","modified":1560328595882},{"_id":"public/CNAME","hash":"6260d4d29aa1e7e1ce123a56008d80824b50be6f","modified":1560328529183},{"_id":"public/img/avatar.jpeg","hash":"d2aa8e646ac5c63dea059226c381cdc0caa10ae3","modified":1560328529183},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1560328529183},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1560328529183},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1560328529183},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1560328529183},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1560328529183},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1560328529183},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1560328529184},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1560328529184},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1560328529184},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1560328529214},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1560328529214},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1560328529214},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1560328529214},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1560328529214},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1560328529214},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1560328529214},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1560328529214},{"_id":"public/donate/index.html","hash":"e94c928417ceaf6e2dae7eac2ccb5b106fd9c2a4","modified":1560328529215},{"_id":"public/css/style.css","hash":"50dac51e44b24279f14cd3756bf1b388e5977f74","modified":1560328529215},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1560328529215},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1560328529215}],"Category":[{"name":"Hexo","_id":"cjwszbi4300056owwyhioqo9n"},{"name":"iOS","_id":"cjwszbi4a00096oww17uxt6hv"}],"Data":[],"Page":[{"layout":"about","title":"关于","_content":"\n哈喽，我是leafly，很高兴您能来我的博客，在这里我会分享一些学习心得，希望能对您也有帮助~\n\n博客的主要内容以iOS技术为主，也会涉及前端、后端的一些知识，如果您对文章有不同的看法，还请不吝赐教，博客利用Hexo搭建，托管在GitHub上，如果在浏览过程中觉得体验不佳还请见谅。","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于\"\n---\n\n哈喽，我是leafly，很高兴您能来我的博客，在这里我会分享一些学习心得，希望能对您也有帮助~\n\n博客的主要内容以iOS技术为主，也会涉及前端、后端的一些知识，如果您对文章有不同的看法，还请不吝赐教，博客利用Hexo搭建，托管在GitHub上，如果在浏览过程中觉得体验不佳还请见谅。","date":"2019-06-12T07:59:36.042Z","updated":"2019-06-12T07:59:36.042Z","path":"about/index.html","comments":1,"_id":"cjwszbi3r00006owwsbp2q1er","content":"<p>哈喽，我是leafly，很高兴您能来我的博客，在这里我会分享一些学习心得，希望能对您也有帮助~</p>\n<p>博客的主要内容以iOS技术为主，也会涉及前端、后端的一些知识，如果您对文章有不同的看法，还请不吝赐教，博客利用Hexo搭建，托管在GitHub上，如果在浏览过程中觉得体验不佳还请见谅。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>哈喽，我是leafly，很高兴您能来我的博客，在这里我会分享一些学习心得，希望能对您也有帮助~</p>\n<p>博客的主要内容以iOS技术为主，也会涉及前端、后端的一些知识，如果您对文章有不同的看法，还请不吝赐教，博客利用Hexo搭建，托管在GitHub上，如果在浏览过程中觉得体验不佳还请见谅。</p>\n"},{"layout":"categories","title":"分类","_content":"","source":"categories/index.md","raw":"---\nlayout: \"categories\"\ntitle: \"分类\"\n---\n","date":"2019-06-11T03:12:22.235Z","updated":"2019-06-11T02:53:22.768Z","path":"categories/index.html","comments":1,"_id":"cjwszbi3t00016owwvemwtdb5","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"标签","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"标签\"\n---\n","date":"2019-06-11T03:12:22.233Z","updated":"2019-06-11T02:53:22.769Z","path":"tags/index.html","comments":1,"_id":"cjwszbi3u00026owwey677kjq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"使用语雀管理博客","date":"2018-11-09T12:43:26.000Z","_content":"\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n<a name=\"x43bcd\"></a>\n#### [](#x43bcd)Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n<a name=\"wgwlfo\"></a>\n#### [](#wgwlfo)安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n\n1. 安装yuque-hexo\n\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n\n4. 同步文章\n\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n<a name=\"ol3liq\"></a>\n#### [](#ol3liq)如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n\n","source":"_posts/yuque/使用语雀管理博客.md","raw":"\n---\n\ntitle: 使用语雀管理博客\n\ndate: 2018-11-09 20:43:26 +0800\n\ncategories: Hexo\n\ntags: []\n\n---\n\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n<a name=\"x43bcd\"></a>\n#### [](#x43bcd)Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n<a name=\"wgwlfo\"></a>\n#### [](#wgwlfo)安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n\n1. 安装yuque-hexo\n\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n\n4. 同步文章\n\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n<a name=\"ol3liq\"></a>\n#### [](#ol3liq)如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n\n","slug":"yuque/使用语雀管理博客","published":1,"updated":"2019-06-12T08:35:22.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwszbi3y00036owwzqb1csa0","content":"<p>之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用<a href=\"https://jaredforsyth.com/hexo-admin/\" target=\"_blank\" rel=\"noopener\">hexo-admin</a>，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客<a href=\"https://www.yuque.com/page/luan.ma/yuque2blog\" target=\"_blank\" rel=\"noopener\">静态博客使用语雀编辑器</a>，文中介绍了如何利用语雀管理博客，决定一试。</p>\n<p><a name=\"x43bcd\"></a></p>\n<h4 id=\"Hexo搭建博客\"><a href=\"#Hexo搭建博客\" class=\"headerlink\" title=\"Hexo搭建博客\"></a><a href=\"#x43bcd\"></a>Hexo搭建博客</h4><p>首先需要先利用<a href=\"https://hexo.io/zh-cn/index.html\" target=\"_blank\" rel=\"noopener\">hexo</a>搭建博客，具体的搭建流程可以参考<a href=\"http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/\" target=\"_blank\" rel=\"noopener\">Github+Hexo搭建个人博客详细教程</a></p>\n<p><a name=\"wgwlfo\"></a></p>\n<h4 id=\"安装语雀插件\"><a href=\"#安装语雀插件\" class=\"headerlink\" title=\"安装语雀插件\"></a><a href=\"#wgwlfo\"></a>安装语雀插件</h4><p><a href=\"https://github.com/x-cold/yuque-hexo/\" target=\"_blank\" rel=\"noopener\">yuque-hexo</a>是一个Node.js环境下的语雀下载器。</p>\n<ol>\n<li><p>安装yuque-hexo</p>\n</li>\n<li><p>注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的<a href=\"https://www.yuque.com/leafly/blog\" target=\"_blank\" rel=\"noopener\">语雀知识库地址</a></p>\n</li>\n<li><p>在Hexo博客的目录下面找到package.json文件，进入如下配置：</p>\n</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可</span><br><span class=\"line\">\"yuqueConfig\": &#123;</span><br><span class=\"line\">    \"baseUrl\": \"https://www.yuque.com/api/v2\",</span><br><span class=\"line\">    \"login\": \"leafly\",</span><br><span class=\"line\">    \"repo\": \"blog\",</span><br><span class=\"line\">    \"postPath\": \"source/_posts/yuque\"</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>同步文章</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yuque-hexo sync</span><br></pre></td></tr></table></figure>\n<p>执行完毕，会自动将语雀上的文章同步到<code>source/_post/yuque</code>文件夹下<br><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>将博客内容同步到github。</p>\n<p><a name=\"ol3liq\"></a></p>\n<h4 id=\"如何添加分类、标签、创建时间\"><a href=\"#如何添加分类、标签、创建时间\" class=\"headerlink\" title=\"如何添加分类、标签、创建时间\"></a><a href=\"#ol3liq\"></a>如何添加分类、标签、创建时间</h4><p>插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: [Hexo]</span><br><span class=\"line\">categories: 教程</span><br><span class=\"line\">date: 2018-10-10 15:43:50</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用<a href=\"https://jaredforsyth.com/hexo-admin/\" target=\"_blank\" rel=\"noopener\">hexo-admin</a>，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客<a href=\"https://www.yuque.com/page/luan.ma/yuque2blog\" target=\"_blank\" rel=\"noopener\">静态博客使用语雀编辑器</a>，文中介绍了如何利用语雀管理博客，决定一试。</p>\n<p><a name=\"x43bcd\"></a></p>\n<h4 id=\"Hexo搭建博客\"><a href=\"#Hexo搭建博客\" class=\"headerlink\" title=\"Hexo搭建博客\"></a><a href=\"#x43bcd\"></a>Hexo搭建博客</h4><p>首先需要先利用<a href=\"https://hexo.io/zh-cn/index.html\" target=\"_blank\" rel=\"noopener\">hexo</a>搭建博客，具体的搭建流程可以参考<a href=\"http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/\" target=\"_blank\" rel=\"noopener\">Github+Hexo搭建个人博客详细教程</a></p>\n<p><a name=\"wgwlfo\"></a></p>\n<h4 id=\"安装语雀插件\"><a href=\"#安装语雀插件\" class=\"headerlink\" title=\"安装语雀插件\"></a><a href=\"#wgwlfo\"></a>安装语雀插件</h4><p><a href=\"https://github.com/x-cold/yuque-hexo/\" target=\"_blank\" rel=\"noopener\">yuque-hexo</a>是一个Node.js环境下的语雀下载器。</p>\n<ol>\n<li><p>安装yuque-hexo</p>\n</li>\n<li><p>注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的<a href=\"https://www.yuque.com/leafly/blog\" target=\"_blank\" rel=\"noopener\">语雀知识库地址</a></p>\n</li>\n<li><p>在Hexo博客的目录下面找到package.json文件，进入如下配置：</p>\n</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可</span><br><span class=\"line\">\"yuqueConfig\": &#123;</span><br><span class=\"line\">    \"baseUrl\": \"https://www.yuque.com/api/v2\",</span><br><span class=\"line\">    \"login\": \"leafly\",</span><br><span class=\"line\">    \"repo\": \"blog\",</span><br><span class=\"line\">    \"postPath\": \"source/_posts/yuque\"</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>同步文章</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yuque-hexo sync</span><br></pre></td></tr></table></figure>\n<p>执行完毕，会自动将语雀上的文章同步到<code>source/_post/yuque</code>文件夹下<br><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>将博客内容同步到github。</p>\n<p><a name=\"ol3liq\"></a></p>\n<h4 id=\"如何添加分类、标签、创建时间\"><a href=\"#如何添加分类、标签、创建时间\" class=\"headerlink\" title=\"如何添加分类、标签、创建时间\"></a><a href=\"#ol3liq\"></a>如何添加分类、标签、创建时间</h4><p>插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: [Hexo]</span><br><span class=\"line\">categories: 教程</span><br><span class=\"line\">date: 2018-10-10 15:43:50</span><br></pre></td></tr></table></figure></p>\n"},{"title":"xopen快捷脚本","date":"2019-06-11T02:10:16.000Z","_content":"\n自定义xopen快捷脚本，在终端中快速打开项目\n\n<a name=\"dWZuy\"></a>\n#### 详细教程\n\n1. 创建 `xopen` 文件\n1. 编辑 `xopen` 内容\n\n```ruby\n#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts \"Opening  #{proj}\"\n   `open #{proj}`\nelse\n  puts \"No  xcworkspace|xcproj  file  found\"\nend\n```\n\n3. 将 `xopen` 文件移入 `/usr/local/bin` 目录下\n3. 添加权限 `chmod 777 xopen` \n3. 在终端中，cd到项目目录下，执行xopen\n\n","source":"_posts/yuque/xopen快捷脚本.md","raw":"\n---\n\ntitle: xopen快捷脚本\n\ndate: 2019-06-11 10:10:16 +0800\n\ncategories: iOS\n\ntags: [iOS]\n\n---\n\n自定义xopen快捷脚本，在终端中快速打开项目\n\n<a name=\"dWZuy\"></a>\n#### 详细教程\n\n1. 创建 `xopen` 文件\n1. 编辑 `xopen` 内容\n\n```ruby\n#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts \"Opening  #{proj}\"\n   `open #{proj}`\nelse\n  puts \"No  xcworkspace|xcproj  file  found\"\nend\n```\n\n3. 将 `xopen` 文件移入 `/usr/local/bin` 目录下\n3. 添加权限 `chmod 777 xopen` \n3. 在终端中，cd到项目目录下，执行xopen\n\n","slug":"yuque/xopen快捷脚本","published":1,"updated":"2019-06-12T08:36:30.863Z","_id":"cjwszbi4100046owwutxv03x8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>自定义xopen快捷脚本，在终端中快速打开项目</p>\n<p><a name=\"dWZuy\"></a></p>\n<h4 id=\"详细教程\"><a href=\"#详细教程\" class=\"headerlink\" title=\"详细教程\"></a>详细教程</h4><ol>\n<li>创建 <code>xopen</code> 文件</li>\n<li>编辑 <code>xopen</code> 内容</li>\n</ol>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env ruby</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'shellwords'</span></span><br><span class=\"line\"></span><br><span class=\"line\">proj = Dir[<span class=\"string\">'*.xcworkspace'</span>].first</span><br><span class=\"line\">proj = Dir[<span class=\"string\">'*.xcodeproj'</span>].first <span class=\"keyword\">unless</span> proj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> proj</span><br><span class=\"line\">   puts <span class=\"string\">\"Opening  <span class=\"subst\">#&#123;proj&#125;</span>\"</span></span><br><span class=\"line\">   <span class=\"string\">`open <span class=\"subst\">#&#123;proj&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  puts <span class=\"string\">\"No  xcworkspace|xcproj  file  found\"</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下</li>\n<li>添加权限 <code>chmod 777 xopen</code> </li>\n<li>在终端中，cd到项目目录下，执行xopen</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>自定义xopen快捷脚本，在终端中快速打开项目</p>\n<p><a name=\"dWZuy\"></a></p>\n<h4 id=\"详细教程\"><a href=\"#详细教程\" class=\"headerlink\" title=\"详细教程\"></a>详细教程</h4><ol>\n<li>创建 <code>xopen</code> 文件</li>\n<li>编辑 <code>xopen</code> 内容</li>\n</ol>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env ruby</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'shellwords'</span></span><br><span class=\"line\"></span><br><span class=\"line\">proj = Dir[<span class=\"string\">'*.xcworkspace'</span>].first</span><br><span class=\"line\">proj = Dir[<span class=\"string\">'*.xcodeproj'</span>].first <span class=\"keyword\">unless</span> proj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> proj</span><br><span class=\"line\">   puts <span class=\"string\">\"Opening  <span class=\"subst\">#&#123;proj&#125;</span>\"</span></span><br><span class=\"line\">   <span class=\"string\">`open <span class=\"subst\">#&#123;proj&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  puts <span class=\"string\">\"No  xcworkspace|xcproj  file  found\"</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下</li>\n<li>添加权限 <code>chmod 777 xopen</code> </li>\n<li>在终端中，cd到项目目录下，执行xopen</li>\n</ol>\n"},{"title":"弄透Block","date":"2019-06-11T02:18:48.000Z","_content":"\n\n本文重点：\n\n- Block是什么？\n- 总结Block的使用场景\n- 为什么Block属性需要用copy修饰？\n- __block修饰后为何就可以修改？\n- Block循环引用是怎么产生的？\n\n\n<a name=\"d9d97201\"></a>\n# Block是什么？\n\n> Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数\n\n\n1. 匿名函数\n\n匿名函数是指不带函数名称的函数\n\n2. 带有自动变量\n\n这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态\n\n```objectivec\nint val = 10;\nvoid (^blk)(void) = ^{\n  printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝\n```\n\n3. 为了解决block不能修改自动变量的值，可以使用 `__block` 修饰\n\n```objectivec\n__block int val = 10;\nvoid (^blk)(void) = ^{\n printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是2\n```\n\n\n<a name=\"e3d6ac67\"></a>\n# Block的使用场景\n\n1. 声明Block属性 利用Block属性响应事件或传递数据\n\n> UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调\n> Block回调的思路：\n> 声明一个Block属性，注意这里要用copy。\n> 利用Block属性进行回调\n\n\n2. 方法参数为Block 利用Block实现回调\n\n> 以 `[UIView animateWithDuration:animations:]` 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递\n\n\n3. 链式语法\n\n> 链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用\n\n\n```objectivec\n//  CaculateMaker.h\n//  ChainBlockTestApp\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface CaculateMaker : NSObject\n\n@property (nonatomic, assign) CGFloat result;\n\n/*\n* 返回类型 CaculateMaker\n* 传入参数 CGFloat num\n*/\n- (CaculateMaker *(^)(CGFloat num))add;\n\n@end\n\n\n//  CaculateMaker.m\n//  ChainBlockTestApp\n\n\n#import \"CaculateMaker.h\"\n\n@implementation CaculateMaker\n\n- (CaculateMaker *(^)(CGFloat num))add;{\n    return ^CaculateMaker *(CGFloat num){\n        _result += num;\n        return self;\n    };\n}\n\n@end\n\n// 使用\nCaculateMaker *maker = [[CaculateMaker alloc] init];\nmaker.add(20).add(30);\n```\n\n\n<a name=\"fd60c885\"></a>\n# 为什么Block属性需要用copy修饰？\n\n**因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。**<br />**<br />为何会有这种现象出现？\n\nBlock在内存中的位置分为三种类型：\n\n- **NSGlobalBlock** 是位于全局区的block，它是设置在程序的数据区中。\n- **NSStackBlock** 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。\n- **NSMallocBlock** 是位于堆区，在变量作用域结束时不受影响。\n\n这三种类型对应以下三种情况：\n\n1. Block中没有截获自动变量时Block类型是**NSGlobalBlock**\n1. Block中截获自动变量时Block类型是**NSStackBlock**\n1. 堆中的Block无法直接创建，当对**NSStackBlock**类型的Block进行copy时，会将Block放到堆中，Block类型变为**NSMallocBlock**\n\n当Block类型是**NSStackBlock**时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。\n\n```objectivec\n- (void)click:(id)sender {\n        TestClass *test = [[TestClass alloc] init];\n        \n        __block int a = 1;\n        // 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.weakBlock = ^() {\n            NSLog(@\"ok\");\n            a = 2;\n        };\n        \n        // block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.assignBlock = ^() {\n            NSLog(@\"ok\");\n            a = 3;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.copyBlock = ^() {\n            NSLog(@\"ok\");\n            a = 4;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.strongBlock = ^() {\n            NSLog(@\"ok\");\n            a = 5;\n        };\n        \n        NSLog(@\"copy property: %@\", test.copyBlock);\n        NSLog(@\"assign property: %@\", test.assignBlock);\n        NSLog(@\"weak property: %@\", test.weakBlock);\n        NSLog(@\"strong property: %@\", test.strongBlock);\n        \n        \n        [test start];\n    }\n```\n\n\n<a name=\"7a61fc63\"></a>\n# __block修饰后为何就可以修改局部变量？\n\n首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br />因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。\n\n加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br />定义一个 `__block int a = 10;`  会变成 `__Block_byref_a_0 *a;` <br />`__Block_byref_a_0` 的结构体如下所示：\n\n```objectivec\nstruct __Block_byref_a_0 {\n void *__isa;\n __Block_byref_a_0 *__forwarding; // forwarding指针\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n int a; // 原变量同类型变量\n};\n```\n\n结构体中有一个**forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量->forwarding->原变量同类型变量**\n\n如果在block中直接修改变量的值，实质的过程是新变量->__forwarding->原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。\n\n这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收\n\n总结：<br />**block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。**\n\n\n<a name=\"0eccb7a1\"></a>\n# Block的循环引用是怎么产生的？\n\n我们先看一段block导致循环引用的代码：\n\n```objectivec\nTestClass *test = [[TestClass alloc] init]; \n\ntest.copyBlock = ^() {\n    NSLog(@\"ok: %d\", test.result);\n};\n```\n\n当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br />test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。\n\n并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：\n\n```objectivec\n// self-->requestModel-->block-->self \n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// 虽然存在引用环，但是通过主动释放requestModel打破了循环\n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n    self.requestModel = nil;\n}];\n\n// t-->block-->self 不存在循环引用\nTest *t = [[Test alloc] init];\n\n[t requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// AFNetworking-->block-->self 不存在循环引用\n[AFNetworking requestData:^(NSData *data) {\n    self.name = @\"lealfy\";\n}];\n```\n\n\n","source":"_posts/yuque/弄透Block.md","raw":"\n---\n\ntitle: 弄透Block\n\ndate: 2019-06-11 10:18:48 +0800\n\ncategories: iOS\n\ntags: [iOS]\n\n---\n\n\n本文重点：\n\n- Block是什么？\n- 总结Block的使用场景\n- 为什么Block属性需要用copy修饰？\n- __block修饰后为何就可以修改？\n- Block循环引用是怎么产生的？\n\n\n<a name=\"d9d97201\"></a>\n# Block是什么？\n\n> Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数\n\n\n1. 匿名函数\n\n匿名函数是指不带函数名称的函数\n\n2. 带有自动变量\n\n这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态\n\n```objectivec\nint val = 10;\nvoid (^blk)(void) = ^{\n  printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝\n```\n\n3. 为了解决block不能修改自动变量的值，可以使用 `__block` 修饰\n\n```objectivec\n__block int val = 10;\nvoid (^blk)(void) = ^{\n printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是2\n```\n\n\n<a name=\"e3d6ac67\"></a>\n# Block的使用场景\n\n1. 声明Block属性 利用Block属性响应事件或传递数据\n\n> UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调\n> Block回调的思路：\n> 声明一个Block属性，注意这里要用copy。\n> 利用Block属性进行回调\n\n\n2. 方法参数为Block 利用Block实现回调\n\n> 以 `[UIView animateWithDuration:animations:]` 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递\n\n\n3. 链式语法\n\n> 链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用\n\n\n```objectivec\n//  CaculateMaker.h\n//  ChainBlockTestApp\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface CaculateMaker : NSObject\n\n@property (nonatomic, assign) CGFloat result;\n\n/*\n* 返回类型 CaculateMaker\n* 传入参数 CGFloat num\n*/\n- (CaculateMaker *(^)(CGFloat num))add;\n\n@end\n\n\n//  CaculateMaker.m\n//  ChainBlockTestApp\n\n\n#import \"CaculateMaker.h\"\n\n@implementation CaculateMaker\n\n- (CaculateMaker *(^)(CGFloat num))add;{\n    return ^CaculateMaker *(CGFloat num){\n        _result += num;\n        return self;\n    };\n}\n\n@end\n\n// 使用\nCaculateMaker *maker = [[CaculateMaker alloc] init];\nmaker.add(20).add(30);\n```\n\n\n<a name=\"fd60c885\"></a>\n# 为什么Block属性需要用copy修饰？\n\n**因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。**<br />**<br />为何会有这种现象出现？\n\nBlock在内存中的位置分为三种类型：\n\n- **NSGlobalBlock** 是位于全局区的block，它是设置在程序的数据区中。\n- **NSStackBlock** 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。\n- **NSMallocBlock** 是位于堆区，在变量作用域结束时不受影响。\n\n这三种类型对应以下三种情况：\n\n1. Block中没有截获自动变量时Block类型是**NSGlobalBlock**\n1. Block中截获自动变量时Block类型是**NSStackBlock**\n1. 堆中的Block无法直接创建，当对**NSStackBlock**类型的Block进行copy时，会将Block放到堆中，Block类型变为**NSMallocBlock**\n\n当Block类型是**NSStackBlock**时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。\n\n```objectivec\n- (void)click:(id)sender {\n        TestClass *test = [[TestClass alloc] init];\n        \n        __block int a = 1;\n        // 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.weakBlock = ^() {\n            NSLog(@\"ok\");\n            a = 2;\n        };\n        \n        // block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.assignBlock = ^() {\n            NSLog(@\"ok\");\n            a = 3;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.copyBlock = ^() {\n            NSLog(@\"ok\");\n            a = 4;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.strongBlock = ^() {\n            NSLog(@\"ok\");\n            a = 5;\n        };\n        \n        NSLog(@\"copy property: %@\", test.copyBlock);\n        NSLog(@\"assign property: %@\", test.assignBlock);\n        NSLog(@\"weak property: %@\", test.weakBlock);\n        NSLog(@\"strong property: %@\", test.strongBlock);\n        \n        \n        [test start];\n    }\n```\n\n\n<a name=\"7a61fc63\"></a>\n# __block修饰后为何就可以修改局部变量？\n\n首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br />因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。\n\n加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br />定义一个 `__block int a = 10;`  会变成 `__Block_byref_a_0 *a;` <br />`__Block_byref_a_0` 的结构体如下所示：\n\n```objectivec\nstruct __Block_byref_a_0 {\n void *__isa;\n __Block_byref_a_0 *__forwarding; // forwarding指针\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n int a; // 原变量同类型变量\n};\n```\n\n结构体中有一个**forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量->forwarding->原变量同类型变量**\n\n如果在block中直接修改变量的值，实质的过程是新变量->__forwarding->原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。\n\n这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收\n\n总结：<br />**block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。**\n\n\n<a name=\"0eccb7a1\"></a>\n# Block的循环引用是怎么产生的？\n\n我们先看一段block导致循环引用的代码：\n\n```objectivec\nTestClass *test = [[TestClass alloc] init]; \n\ntest.copyBlock = ^() {\n    NSLog(@\"ok: %d\", test.result);\n};\n```\n\n当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br />test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。\n\n并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：\n\n```objectivec\n// self-->requestModel-->block-->self \n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// 虽然存在引用环，但是通过主动释放requestModel打破了循环\n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n    self.requestModel = nil;\n}];\n\n// t-->block-->self 不存在循环引用\nTest *t = [[Test alloc] init];\n\n[t requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// AFNetworking-->block-->self 不存在循环引用\n[AFNetworking requestData:^(NSData *data) {\n    self.name = @\"lealfy\";\n}];\n```\n\n\n","slug":"yuque/弄透Block","published":1,"updated":"2019-06-12T08:35:22.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwszbi4400066oww6btdhgwi","content":"<p>本文重点：</p>\n<ul>\n<li>Block是什么？</li>\n<li>总结Block的使用场景</li>\n<li>为什么Block属性需要用copy修饰？</li>\n<li>__block修饰后为何就可以修改？</li>\n<li>Block循环引用是怎么产生的？</li>\n</ul>\n<p><a name=\"d9d97201\"></a></p>\n<h1 id=\"Block是什么？\"><a href=\"#Block是什么？\" class=\"headerlink\" title=\"Block是什么？\"></a>Block是什么？</h1><blockquote>\n<p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p>\n</blockquote>\n<ol>\n<li>匿名函数</li>\n</ol>\n<p>匿名函数是指不带函数名称的函数</p>\n<ol start=\"2\">\n<li>带有自动变量</li>\n</ol>\n<p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (^blk)(<span class=\"keyword\">void</span>) = ^&#123;</span><br><span class=\"line\">  printf(<span class=\"string\">\"val=%d\\n\"</span>, val);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">val = <span class=\"number\">2</span>;</span><br><span class=\"line\">blk(); <span class=\"comment\">// 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (^blk)(<span class=\"keyword\">void</span>) = ^&#123;</span><br><span class=\"line\"> printf(<span class=\"string\">\"val=%d\\n\"</span>, val);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">val = <span class=\"number\">2</span>;</span><br><span class=\"line\">blk(); <span class=\"comment\">// 这里输出的值是2</span></span><br></pre></td></tr></table></figure>\n<p><a name=\"e3d6ac67\"></a></p>\n<h1 id=\"Block的使用场景\"><a href=\"#Block的使用场景\" class=\"headerlink\" title=\"Block的使用场景\"></a>Block的使用场景</h1><ol>\n<li>声明Block属性 利用Block属性响应事件或传递数据</li>\n</ol>\n<blockquote>\n<p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调<br>Block回调的思路：<br>声明一个Block属性，注意这里要用copy。<br>利用Block属性进行回调</p>\n</blockquote>\n<ol start=\"2\">\n<li>方法参数为Block 利用Block实现回调</li>\n</ol>\n<blockquote>\n<p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p>\n</blockquote>\n<ol start=\"3\">\n<li>链式语法</li>\n</ol>\n<blockquote>\n<p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  CaculateMaker.h</span></span><br><span class=\"line\"><span class=\"comment\">//  ChainBlockTestApp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CaculateMaker</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">CGFloat</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 返回类型 CaculateMaker</span></span><br><span class=\"line\"><span class=\"comment\">* 传入参数 CGFloat num</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (CaculateMaker *(^)(<span class=\"built_in\">CGFloat</span> num))add;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  CaculateMaker.m</span></span><br><span class=\"line\"><span class=\"comment\">//  ChainBlockTestApp</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CaculateMaker.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CaculateMaker</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (CaculateMaker *(^)(<span class=\"built_in\">CGFloat</span> num))add;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^CaculateMaker *(<span class=\"built_in\">CGFloat</span> num)&#123;</span><br><span class=\"line\">        _result += num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">CaculateMaker *maker = [[CaculateMaker alloc] init];</span><br><span class=\"line\">maker.add(<span class=\"number\">20</span>).add(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n<p><a name=\"fd60c885\"></a></p>\n<h1 id=\"为什么Block属性需要用copy修饰？\"><a href=\"#为什么Block属性需要用copy修饰？\" class=\"headerlink\" title=\"为什么Block属性需要用copy修饰？\"></a>为什么Block属性需要用copy修饰？</h1><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong><br>**<br>为何会有这种现象出现？</p>\n<p>Block在内存中的位置分为三种类型：</p>\n<ul>\n<li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li>\n<li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li>\n<li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li>\n</ul>\n<p>这三种类型对应以下三种情况：</p>\n<ol>\n<li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li>\n<li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li>\n<li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li>\n</ol>\n<p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)click:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">        TestClass *test = [[TestClass alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        __block <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS</span></span><br><span class=\"line\">        test.weakBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS</span></span><br><span class=\"line\">        test.assignBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// block类型是__MallocBlock__ 正常执行</span></span><br><span class=\"line\">        test.copyBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">4</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// block类型是__MallocBlock__ 正常执行</span></span><br><span class=\"line\">        test.strongBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copy property: %@\"</span>, test.copyBlock);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"assign property: %@\"</span>, test.assignBlock);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"weak property: %@\"</span>, test.weakBlock);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"strong property: %@\"</span>, test.strongBlock);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        [test start];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"7a61fc63\"></a></p>\n<h1 id=\"block修饰后为何就可以修改局部变量？\"><a href=\"#block修饰后为何就可以修改局部变量？\" class=\"headerlink\" title=\"__block修饰后为何就可以修改局部变量？\"></a>__block修饰后为何就可以修改局部变量？</h1><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p>\n<p>加上<strong>block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br>定义一个 `</strong>block int a = 10;<code>会变成</code><strong>Block_byref_a_0 *a;<code>&lt;br /&gt;</code></strong>Block_byref_a_0` 的结构体如下所示：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __Block_byref_a_0 &#123;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> *__isa;</span><br><span class=\"line\"> __Block_byref_a_0 *__forwarding; <span class=\"comment\">// forwarding指针</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> __flags;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> __size;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (*__Block_byref_id_object_copy)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (*__Block_byref_id_object_dispose)(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\"> <span class=\"keyword\">int</span> a; <span class=\"comment\">// 原变量同类型变量</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p>\n<p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p>\n<p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p>\n<p>总结：<br><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。</strong></p>\n<p><a name=\"0eccb7a1\"></a></p>\n<h1 id=\"Block的循环引用是怎么产生的？\"><a href=\"#Block的循环引用是怎么产生的？\" class=\"headerlink\" title=\"Block的循环引用是怎么产生的？\"></a>Block的循环引用是怎么产生的？</h1><p>我们先看一段block导致循环引用的代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestClass *test = [[TestClass alloc] init]; </span><br><span class=\"line\"></span><br><span class=\"line\">test.copyBlock = ^() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok: %d\"</span>, test.result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p>\n<p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// self--&gt;requestModel--&gt;block--&gt;self </span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.requestModel requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"leafly\"</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 虽然存在引用环，但是通过主动释放requestModel打破了循环</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.requestModel requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"leafly\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.requestModel = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// t--&gt;block--&gt;self 不存在循环引用</span></span><br><span class=\"line\">Test *t = [[Test alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">[t requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"leafly\"</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AFNetworking--&gt;block--&gt;self 不存在循环引用</span></span><br><span class=\"line\">[AFNetworking requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"lealfy\"</span>;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>本文重点：</p>\n<ul>\n<li>Block是什么？</li>\n<li>总结Block的使用场景</li>\n<li>为什么Block属性需要用copy修饰？</li>\n<li>__block修饰后为何就可以修改？</li>\n<li>Block循环引用是怎么产生的？</li>\n</ul>\n<p><a name=\"d9d97201\"></a></p>\n<h1 id=\"Block是什么？\"><a href=\"#Block是什么？\" class=\"headerlink\" title=\"Block是什么？\"></a>Block是什么？</h1><blockquote>\n<p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p>\n</blockquote>\n<ol>\n<li>匿名函数</li>\n</ol>\n<p>匿名函数是指不带函数名称的函数</p>\n<ol start=\"2\">\n<li>带有自动变量</li>\n</ol>\n<p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (^blk)(<span class=\"keyword\">void</span>) = ^&#123;</span><br><span class=\"line\">  printf(<span class=\"string\">\"val=%d\\n\"</span>, val);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">val = <span class=\"number\">2</span>;</span><br><span class=\"line\">blk(); <span class=\"comment\">// 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"keyword\">int</span> val = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> (^blk)(<span class=\"keyword\">void</span>) = ^&#123;</span><br><span class=\"line\"> printf(<span class=\"string\">\"val=%d\\n\"</span>, val);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">val = <span class=\"number\">2</span>;</span><br><span class=\"line\">blk(); <span class=\"comment\">// 这里输出的值是2</span></span><br></pre></td></tr></table></figure>\n<p><a name=\"e3d6ac67\"></a></p>\n<h1 id=\"Block的使用场景\"><a href=\"#Block的使用场景\" class=\"headerlink\" title=\"Block的使用场景\"></a>Block的使用场景</h1><ol>\n<li>声明Block属性 利用Block属性响应事件或传递数据</li>\n</ol>\n<blockquote>\n<p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调<br>Block回调的思路：<br>声明一个Block属性，注意这里要用copy。<br>利用Block属性进行回调</p>\n</blockquote>\n<ol start=\"2\">\n<li>方法参数为Block 利用Block实现回调</li>\n</ol>\n<blockquote>\n<p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p>\n</blockquote>\n<ol start=\"3\">\n<li>链式语法</li>\n</ol>\n<blockquote>\n<p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  CaculateMaker.h</span></span><br><span class=\"line\"><span class=\"comment\">//  ChainBlockTestApp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CaculateMaker</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">CGFloat</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 返回类型 CaculateMaker</span></span><br><span class=\"line\"><span class=\"comment\">* 传入参数 CGFloat num</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (CaculateMaker *(^)(<span class=\"built_in\">CGFloat</span> num))add;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  CaculateMaker.m</span></span><br><span class=\"line\"><span class=\"comment\">//  ChainBlockTestApp</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CaculateMaker.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CaculateMaker</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (CaculateMaker *(^)(<span class=\"built_in\">CGFloat</span> num))add;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ^CaculateMaker *(<span class=\"built_in\">CGFloat</span> num)&#123;</span><br><span class=\"line\">        _result += num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">CaculateMaker *maker = [[CaculateMaker alloc] init];</span><br><span class=\"line\">maker.add(<span class=\"number\">20</span>).add(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n<p><a name=\"fd60c885\"></a></p>\n<h1 id=\"为什么Block属性需要用copy修饰？\"><a href=\"#为什么Block属性需要用copy修饰？\" class=\"headerlink\" title=\"为什么Block属性需要用copy修饰？\"></a>为什么Block属性需要用copy修饰？</h1><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong><br>**<br>为何会有这种现象出现？</p>\n<p>Block在内存中的位置分为三种类型：</p>\n<ul>\n<li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li>\n<li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li>\n<li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li>\n</ul>\n<p>这三种类型对应以下三种情况：</p>\n<ol>\n<li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li>\n<li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li>\n<li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li>\n</ol>\n<p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)click:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">        TestClass *test = [[TestClass alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        __block <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS</span></span><br><span class=\"line\">        test.weakBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS</span></span><br><span class=\"line\">        test.assignBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// block类型是__MallocBlock__ 正常执行</span></span><br><span class=\"line\">        test.copyBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">4</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// block类型是__MallocBlock__ 正常执行</span></span><br><span class=\"line\">        test.strongBlock = ^() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok\"</span>);</span><br><span class=\"line\">            a = <span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"copy property: %@\"</span>, test.copyBlock);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"assign property: %@\"</span>, test.assignBlock);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"weak property: %@\"</span>, test.weakBlock);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"strong property: %@\"</span>, test.strongBlock);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        [test start];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"7a61fc63\"></a></p>\n<h1 id=\"block修饰后为何就可以修改局部变量？\"><a href=\"#block修饰后为何就可以修改局部变量？\" class=\"headerlink\" title=\"__block修饰后为何就可以修改局部变量？\"></a>__block修饰后为何就可以修改局部变量？</h1><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p>\n<p>加上<strong>block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br>定义一个 `</strong>block int a = 10;<code>会变成</code><strong>Block_byref_a_0 *a;<code>&lt;br /&gt;</code></strong>Block_byref_a_0` 的结构体如下所示：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __Block_byref_a_0 &#123;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> *__isa;</span><br><span class=\"line\"> __Block_byref_a_0 *__forwarding; <span class=\"comment\">// forwarding指针</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> __flags;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> __size;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (*__Block_byref_id_object_copy)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (*__Block_byref_id_object_dispose)(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\"> <span class=\"keyword\">int</span> a; <span class=\"comment\">// 原变量同类型变量</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p>\n<p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p>\n<p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p>\n<p>总结：<br><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。</strong></p>\n<p><a name=\"0eccb7a1\"></a></p>\n<h1 id=\"Block的循环引用是怎么产生的？\"><a href=\"#Block的循环引用是怎么产生的？\" class=\"headerlink\" title=\"Block的循环引用是怎么产生的？\"></a>Block的循环引用是怎么产生的？</h1><p>我们先看一段block导致循环引用的代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestClass *test = [[TestClass alloc] init]; </span><br><span class=\"line\"></span><br><span class=\"line\">test.copyBlock = ^() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"ok: %d\"</span>, test.result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p>\n<p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// self--&gt;requestModel--&gt;block--&gt;self </span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.requestModel requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"leafly\"</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 虽然存在引用环，但是通过主动释放requestModel打破了循环</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.requestModel requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"leafly\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.requestModel = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// t--&gt;block--&gt;self 不存在循环引用</span></span><br><span class=\"line\">Test *t = [[Test alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">[t requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"leafly\"</span>;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AFNetworking--&gt;block--&gt;self 不存在循环引用</span></span><br><span class=\"line\">[AFNetworking requestData:^(<span class=\"built_in\">NSData</span> *data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@\"lealfy\"</span>;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n"},{"title":"Github+Hexo搭建个人博客详细教程","date":"2018-11-10T01:14:00.000Z","_content":"\n<a name=\"sl6tws\"></a>\n#### [](#sl6tws)安装Node.js\n\n1. 安装nvm\n\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n\n2. 安装node\n\n```powershell\n$ nvm install node\n```\n\n3. 验证node是否安装成功\n\n```powershell\n$  node -v\n$  v8.12.0\n```\n<a name=\"t8a8gr\"></a>\n#### [](#t8a8gr)安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n<a name=\"ua2lyy\"></a>\n#### [](#ua2lyy)Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n<a name=\"oefdft\"></a>\n#### [](#oefdft)配置_config.yml\n```\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n<a name=\"s6t5gs\"></a>\n#### [](#s6t5gs)编写博客\n```\n$ hexo new post '文章标题'\n```\n在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n<a name=\"ybauhr\"></a>\n#### [](#ybauhr)推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n<a name=\"padgfi\"></a>\n#### [](#padgfi)多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n\n1. 新建分支 hexo\n\n2. 在设置里将hexo设置为默认分支\n\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n\n<a name=\"xhgmdd\"></a>\n#### [](#xhgmdd)绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n\n1. 购买域名\n\n\n     一般去阿里云购买，具体流程网上很多，就不再细说\n\n2. 配置DNS地址\n\n\n     在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n\n3. 配置hexo文件\n\n\n     在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n\n4. 发布到github\n\n\n我的博客地址是[http://blog.ileafly.com](http://blog.ileafly.com)\n<a name=\"yst3oh\"></a>\n#### [](#yst3oh)绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n<a name=\"qvkuep\"></a>\n#### [](#qvkuep)自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。<br />我比较喜欢的主题是[Anisina](https://github.com/haojen/hexo-theme-Anisina)和[cafe](https://github.com/giscafer/hexo-theme-cafe)，这里就以[cafe](https://github.com/giscafer/hexo-theme-cafe)为例简述一下集成的流程。\n```\n# 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml\n```\n<a name=\"ctisce\"></a>\n#### [](#ctisce)集成评论\n目前比较好用的评论是[LiveRe](https://www.livere.com)，注册并按照City版，获取uid。在__config.yml作如下配置：\n```ruby\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'\n```\n\n\n\n","source":"_posts/yuque/Github+Hexo搭建个人博客详细教程.md","raw":"\n---\n\ntitle: Github+Hexo搭建个人博客详细教程\n\ndate: 2018-11-10 09:14:00 +0800\n\ncategories: Hexo\n\ntags: []\n\n---\n\n<a name=\"sl6tws\"></a>\n#### [](#sl6tws)安装Node.js\n\n1. 安装nvm\n\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n\n2. 安装node\n\n```powershell\n$ nvm install node\n```\n\n3. 验证node是否安装成功\n\n```powershell\n$  node -v\n$  v8.12.0\n```\n<a name=\"t8a8gr\"></a>\n#### [](#t8a8gr)安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n<a name=\"ua2lyy\"></a>\n#### [](#ua2lyy)Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n<a name=\"oefdft\"></a>\n#### [](#oefdft)配置_config.yml\n```\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n<a name=\"s6t5gs\"></a>\n#### [](#s6t5gs)编写博客\n```\n$ hexo new post '文章标题'\n```\n在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n<a name=\"ybauhr\"></a>\n#### [](#ybauhr)推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n<a name=\"padgfi\"></a>\n#### [](#padgfi)多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n\n1. 新建分支 hexo\n\n2. 在设置里将hexo设置为默认分支\n\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n\n<a name=\"xhgmdd\"></a>\n#### [](#xhgmdd)绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n\n1. 购买域名\n\n\n     一般去阿里云购买，具体流程网上很多，就不再细说\n\n2. 配置DNS地址\n\n\n     在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n\n3. 配置hexo文件\n\n\n     在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n\n4. 发布到github\n\n\n我的博客地址是[http://blog.ileafly.com](http://blog.ileafly.com)\n<a name=\"yst3oh\"></a>\n#### [](#yst3oh)绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n<a name=\"qvkuep\"></a>\n#### [](#qvkuep)自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。<br />我比较喜欢的主题是[Anisina](https://github.com/haojen/hexo-theme-Anisina)和[cafe](https://github.com/giscafer/hexo-theme-cafe)，这里就以[cafe](https://github.com/giscafer/hexo-theme-cafe)为例简述一下集成的流程。\n```\n# 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml\n```\n<a name=\"ctisce\"></a>\n#### [](#ctisce)集成评论\n目前比较好用的评论是[LiveRe](https://www.livere.com)，注册并按照City版，获取uid。在__config.yml作如下配置：\n```ruby\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'\n```\n\n\n\n","slug":"yuque/Github+Hexo搭建个人博客详细教程","published":1,"updated":"2019-06-12T08:35:22.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwszbi4900086owwkatx8sz5","content":"<p><a name=\"sl6tws\"></a></p>\n<h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a><a href=\"#sl6tws\"></a>安装Node.js</h4><ol>\n<li>安装nvm</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.<span class=\"number\">30.2</span>/install.sh | bash</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>安装node</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvm install node</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>验证node是否安装成功</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  node -v</span><br><span class=\"line\">$  v8.<span class=\"number\">12.0</span></span><br></pre></td></tr></table></figure>\n<p><a name=\"t8a8gr\"></a></p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a><a href=\"#t8a8gr\"></a>安装Hexo</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p>安装完成后，进入一个文件夹，执行<br><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install hexo --save</span><br></pre></td></tr></table></figure></p>\n<p><a name=\"ua2lyy\"></a></p>\n<h4 id=\"Github创建个人仓库\"><a href=\"#Github创建个人仓库\" class=\"headerlink\" title=\"Github创建个人仓库\"></a><a href=\"#ua2lyy\"></a>Github创建个人仓库</h4><p>在Github上创建一个新仓库，并命名为  <code>你的github用户名.github.io</code><br><a name=\"oefdft\"></a></p>\n<h4 id=\"配置-config-yml\"><a href=\"#配置-config-yml\" class=\"headerlink\" title=\"配置_config.yml\"></a><a href=\"#oefdft\"></a>配置_config.yml</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">   type: git</span><br><span class=\"line\">   repository: https://github.com/username/username.github.io</span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n<p><a name=\"s6t5gs\"></a></p>\n<h4 id=\"编写博客\"><a href=\"#编写博客\" class=\"headerlink\" title=\"编写博客\"></a><a href=\"#s6t5gs\"></a>编写博客</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &apos;文章标题&apos;</span><br></pre></td></tr></table></figure>\n<p>在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。<br><a name=\"ybauhr\"></a></p>\n<h4 id=\"推送站点\"><a href=\"#推送站点\" class=\"headerlink\" title=\"推送站点\"></a><a href=\"#ybauhr\"></a>推送站点</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p>上传成功后，访问<a href=\"https://username.github.io\" target=\"_blank\" rel=\"noopener\">https://username.github.io</a></p>\n<hr>\n<p>接下来再介绍一些进阶用法：<br><a name=\"padgfi\"></a></p>\n<h4 id=\"多台电脑管理hexo博客\"><a href=\"#多台电脑管理hexo博客\" class=\"headerlink\" title=\"多台电脑管理hexo博客\"></a><a href=\"#padgfi\"></a>多台电脑管理hexo博客</h4><p>利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。</p>\n<ol>\n<li><p>新建分支 hexo</p>\n</li>\n<li><p>在设置里将hexo设置为默认分支</p>\n</li>\n<li><p>clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支</p>\n</li>\n<li><p>新电脑需要重新安装hexo环境，安装完成后clone代码到本地</p>\n</li>\n</ol>\n<p><a name=\"xhgmdd\"></a></p>\n<h4 id=\"绑定个人域名\"><a href=\"#绑定个人域名\" class=\"headerlink\" title=\"绑定个人域名\"></a><a href=\"#xhgmdd\"></a>绑定个人域名</h4><p>拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程</p>\n<ol>\n<li>购买域名</li>\n</ol>\n<pre><code>一般去阿里云购买，具体流程网上很多，就不再细说\n</code></pre><ol start=\"2\">\n<li>配置DNS地址</li>\n</ol>\n<pre><code>在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n</code></pre><ol start=\"3\">\n<li>配置hexo文件</li>\n</ol>\n<pre><code>在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n</code></pre><ol start=\"4\">\n<li>发布到github</li>\n</ol>\n<p>我的博客地址是<a href=\"http://blog.ileafly.com\" target=\"_blank\" rel=\"noopener\">http://blog.ileafly.com</a><br><a name=\"yst3oh\"></a></p>\n<h4 id=\"绑定语雀管理博客内容\"><a href=\"#绑定语雀管理博客内容\" class=\"headerlink\" title=\"绑定语雀管理博客内容\"></a><a href=\"#yst3oh\"></a>绑定语雀管理博客内容</h4><p>可以利用语雀管理博客内容，非常方便，详细流程可参考<a href=\"http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/\" target=\"_blank\" rel=\"noopener\">使用语雀管理博客</a>。<br><a name=\"qvkuep\"></a></p>\n<h4 id=\"自定义主题\"><a href=\"#自定义主题\" class=\"headerlink\" title=\"自定义主题\"></a><a href=\"#qvkuep\"></a>自定义主题</h4><p>Hexo有非常非常多的主题，你可以在<a href=\"https://hexo.io/themes/index.html\" target=\"_blank\" rel=\"noopener\">Themes | Hexo</a>浏览这些主题，选择你喜欢的主题进行使用。<br>我比较喜欢的主题是<a href=\"https://github.com/haojen/hexo-theme-Anisina\" target=\"_blank\" rel=\"noopener\">Anisina</a>和<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\" rel=\"noopener\">cafe</a>，这里就以<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\" rel=\"noopener\">cafe</a>为例简述一下集成的流程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装</span><br><span class=\"line\">$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.</span><br><span class=\"line\"></span><br><span class=\"line\"># 更新cafe文件</span><br><span class=\"line\">cd themes/cafe</span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"># 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml</span><br></pre></td></tr></table></figure></p>\n<p><a name=\"ctisce\"></a></p>\n<h4 id=\"集成评论\"><a href=\"#集成评论\" class=\"headerlink\" title=\"集成评论\"></a><a href=\"#ctisce\"></a>集成评论</h4><p>目前比较好用的评论是<a href=\"https://www.livere.com\" target=\"_blank\" rel=\"noopener\">LiveRe</a>，注册并按照City版，获取uid。在__config.yml作如下配置：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">comment:</span></span><br><span class=\"line\">   <span class=\"symbol\">type:</span> livere</span><br><span class=\"line\">   <span class=\"symbol\">livere_id:</span> <span class=\"string\">'city'</span></span><br><span class=\"line\">   <span class=\"symbol\">livere_uid:</span> <span class=\"string\">'*******'</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a name=\"sl6tws\"></a></p>\n<h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a><a href=\"#sl6tws\"></a>安装Node.js</h4><ol>\n<li>安装nvm</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.<span class=\"number\">30.2</span>/install.sh | bash</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>安装node</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nvm install node</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>验证node是否安装成功</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  node -v</span><br><span class=\"line\">$  v8.<span class=\"number\">12.0</span></span><br></pre></td></tr></table></figure>\n<p><a name=\"t8a8gr\"></a></p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a><a href=\"#t8a8gr\"></a>安装Hexo</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p>安装完成后，进入一个文件夹，执行<br><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install hexo --save</span><br></pre></td></tr></table></figure></p>\n<p><a name=\"ua2lyy\"></a></p>\n<h4 id=\"Github创建个人仓库\"><a href=\"#Github创建个人仓库\" class=\"headerlink\" title=\"Github创建个人仓库\"></a><a href=\"#ua2lyy\"></a>Github创建个人仓库</h4><p>在Github上创建一个新仓库，并命名为  <code>你的github用户名.github.io</code><br><a name=\"oefdft\"></a></p>\n<h4 id=\"配置-config-yml\"><a href=\"#配置-config-yml\" class=\"headerlink\" title=\"配置_config.yml\"></a><a href=\"#oefdft\"></a>配置_config.yml</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">   type: git</span><br><span class=\"line\">   repository: https://github.com/username/username.github.io</span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n<p><a name=\"s6t5gs\"></a></p>\n<h4 id=\"编写博客\"><a href=\"#编写博客\" class=\"headerlink\" title=\"编写博客\"></a><a href=\"#s6t5gs\"></a>编写博客</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &apos;文章标题&apos;</span><br></pre></td></tr></table></figure>\n<p>在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。<br><a name=\"ybauhr\"></a></p>\n<h4 id=\"推送站点\"><a href=\"#推送站点\" class=\"headerlink\" title=\"推送站点\"></a><a href=\"#ybauhr\"></a>推送站点</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p>上传成功后，访问<a href=\"https://username.github.io\" target=\"_blank\" rel=\"noopener\">https://username.github.io</a></p>\n<hr>\n<p>接下来再介绍一些进阶用法：<br><a name=\"padgfi\"></a></p>\n<h4 id=\"多台电脑管理hexo博客\"><a href=\"#多台电脑管理hexo博客\" class=\"headerlink\" title=\"多台电脑管理hexo博客\"></a><a href=\"#padgfi\"></a>多台电脑管理hexo博客</h4><p>利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。</p>\n<ol>\n<li><p>新建分支 hexo</p>\n</li>\n<li><p>在设置里将hexo设置为默认分支</p>\n</li>\n<li><p>clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支</p>\n</li>\n<li><p>新电脑需要重新安装hexo环境，安装完成后clone代码到本地</p>\n</li>\n</ol>\n<p><a name=\"xhgmdd\"></a></p>\n<h4 id=\"绑定个人域名\"><a href=\"#绑定个人域名\" class=\"headerlink\" title=\"绑定个人域名\"></a><a href=\"#xhgmdd\"></a>绑定个人域名</h4><p>拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程</p>\n<ol>\n<li>购买域名</li>\n</ol>\n<pre><code>一般去阿里云购买，具体流程网上很多，就不再细说\n</code></pre><ol start=\"2\">\n<li>配置DNS地址</li>\n</ol>\n<pre><code>在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n</code></pre><ol start=\"3\">\n<li>配置hexo文件</li>\n</ol>\n<pre><code>在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n</code></pre><ol start=\"4\">\n<li>发布到github</li>\n</ol>\n<p>我的博客地址是<a href=\"http://blog.ileafly.com\" target=\"_blank\" rel=\"noopener\">http://blog.ileafly.com</a><br><a name=\"yst3oh\"></a></p>\n<h4 id=\"绑定语雀管理博客内容\"><a href=\"#绑定语雀管理博客内容\" class=\"headerlink\" title=\"绑定语雀管理博客内容\"></a><a href=\"#yst3oh\"></a>绑定语雀管理博客内容</h4><p>可以利用语雀管理博客内容，非常方便，详细流程可参考<a href=\"http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/\" target=\"_blank\" rel=\"noopener\">使用语雀管理博客</a>。<br><a name=\"qvkuep\"></a></p>\n<h4 id=\"自定义主题\"><a href=\"#自定义主题\" class=\"headerlink\" title=\"自定义主题\"></a><a href=\"#qvkuep\"></a>自定义主题</h4><p>Hexo有非常非常多的主题，你可以在<a href=\"https://hexo.io/themes/index.html\" target=\"_blank\" rel=\"noopener\">Themes | Hexo</a>浏览这些主题，选择你喜欢的主题进行使用。<br>我比较喜欢的主题是<a href=\"https://github.com/haojen/hexo-theme-Anisina\" target=\"_blank\" rel=\"noopener\">Anisina</a>和<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\" rel=\"noopener\">cafe</a>，这里就以<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\" rel=\"noopener\">cafe</a>为例简述一下集成的流程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装</span><br><span class=\"line\">$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.</span><br><span class=\"line\"></span><br><span class=\"line\"># 更新cafe文件</span><br><span class=\"line\">cd themes/cafe</span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\"># 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml</span><br></pre></td></tr></table></figure></p>\n<p><a name=\"ctisce\"></a></p>\n<h4 id=\"集成评论\"><a href=\"#集成评论\" class=\"headerlink\" title=\"集成评论\"></a><a href=\"#ctisce\"></a>集成评论</h4><p>目前比较好用的评论是<a href=\"https://www.livere.com\" target=\"_blank\" rel=\"noopener\">LiveRe</a>，注册并按照City版，获取uid。在__config.yml作如下配置：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">comment:</span></span><br><span class=\"line\">   <span class=\"symbol\">type:</span> livere</span><br><span class=\"line\">   <span class=\"symbol\">livere_id:</span> <span class=\"string\">'city'</span></span><br><span class=\"line\">   <span class=\"symbol\">livere_uid:</span> <span class=\"string\">'*******'</span></span><br></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjwszbi4900086owwkatx8sz5","category_id":"cjwszbi4300056owwyhioqo9n","_id":"cjwszbi4b000c6owwjtxk6x3e"},{"post_id":"cjwszbi3y00036owwzqb1csa0","category_id":"cjwszbi4300056owwyhioqo9n","_id":"cjwszbi4c000e6owwge7gt3fb"},{"post_id":"cjwszbi4100046owwutxv03x8","category_id":"cjwszbi4a00096oww17uxt6hv","_id":"cjwszbi4c000g6oww7ko8shw5"},{"post_id":"cjwszbi4400066oww6btdhgwi","category_id":"cjwszbi4a00096oww17uxt6hv","_id":"cjwszbi4d000h6owwswk7ep2h"}],"PostTag":[{"post_id":"cjwszbi4100046owwutxv03x8","tag_id":"cjwszbi4800076owwzvtmtle0","_id":"cjwszbi4b000b6owwcvfzkwo0"},{"post_id":"cjwszbi4400066oww6btdhgwi","tag_id":"cjwszbi4800076owwzvtmtle0","_id":"cjwszbi4c000f6oww5vi92qcl"}],"Tag":[{"name":"iOS","_id":"cjwszbi4800076owwzvtmtle0"}]}}