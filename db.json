{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/cafe/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/cafe/source/images/fly-to-top.png","path":"images/fly-to-top.png","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/js/is.js","path":"js/is.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/js/elevator.js","path":"js/elevator.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/js/posts.js","path":"js/posts.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/duoshuo/embed.js","path":"duoshuo/embed.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/jquery/jquery.min.js","path":"jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/cafe/source/themes/screenshots/Cafe.png","path":"themes/screenshots/Cafe.png","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/cafe/.gitignore","hash":"a632e0ef685c46927968336af6b03ab3465d4fb2","modified":1513165115000},{"_id":"themes/cafe/.bowerrc","hash":"5d8502d31f0ed07e935bc6faf5e7f8ce8308ab75","modified":1513165115000},{"_id":"themes/cafe/README_en.md","hash":"c66ddb0326313f1b912d41d735e22dd2d10509e1","modified":1513165115000},{"_id":"themes/cafe/README.md","hash":"7f7b7b853aa9f62d97fb2e5979e962dd47b93aaa","modified":1513165115000},{"_id":"themes/cafe/bower.json","hash":"b62df738176f21afb7f9bac2ddca8b269fd4b863","modified":1513165115000},{"_id":"themes/cafe/_config.yml","hash":"039520e33fd81bf3f8d0171c281209f294750ef9","modified":1513250289000},{"_id":"themes/cafe/cafe-qrcode.png","hash":"4fef2c889376a208a49aa92c582b147e7e005d23","modified":1513165115000},{"_id":"themes/cafe/package.json","hash":"bf40790696da9a813489f49dcf90a87f9114869c","modified":1513165115000},{"_id":"source/.DS_Store","hash":"43412485ea99ade5daeaa01645b022db78a627bd","modified":1496893761000},{"_id":"themes/cafe/webpack.config.js","hash":"7fa25bf7c2bf831c8dfcece8bbeee6cb5c2b2c80","modified":1513165115000},{"_id":"source/CNAME","hash":"ff2f59c6b412222407781fdc7d9a8b96fe7cc391","modified":1488936436000},{"_id":"themes/cafe/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1513165115000},{"_id":"themes/cafe/.git/config","hash":"1c091a5565c6432135a663d4ffe26c8a2b3d2aca","modified":1513165115000},{"_id":"themes/cafe/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1513165094000},{"_id":"themes/cafe/.git/index","hash":"140f4411ccdd3be5b17514fe08afe46c17f7a675","modified":1517299963000},{"_id":"themes/cafe/scripts/fancybox.js","hash":"1c20613889139c652923b57b42ce6f7bc279511b","modified":1513165115000},{"_id":"themes/cafe/scripts/extend.generator.js","hash":"06d801d46268351c34f1b0a2fc67726cf9418baa","modified":1513165115000},{"_id":"themes/cafe/.git/packed-refs","hash":"0708400921340a87eedd4f8551bf9b511d75896f","modified":1513165115000},{"_id":"themes/cafe/assets/duoshuo_comment.png","hash":"33402149f82b66ff4ed405f44beb06eb0172b6de","modified":1513165115000},{"_id":"themes/cafe/assets/share.png","hash":"823926d9cb8985ceb93a119ef138f9638a8ead1a","modified":1513165115000},{"_id":"themes/cafe/layout/archive.ejs","hash":"11912b8e50dafbe9b0a65df0beaeab64fde90abe","modified":1513165115000},{"_id":"themes/cafe/layout/category.ejs","hash":"f46e99e5b68c2ee67bdab068b1da4029bc09847d","modified":1513165115000},{"_id":"themes/cafe/layout/layout.ejs","hash":"54719bf692ee75c4e0fc4a39dec83484e4851307","modified":1513165115000},{"_id":"themes/cafe/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1513165115000},{"_id":"themes/cafe/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1513165115000},{"_id":"themes/cafe/layout/tag.ejs","hash":"4349f382b07603f9d2c03dd4df70ddea9b9a035c","modified":1513165115000},{"_id":"themes/cafe/languages/en.yml","hash":"4d072fac64d756579962d3c0d10e300c11f99668","modified":1513165115000},{"_id":"themes/cafe/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1513165115000},{"_id":"themes/cafe/languages/default.yml","hash":"0f4186f8e0c5d83cddf443fb9d7d4f200780831b","modified":1513165115000},{"_id":"themes/cafe/languages/ru.yml","hash":"2b9f264074acbbdd46512d8d7488e7ec0eee2da9","modified":1513165115000},{"_id":"themes/cafe/languages/zh-CN.yml","hash":"fd7eb6f2395cd8c483119bb96882c7dd3004881d","modified":1513165115000},{"_id":"themes/cafe/languages/no.yml","hash":"d326d07449152e874d419c21fe31bbbfa624809c","modified":1513165115000},{"_id":"themes/cafe/languages/zh-TW.yml","hash":"a53f356900ffd40cb87dfbb96e5c677ed88e9992","modified":1513165115000},{"_id":"themes/cafe/languages/nl.yml","hash":"218d1ef7863e884de5e48c6a9fa7c8e3a07a88c6","modified":1513165115000},{"_id":"themes/cafe/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1513165115000},{"_id":"source/_posts/3DTouch开发.md","hash":"a99801c57bebc4f1383434bbb88c3337fc77f6d7","modified":1535708874252},{"_id":"source/_posts/.DS_Store","hash":"3209ea01fef60ac0ce8be4e21bdf7aadec478cb3","modified":1479371651000},{"_id":"source/_posts/CocoaPods升级后问题解决.md","hash":"c15b077eacc16ccd2a987fd7f8944ef1e26a3b4c","modified":1535709059569},{"_id":"source/_posts/Bootstrap框架入门.md","hash":"d144655a13dfe9f105783a51451b9306d5f1c739","modified":1535708746251},{"_id":"source/_posts/Block用法小结.md","hash":"a6c7e5f69582aa05a171c6855c1ad42b7601d3a4","modified":1535708694769},{"_id":"source/_posts/Hexo多台电脑同步.md","hash":"5d00d52b78e36db1afe650ea0da67a59528f98ae","modified":1535709109879},{"_id":"source/_posts/Markdown语法初探.md","hash":"3d0dd146d550e8eaa49b7930b942a5633e0817ac","modified":1535708977592},{"_id":"source/_posts/EPUB文件格式解析.md","hash":"2eda2aeee7d40c079fc58fef21b2a161fc1040ae","modified":1535708587167},{"_id":"source/_posts/NS-UNAVAILABLE和NS-DESIGNATED是什么.md","hash":"8ce7df2735e31b385cb88d61e0c09bf20070a409","modified":1535708522638},{"_id":"source/_posts/ReactNative入门.md","hash":"bd5a16ce8b17b990d6af974749a3d4c1b3bd909d","modified":1535709229237},{"_id":"source/_posts/PHP与iOS之间的AES加解密.md","hash":"8e6a4a43011c995e5613072b58e4dd7217de6a29","modified":1535708789116},{"_id":"source/_posts/UIWebView加载本地html.md","hash":"a3963570cf36c0b0dbd416b14ecf31b83c3b864a","modified":1535708857049},{"_id":"source/_posts/SDWebImage与YYWebImage加载gif对比.md","hash":"5136bf87096965510daa6d40d0c8cec7462b98b6","modified":1535708437788},{"_id":"source/_posts/Mac搭建基于Eclipse的J2EE开发环境.md","hash":"952f486f720456fdccb4724ed52d9bf71b005534","modified":1535708227325},{"_id":"source/_posts/ZYLoading-自定义Loading控件.md","hash":"45b1cf88361f0776fa4c3fae8a1f66b5086c89c9","modified":1535708505721},{"_id":"source/_posts/React-Native之Navigator.md","hash":"e88afaa818c451e87e4d67e1af9f03867e093b93","modified":1535709268549},{"_id":"source/_posts/Swift开源项目ObjectMapper实践.md","hash":"7c33bfa48c957187ea4b6284c0988fdb0cf29147","modified":1535708635470},{"_id":"source/_posts/Xcode9新特性汇总.md","hash":"46ba82a95f9bd237ae25a7ffd568d8bbdc6fbbae","modified":1535708515071},{"_id":"source/_posts/iOS-让子View不响应父View的手势.md","hash":"074506a2198088b98fe2d6bf73a1b0a9445a88dd","modified":1535709077560},{"_id":"source/_posts/Xcode统计整个项目代码行数.md","hash":"c2e8adca096a005dcf1dd7695c24e024f4647f64","modified":1535708843599},{"_id":"source/_posts/iOS10系统下的推送开发.md","hash":"5fea0ea6db1a3f5caffd06c3e3588ecd2782b237","modified":1535709204387},{"_id":"source/_posts/iOS复制字符串到剪贴板.md","hash":"c70bba85b71c5b8862b944adac35b33b1743c770","modified":1535708208963},{"_id":"source/_posts/iOS导航栏显示与隐藏控制.md","hash":"6fb06163347668ff49a3903b5900a49f617b4ea5","modified":1535708469690},{"_id":"source/_posts/git命令行入门.md","hash":"28fde62d56b7f354c9dbb1fd1691f5d70c70760b","modified":1535709019168},{"_id":"source/_posts/iOS11开发者需要知道的改变.md","hash":"fb09e8fc431c8e8d539cb13415e8cc42f2127f21","modified":1535708606065},{"_id":"source/_posts/iOS开发小结之H5与OC交互.md","hash":"bb38310f3d3c0eea07861f6fc2d4db28a5a1c233","modified":1535708816982},{"_id":"source/_posts/iOS项目添加自定义字体.md","hash":"ea099f0f627001097b88ffae33d1b500df50aaf7","modified":1535708902335},{"_id":"source/_posts/iOS的引用计数与循环引用.md","hash":"cf1611025705b7dcae2c3bd183c00a048294590a","modified":1535708445313},{"_id":"source/_posts/runtime机制.md","hash":"06db43fe81eb14da22896bf70385871108286a25","modified":1535708889414},{"_id":"source/_posts/个人博客进阶-Hexo搭建博客.md","hash":"7d56c9a284cc835d3615222da185e10ec85a3aac","modified":1535708997153},{"_id":"source/_posts/如何使用OmniPlan.md","hash":"cfdd68800a6494ec9fb9295f3fd17ecf134723c0","modified":1535708192796},{"_id":"source/_posts/如何搭建属于自己的博客.md","hash":"4b349dc8bf6a62afca74a562b162cc631b7ad5ab","modified":1535708921452},{"_id":"source/_posts/利用SDWebImage下载图片.md","hash":"69ce8dc3702b3dbe75f3817c8fc16af18507b856","modified":1535708650993},{"_id":"source/_posts/开发者账号批量导入设备号.md","hash":"4fa48ee58aff2d903e4f7e58bed89fcb25478aa6","modified":1535708535252},{"_id":"source/_posts/搭建私有Pod.md","hash":"c3e4b7684d63fcf94fe10927dae0c43df4ba0aed","modified":1535708986856},{"_id":"source/_posts/引导用户设置支付方式.md","hash":"36cbd048b459eba311fdc6a68b6e84459070e385","modified":1535708458229},{"_id":"source/_posts/私有pod创建进阶-如何通过pod管理静态库.md","hash":"77607cbdd3e59e962fba420e05965648b81321b3","modified":1535709033035},{"_id":"source/_posts/移除Pod管理的库后编译报Link错误.md","hash":"bd43d14e7ea7b49d62857bd3e39aff9b6184041b","modified":1535709093794},{"_id":"source/_posts/自动化打包IPA脚本.md","hash":"b007b2d07a8356f5412bdb75c64697926564d345","modified":1535709247346},{"_id":"source/_posts/轻松搞定状态栏颜色变化.md","hash":"202ac8abb1e9e9413c07450212aeb2b850a718a3","modified":1535708478198},{"_id":"source/_posts/自定义xopen命令打开工程.md","hash":"d02cf94b2b9386808972ad4bed0d4cf5f02cb22a","modified":1535709256813},{"_id":"source/categories/index.md","hash":"110798b7c254007cd39bede8c638cc76c745f1b3","modified":1479795079000},{"_id":"source/_posts/自定义快捷代码片段.md","hash":"85c1da68051ca1f914148df1eb55d0f5f53a9f85","modified":1535708544961},{"_id":"source/_posts/深入浅出Texture-高性能界面的解决方案.md","hash":"b6e78b64caa57705d3ba8ca5acd4dbf2b30804bb","modified":1535708707598},{"_id":"source/_posts/自定义UIPageControl.md","hash":"d81167039b5c4cbf41fda476887fee26b664e16e","modified":1535708727242},{"_id":"themes/cafe/layout/_scripts/index.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513165115000},{"_id":"source/about/index.md","hash":"3921e21b81b978bd9c73cd3f6918a876467f49ad","modified":1535707959789},{"_id":"source/tags/index.md","hash":"738bc3f8e6d7ed60bbe978a7aead9044a01d6e24","modified":1479793806000},{"_id":"themes/cafe/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1513165094000},{"_id":"themes/cafe/.git/logs/HEAD","hash":"56fe373837b9ea39204605892084abf7c1a6223a","modified":1513165115000},{"_id":"themes/cafe/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1513165094000},{"_id":"themes/cafe/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1513165094000},{"_id":"themes/cafe/layout/_partial/archive.ejs","hash":"b7358ffcbd26bc2c6c7bf384c4fb7b68085b6cbc","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/after-footer.ejs","hash":"e48868420643950050f8622a1a68d738f0fddde5","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/article.ejs","hash":"1d6e90775a6f52b862047adf2369ce8c1282554a","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/archive-post.ejs","hash":"4c7716e53396abdf828b518f90df3c00e63349da","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/comments.ejs","hash":"43217242b743530f6dd1c08e41af5c255f14abd9","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/footer.ejs","hash":"fbc03f56835e967bfe6021a2102f058b1ec27af5","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/header.ejs","hash":"ee530030409ee4cd67136ad23c96aa1b3466293e","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/head.ejs","hash":"6774dad5680a91f8a4d21e5d73189b92a9b6864b","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/random_posts.ejs","hash":"8ac10cb23345a04de2683bcfc2122f26111131ed","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/sidebar.ejs","hash":"ce3ecf7c74fd5f50aebada49e403152de114e6bb","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/widget.ejs","hash":"fe22996588b33eb9d44ab104c6ed5687fb11cac6","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/index.ejs","hash":"219d269b6840d5dde5a14e4f26ef49d102d32532","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/archive.ejs","hash":"39a047c9bcfbce9d6a815b3938211213bd5268f7","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/category.ejs","hash":"6064d276caf727d3e082343f9a30b015d30fdd48","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/hot_comment_posts.ejs","hash":"819fd75aad2d16d58bc06054b8fdf966d222576a","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/lastest_comments.ejs","hash":"518f17d2a3ca5daca4a8a6ed186bae3ae348fde5","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/post_content.ejs","hash":"9f17038635d221719c7ef10ae473f7f5b288fc9a","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/social.ejs","hash":"601c0295ac544942bc78185ce5378a3a19f267fe","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/recent_posts.ejs","hash":"1eca91f3cd8fb4563f708678130138be9404b70e","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/tag.ejs","hash":"e82a6951bf13a05f0d2218516d51fac1953d6739","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/friendly_link.ejs","hash":"0c01b13ad81b729fd1f39e01b819d6f315a411b8","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/wechat.ejs","hash":"22d19c533a30e41c56a45e4edb74ec30c8c70978","modified":1513165115000},{"_id":"themes/cafe/layout/_widget/tagcloud.ejs","hash":"a5846d3bd367a8147d84d57e64ebc93441378cd8","modified":1513165115000},{"_id":"themes/cafe/layout/partials/back2top.ejs","hash":"3b69f1d825f1837100151197da2b13b34676345d","modified":1513165115000},{"_id":"themes/cafe/layout/partials/hot-comment-posts.ejs","hash":"af27de063408d3336ea7bd700d3ea2c4bef71ae0","modified":1513165115000},{"_id":"themes/cafe/layout/partials/lastest-comments.ejs","hash":"64cf0da989e6aeb4635482f48355d74447ba32c8","modified":1513165115000},{"_id":"themes/cafe/layout/partials/recent-posts.ejs","hash":"c4d6ad99fabe8a9821511e2c39861b268779d40e","modified":1513165115000},{"_id":"themes/cafe/source/_data/themes.yml","hash":"dbbd2878f85379b3c388f09539327085e0cdde34","modified":1513165115000},{"_id":"themes/cafe/layout/partials/pagination.ejs","hash":"146ae79bd5a89524d5f8026c21ed34a557fe753d","modified":1513165115000},{"_id":"themes/cafe/source/css/_variables.styl","hash":"73cd2ad7c06c49b6f01ed0cd207e7aac55d22c8c","modified":1513165115000},{"_id":"themes/cafe/source/css/_extend.styl","hash":"faef85ad9c2806b634a638b0b05b825277c11e45","modified":1513165115000},{"_id":"themes/cafe/source/css/style.styl","hash":"78a349fe6901a1ebe6668b58a33ca129cf9cdd35","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513165115000},{"_id":"themes/cafe/source/images/fly-to-top.png","hash":"f189038da3c68a8012e924185a1faee98bde3003","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1513165115000},{"_id":"themes/cafe/source/js/is.js","hash":"457446cf7fe0b08bfa197ee76435d273b456deaa","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1513165115000},{"_id":"themes/cafe/source/js/elevator.js","hash":"2aab182c3f08aa939bbf09faf49e79e0681a6389","modified":1513165115000},{"_id":"themes/cafe/source/js/posts.js","hash":"88ee22b03af3730548392a11725e0e1c015e43a0","modified":1534916205923},{"_id":"themes/cafe/source/js/script.js","hash":"320cc11fb445658e7a1e1bb2e9da499ee579d755","modified":1513165115000},{"_id":"themes/cafe/source/duoshuo/embed.js","hash":"6a8d90f99d17a614312f87d9a6a7182c9cb484f4","modified":1513165115000},{"_id":"themes/cafe/source/jquery/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1513165115000},{"_id":"themes/cafe/.git/refs/heads/master","hash":"ee5fcaedadc36a3fc117d11645d9f896d0295bd1","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/duoshuo.ejs","hash":"0ea7f7effe32f7c9b0716c380850223feb262bcd","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1513165115000},{"_id":"themes/cafe/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/disqus.ejs","hash":"f9543a67619272c9ff23b461ffcc63b504385461","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/duoshuo.ejs","hash":"a37a59cf0226afc1d187810c81c61f4bf5a6a6b7","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/gentie.ejs","hash":"7bb3a0aa215dba09f87bf227b170d54ba69cadb3","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/gitment.ejs","hash":"25c71114ff0ede012d2dcb72cfb4e821f1744634","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/index.ejs","hash":"e32b4c07c55dae75fefbe51d6afc2a0a760f2958","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/changyan.ejs","hash":"b32598bc07328d8118f6b8b8b898a5d3dba4adc0","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/comments/youyan.ejs","hash":"466db2fad7c05b57d8987fc0e042e76072b4e6b2","modified":1513165115000},{"_id":"themes/cafe/layout/_third-part/mathjax/index.ejs","hash":"7b03a461fd2caf4662665a93c5d0e22b6a2ff1a6","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/archive.styl","hash":"bcc996ab9d1a3a2e0f754043a6c93ddd314d9987","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/article.styl","hash":"1273f03633fe8d4199b6269663fcb71dd2c81297","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/comment.styl","hash":"3477b4ecb2b188528b4f9c12fe78369110e0616b","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/custom.styl","hash":"f162ddfa65c268d79425e8c143688481f559ad2c","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/footer.styl","hash":"17fb21e25e7cdd57b3a33d402563d7c543ba9218","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/header.styl","hash":"56b324a23438b1b72c3b1de72ff123c5ca2ca266","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/duoshuo.styl","hash":"5c9cb2c43be136a3cc83fb961b2e030e34cdd0f7","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/random-post.styl","hash":"dba79ab57f6236d7128f3b7680eb2f6ccc84c26e","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/highlight.styl","hash":"83af177b67e71f88a2a58cad944fb1460a41f752","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/other.styl","hash":"e8892f04955c0738bd80bf92d72ee634d2a4e01a","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/sidebar-aside.styl","hash":"cd6e5f50b9db9a9f582995c16d634b1c427a2d00","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/sidebar.styl","hash":"ecd3303b117ae929558899d491e12094d4117829","modified":1513165115000},{"_id":"themes/cafe/source/css/_partial/social.styl","hash":"fc8d62aada96c75930dc03f6d4af83595eb44e71","modified":1513165115000},{"_id":"themes/cafe/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1513165115000},{"_id":"themes/cafe/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1513165115000},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513165115000},{"_id":"themes/cafe/source/themes/screenshots/Cafe.png","hash":"6f639068117b8d44005730864cc0b05a11b28d73","modified":1513165115000},{"_id":"themes/cafe/.git/objects/pack/pack-28fce2894ee947a8d41bf89fb6f2c880939ca565.idx","hash":"db58d4e6e10570ec9f6469171d59e9c4dae4e435","modified":1513165115000},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1513165115000},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1513165115000},{"_id":"themes/cafe/.git/logs/refs/heads/master","hash":"56fe373837b9ea39204605892084abf7c1a6223a","modified":1513165115000},{"_id":"themes/cafe/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1513165115000},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1513165115000},{"_id":"themes/cafe/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1513165115000},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1513165115000},{"_id":"themes/cafe/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1513165115000},{"_id":"themes/cafe/.git/logs/refs/remotes/origin/HEAD","hash":"56fe373837b9ea39204605892084abf7c1a6223a","modified":1513165115000},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1513165115000},{"_id":"themes/cafe/assets/pc-display.gif","hash":"fb84eb2ba958b1e02ad5e178a6f367a561cd9252","modified":1513165115000},{"_id":"themes/cafe/assets/mobie-display.gif","hash":"d20f7aa46d9bf618ba1ebaf9b6bda71b030f0ce9","modified":1513165115000},{"_id":"themes/cafe/.git/objects/pack/pack-28fce2894ee947a8d41bf89fb6f2c880939ca565.pack","hash":"6bd681c89dd53672b356cfc3781c9d5c32dfac0f","modified":1513165115000}],"Category":[{"name":"iOS","_id":"cjlhoqwhd0004kj79xfgubvoc"},{"name":"前端","_id":"cjlhoqwhu000mkj797646sgzv"},{"name":"博客","_id":"cjlhoqwhx000tkj79c55hn3s3"},{"name":"其他","_id":"cjlhoqwhz0010kj79o4gfoir1"},{"name":"ReactNative","_id":"cjlhoqwi20017kj79z1s0vwqk"},{"name":"PHP","_id":"cjlhoqwi6001ekj79ytbwup14"},{"name":"Git","_id":"cjlhoqwip0021kj79a7lpn76y"},{"name":"工具","_id":"cjlht09aw004dkj79s4th872p"},{"name":"PHP","parent":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhtd1ez005ekj796etnhon7"}],"Data":[],"Page":[{"title":"categories","date":"2016-11-22T06:11:19.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-22 14:11:19\n---\n","updated":"2016-11-22T06:11:19.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjlhoqwhb0001kj792h08rqg3","content":"","excerpt":"","more":""},{"title":"个人简介","date":"2017-02-16T05:58:47.000Z","_content":"\n","source":"about/index.md","raw":"title: 个人简介\ndate: 2017-02-16 13:58:47\n---\n\n","updated":"2018-08-31T09:32:39.789Z","path":"about/index.html","_id":"cjlhoqwhd0003kj79m1653chi","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-11-22T05:50:06.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-22 13:50:06\n---\n","updated":"2016-11-22T05:50:06.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjlhoqwhi0007kj792q19fibt","content":"","excerpt":"","more":""}],"Post":[{"title":"3DTouch开发","date":"2016-12-30T08:15:00.000Z","_content":"\n### 准备工作\n开发3DTouch功能需要做好以下准备工作：\n    1. iPhone6s或以上的设备\n    2. iOS9或以上的系统\n    3. Xcode7或以上的开发环境\n\n### 主屏幕按压应用图标展示快捷选项\n应用最多可以有4个快捷选项标签，iOS9为我们提供了两种方式来开发按压应用图片展示快捷选项的功能\n1. 静态标签\n   静态标签是我们通过项目的plist文件进行配置的，我们需要在plist里手动添加一个属性`UIApplicationShortcutItems`，类型为数组，每个元素即表示一个快捷选项标签\n   每个快捷选项标签由以下参数构成：\n   `UIApplicationShortcutItemTitle` 标签标题 (必填)\n   `UIApplicationShortcutItemType` 标签的唯一标识 (必填)\n   `UIApplicationShortcutItemIconType` 使用系统图片的类型\n   `UIApplicationShortcutItemIconFile` 使用项目中的图片作为标签图标\n   `UIApplicationShortcutItemSubtitle` 标签副标题\n   `UIApplicationShortcutItemUserInfo` 字典信息，用于传值\n\n2. 动态标签\n   静态标签添加比较方便，但是太不灵活，还好苹果给我们提供了接口来配置快捷选项，下面是添加快捷选项的代码：\n   ```\n   func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        // Override point for customization after application launch.\n        \n        self.createShortcutItems()\n        \n        return true\n    }\n\n   // 创建应用图标上的3D Touch快捷选项\n    func createShortcutItems() {\n        if #available(iOS 9.0, *) {\n            let icon: UIApplicationShortcutIcon = UIApplicationShortcutIcon.init(type: .share)\n            \n            let item: UIApplicationShortcutItem = UIApplicationShortcutItem.init(type: \"com.ileafly.3DTouchDemo.share\", localizedTitle: \"分享\", localizedSubtitle: nil, icon: icon, userInfo: nil)\n            \n            UIApplication.shared.shortcutItems = [item]\n        } else {\n            // Fallback on earlier versions\n        }\n    }\n   ```\n\n3. 点击快捷选项标签进入应用的响应\n\n  ```\n  @available(iOS 9.0, *) // 只有9系统才能调用此方法\n    func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {\n        print(shortcutItem);\n        \n        if let userInfo = shortcutItem.userInfo {\n            print(userInfo);\n        }\n    }\n\n  ```\n  \n  #### 参考文章\n  \n  [iOS 3D touch 开发(一) Home Screen Quick Actions](http://liuyanwei.jumppo.com/2016/03/21/iOS-3DTouch-1.html)\n\n","source":"_posts/3DTouch开发.md","raw":"title: 3DTouch开发\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2016-12-30 16:15:00\n---\n\n### 准备工作\n开发3DTouch功能需要做好以下准备工作：\n    1. iPhone6s或以上的设备\n    2. iOS9或以上的系统\n    3. Xcode7或以上的开发环境\n\n### 主屏幕按压应用图标展示快捷选项\n应用最多可以有4个快捷选项标签，iOS9为我们提供了两种方式来开发按压应用图片展示快捷选项的功能\n1. 静态标签\n   静态标签是我们通过项目的plist文件进行配置的，我们需要在plist里手动添加一个属性`UIApplicationShortcutItems`，类型为数组，每个元素即表示一个快捷选项标签\n   每个快捷选项标签由以下参数构成：\n   `UIApplicationShortcutItemTitle` 标签标题 (必填)\n   `UIApplicationShortcutItemType` 标签的唯一标识 (必填)\n   `UIApplicationShortcutItemIconType` 使用系统图片的类型\n   `UIApplicationShortcutItemIconFile` 使用项目中的图片作为标签图标\n   `UIApplicationShortcutItemSubtitle` 标签副标题\n   `UIApplicationShortcutItemUserInfo` 字典信息，用于传值\n\n2. 动态标签\n   静态标签添加比较方便，但是太不灵活，还好苹果给我们提供了接口来配置快捷选项，下面是添加快捷选项的代码：\n   ```\n   func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        // Override point for customization after application launch.\n        \n        self.createShortcutItems()\n        \n        return true\n    }\n\n   // 创建应用图标上的3D Touch快捷选项\n    func createShortcutItems() {\n        if #available(iOS 9.0, *) {\n            let icon: UIApplicationShortcutIcon = UIApplicationShortcutIcon.init(type: .share)\n            \n            let item: UIApplicationShortcutItem = UIApplicationShortcutItem.init(type: \"com.ileafly.3DTouchDemo.share\", localizedTitle: \"分享\", localizedSubtitle: nil, icon: icon, userInfo: nil)\n            \n            UIApplication.shared.shortcutItems = [item]\n        } else {\n            // Fallback on earlier versions\n        }\n    }\n   ```\n\n3. 点击快捷选项标签进入应用的响应\n\n  ```\n  @available(iOS 9.0, *) // 只有9系统才能调用此方法\n    func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {\n        print(shortcutItem);\n        \n        if let userInfo = shortcutItem.userInfo {\n            print(userInfo);\n        }\n    }\n\n  ```\n  \n  #### 参考文章\n  \n  [iOS 3D touch 开发(一) Home Screen Quick Actions](http://liuyanwei.jumppo.com/2016/03/21/iOS-3DTouch-1.html)\n\n","slug":"3DTouch开发","published":1,"updated":"2018-08-31T09:47:54.252Z","_id":"cjlhoqwh70000kj79picqjd8l","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>开发3DTouch功能需要做好以下准备工作：</p>\n<pre><code>1. iPhone6s或以上的设备\n2. iOS9或以上的系统\n3. Xcode7或以上的开发环境\n</code></pre><h3 id=\"主屏幕按压应用图标展示快捷选项\"><a href=\"#主屏幕按压应用图标展示快捷选项\" class=\"headerlink\" title=\"主屏幕按压应用图标展示快捷选项\"></a>主屏幕按压应用图标展示快捷选项</h3><p>应用最多可以有4个快捷选项标签，iOS9为我们提供了两种方式来开发按压应用图片展示快捷选项的功能</p>\n<ol>\n<li><p>静态标签<br>静态标签是我们通过项目的plist文件进行配置的，我们需要在plist里手动添加一个属性<code>UIApplicationShortcutItems</code>，类型为数组，每个元素即表示一个快捷选项标签<br>每个快捷选项标签由以下参数构成：<br><code>UIApplicationShortcutItemTitle</code> 标签标题 (必填)<br><code>UIApplicationShortcutItemType</code> 标签的唯一标识 (必填)<br><code>UIApplicationShortcutItemIconType</code> 使用系统图片的类型<br><code>UIApplicationShortcutItemIconFile</code> 使用项目中的图片作为标签图标<br><code>UIApplicationShortcutItemSubtitle</code> 标签副标题<br><code>UIApplicationShortcutItemUserInfo</code> 字典信息，用于传值</p>\n</li>\n<li><p>动态标签<br>静态标签添加比较方便，但是太不灵活，还好苹果给我们提供了接口来配置快捷选项，下面是添加快捷选项的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</div><div class=\"line\">     // Override point for customization after application launch.</div><div class=\"line\">     </div><div class=\"line\">     self.createShortcutItems()</div><div class=\"line\">     </div><div class=\"line\">     return true</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">// 创建应用图标上的3D Touch快捷选项</div><div class=\"line\"> func createShortcutItems() &#123;</div><div class=\"line\">     if #available(iOS 9.0, *) &#123;</div><div class=\"line\">         let icon: UIApplicationShortcutIcon = UIApplicationShortcutIcon.init(type: .share)</div><div class=\"line\">         </div><div class=\"line\">         let item: UIApplicationShortcutItem = UIApplicationShortcutItem.init(type: &quot;com.ileafly.3DTouchDemo.share&quot;, localizedTitle: &quot;分享&quot;, localizedSubtitle: nil, icon: icon, userInfo: nil)</div><div class=\"line\">         </div><div class=\"line\">         UIApplication.shared.shortcutItems = [item]</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Fallback on earlier versions</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>点击快捷选项标签进入应用的响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@available(iOS 9.0, *) // 只有9系统才能调用此方法</div><div class=\"line\">  func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123;</div><div class=\"line\">      print(shortcutItem);</div><div class=\"line\">      </div><div class=\"line\">      if let userInfo = shortcutItem.userInfo &#123;</div><div class=\"line\">          print(userInfo);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p>  <a href=\"http://liuyanwei.jumppo.com/2016/03/21/iOS-3DTouch-1.html\" target=\"_blank\" rel=\"external\">iOS 3D touch 开发(一) Home Screen Quick Actions</a></p>\n","excerpt":"","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>开发3DTouch功能需要做好以下准备工作：</p>\n<pre><code>1. iPhone6s或以上的设备\n2. iOS9或以上的系统\n3. Xcode7或以上的开发环境\n</code></pre><h3 id=\"主屏幕按压应用图标展示快捷选项\"><a href=\"#主屏幕按压应用图标展示快捷选项\" class=\"headerlink\" title=\"主屏幕按压应用图标展示快捷选项\"></a>主屏幕按压应用图标展示快捷选项</h3><p>应用最多可以有4个快捷选项标签，iOS9为我们提供了两种方式来开发按压应用图片展示快捷选项的功能</p>\n<ol>\n<li><p>静态标签<br>静态标签是我们通过项目的plist文件进行配置的，我们需要在plist里手动添加一个属性<code>UIApplicationShortcutItems</code>，类型为数组，每个元素即表示一个快捷选项标签<br>每个快捷选项标签由以下参数构成：<br><code>UIApplicationShortcutItemTitle</code> 标签标题 (必填)<br><code>UIApplicationShortcutItemType</code> 标签的唯一标识 (必填)<br><code>UIApplicationShortcutItemIconType</code> 使用系统图片的类型<br><code>UIApplicationShortcutItemIconFile</code> 使用项目中的图片作为标签图标<br><code>UIApplicationShortcutItemSubtitle</code> 标签副标题<br><code>UIApplicationShortcutItemUserInfo</code> 字典信息，用于传值</p>\n</li>\n<li><p>动态标签<br>静态标签添加比较方便，但是太不灵活，还好苹果给我们提供了接口来配置快捷选项，下面是添加快捷选项的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</div><div class=\"line\">     // Override point for customization after application launch.</div><div class=\"line\">     </div><div class=\"line\">     self.createShortcutItems()</div><div class=\"line\">     </div><div class=\"line\">     return true</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">// 创建应用图标上的3D Touch快捷选项</div><div class=\"line\"> func createShortcutItems() &#123;</div><div class=\"line\">     if #available(iOS 9.0, *) &#123;</div><div class=\"line\">         let icon: UIApplicationShortcutIcon = UIApplicationShortcutIcon.init(type: .share)</div><div class=\"line\">         </div><div class=\"line\">         let item: UIApplicationShortcutItem = UIApplicationShortcutItem.init(type: &quot;com.ileafly.3DTouchDemo.share&quot;, localizedTitle: &quot;分享&quot;, localizedSubtitle: nil, icon: icon, userInfo: nil)</div><div class=\"line\">         </div><div class=\"line\">         UIApplication.shared.shortcutItems = [item]</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Fallback on earlier versions</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>点击快捷选项标签进入应用的响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@available(iOS 9.0, *) // 只有9系统才能调用此方法</div><div class=\"line\">  func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123;</div><div class=\"line\">      print(shortcutItem);</div><div class=\"line\">      </div><div class=\"line\">      if let userInfo = shortcutItem.userInfo &#123;</div><div class=\"line\">          print(userInfo);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p>  <a href=\"http://liuyanwei.jumppo.com/2016/03/21/iOS-3DTouch-1.html\">iOS 3D touch 开发(一) Home Screen Quick Actions</a></p>\n"},{"title":"CocoaPods升级后问题解决","date":"2016-10-09T09:30:00.000Z","_content":"\n升级[CocoaPods](https://cocoapods.org/)到`1.0.1`版本遇到了两个问题，其中第一个比较简单，由于新版本强制要求设置target否则会出现错误，所以我们只需要在`Podfile`里按照新规范给每个Target都设置上就行了。而第二个问题让我寻找了很久，先来描述一下第二个问题。\n\n升级完CocoaPods后，在iPhone 6模拟器中编译没有任何问题，但是在iPhone 4或者iPhone 5等模拟器中一直编译失败，通过调研找到了原因，因为iPhone 4或者iPhone 5模拟器是64位模拟器，也就是说在64位模拟器上编译不会通过，这是因为新版本的CocoaPods\n","source":"_posts/CocoaPods升级后问题解决.md","raw":"title: CocoaPods升级后问题解决\ntags:\n  - iOS技巧\n  - ''\ncategories:\n  - iOS\ndate: 2016-10-09 17:30:00\n---\n\n升级[CocoaPods](https://cocoapods.org/)到`1.0.1`版本遇到了两个问题，其中第一个比较简单，由于新版本强制要求设置target否则会出现错误，所以我们只需要在`Podfile`里按照新规范给每个Target都设置上就行了。而第二个问题让我寻找了很久，先来描述一下第二个问题。\n\n升级完CocoaPods后，在iPhone 6模拟器中编译没有任何问题，但是在iPhone 4或者iPhone 5等模拟器中一直编译失败，通过调研找到了原因，因为iPhone 4或者iPhone 5模拟器是64位模拟器，也就是说在64位模拟器上编译不会通过，这是因为新版本的CocoaPods\n","slug":"CocoaPods升级后问题解决","published":1,"updated":"2018-08-31T09:50:59.569Z","_id":"cjlhoqwhb0002kj79cjshi6t6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>升级<a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">CocoaPods</a>到<code>1.0.1</code>版本遇到了两个问题，其中第一个比较简单，由于新版本强制要求设置target否则会出现错误，所以我们只需要在<code>Podfile</code>里按照新规范给每个Target都设置上就行了。而第二个问题让我寻找了很久，先来描述一下第二个问题。</p>\n<p>升级完CocoaPods后，在iPhone 6模拟器中编译没有任何问题，但是在iPhone 4或者iPhone 5等模拟器中一直编译失败，通过调研找到了原因，因为iPhone 4或者iPhone 5模拟器是64位模拟器，也就是说在64位模拟器上编译不会通过，这是因为新版本的CocoaPods</p>\n","excerpt":"","more":"<p>升级<a href=\"https://cocoapods.org/\">CocoaPods</a>到<code>1.0.1</code>版本遇到了两个问题，其中第一个比较简单，由于新版本强制要求设置target否则会出现错误，所以我们只需要在<code>Podfile</code>里按照新规范给每个Target都设置上就行了。而第二个问题让我寻找了很久，先来描述一下第二个问题。</p>\n<p>升级完CocoaPods后，在iPhone 6模拟器中编译没有任何问题，但是在iPhone 4或者iPhone 5等模拟器中一直编译失败，通过调研找到了原因，因为iPhone 4或者iPhone 5模拟器是64位模拟器，也就是说在64位模拟器上编译不会通过，这是因为新版本的CocoaPods</p>\n"},{"title":"Block用法小结","date":"2017-06-06T08:20:00.000Z","_content":"\n这篇博客将系统整理一下Block相关的知识\n\n首先，先思考一个问题Block能做些什么？\n\n- Block内部能够读取外部局部变量的值\n- 经过`__block`修饰符修饰的变量，Block内部不仅能够读取它的值，而且可以改变这个变量的值\n- Block可以用来作为控制器之间的一个通信\n- Block可以作为方法的参数\n\n## 进一步深挖block的原理\n#### 为什么不加__block修饰符就不能改变Block外部的局部变量?\n\n对于block外的变量引用，block默认是将其复制到其数据结构中实现访问的，对于用__block修饰的外部变量引用，block是复制其引用地址来实现访问的，所以加上__block就能改变block外部的变量\n\n#### Block如何作为控制器之间的一个通信？\n\n举例说明：\n1. 页面B的.h文件中声明一个block变量\n```\n// 方法一\n\ntypedef void(^blo)(NSString *str);\n@property (nonatomic, copy) blo block;\n\n// 方法二\n\n@property (nonatomic, copy) void (^blo)(NSString *str);\n\n```\n2. 页面A中创建B页面，并调用Block变量\n```\n// 方法一\n\nB *b = [[B alloc] init];\n\n__weak A *weakself = self;\nb.block = ^(NSString *str) {\n    weakself.str = str;\n}\n\n// 方法二\n\nB *b = [[B alloc] init];\n\n__weak A *weakself = self;\nb.blo = ^(NSString *str) {\n    weakself.str = str;\n}\n\n```\n\n3. 在页面B中调用Block变量\n\n```\nself.block(\"string\");\n```\n\n#### 为何A页面要用__weak修饰？\n使用__weak修饰符是为了避免引起循环引用。如果在Block中使用了__strong修饰符修饰的对象，那么当Block从栈复制到堆时，改对象为Block所有，这就容易引起循环引用，从而发生内存泄漏\n\n#### 如何使用Block作为方法的参数\n\n```\n- (void)blockAsParameter:(void (^)())block {\n    block(); // 执行block内部的代码\n}\n\n[self blockAsParameter:^{\n    NSLog(@\"\");\n}];\n```\n\n#### block的三种类型\n1. 不管在ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block `_NSConcreteGlobalBlock`，存储在内存中的代码区\n2. 在MRC下，block内部如果访问外部变量，这个block就是栈block `_NSConcreteStackBlock`，存储在内存中的栈上，当函数返回时会被销毁\n3. 在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block `_NSConcreteMallocBlock`，存储在内存的堆上，当引用计数为 0 时会被销毁\n4. 在ARC下，block内部如果访问了外部变量，这个block就是堆block，因为在ARC下，默认对block做一次copy操作\n\n### 总结一些block使用的注意点\n\n1.默认情况下，block内部可以访问外部变量，但是不能修改外部变量，如果想要修改外部变量，可以给外部变量加上`__block`关键字，block是复制其引用地址来实现访问的\n2. block作为属性应该用copy修饰，如果我们使用weak、assign来修饰block属性，block访问外部变量时类型就是栈block，而保存在栈中的block在其所在的函数、方法返回时，该block就会被销毁，在其他方法内部调用改block时，就会引发野指针错误。\n\n### 参考文献\n\n[黑幕背后的 __block 修饰符](http://chun.tips/2014/11/13/objc-block/)--分析了为什么不加__block修饰符就不能改变Block外部的局部变量\n\n[谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n","source":"_posts/Block用法小结.md","raw":"title: Block用法小结\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2017-06-06 16:20:00\n---\n\n这篇博客将系统整理一下Block相关的知识\n\n首先，先思考一个问题Block能做些什么？\n\n- Block内部能够读取外部局部变量的值\n- 经过`__block`修饰符修饰的变量，Block内部不仅能够读取它的值，而且可以改变这个变量的值\n- Block可以用来作为控制器之间的一个通信\n- Block可以作为方法的参数\n\n## 进一步深挖block的原理\n#### 为什么不加__block修饰符就不能改变Block外部的局部变量?\n\n对于block外的变量引用，block默认是将其复制到其数据结构中实现访问的，对于用__block修饰的外部变量引用，block是复制其引用地址来实现访问的，所以加上__block就能改变block外部的变量\n\n#### Block如何作为控制器之间的一个通信？\n\n举例说明：\n1. 页面B的.h文件中声明一个block变量\n```\n// 方法一\n\ntypedef void(^blo)(NSString *str);\n@property (nonatomic, copy) blo block;\n\n// 方法二\n\n@property (nonatomic, copy) void (^blo)(NSString *str);\n\n```\n2. 页面A中创建B页面，并调用Block变量\n```\n// 方法一\n\nB *b = [[B alloc] init];\n\n__weak A *weakself = self;\nb.block = ^(NSString *str) {\n    weakself.str = str;\n}\n\n// 方法二\n\nB *b = [[B alloc] init];\n\n__weak A *weakself = self;\nb.blo = ^(NSString *str) {\n    weakself.str = str;\n}\n\n```\n\n3. 在页面B中调用Block变量\n\n```\nself.block(\"string\");\n```\n\n#### 为何A页面要用__weak修饰？\n使用__weak修饰符是为了避免引起循环引用。如果在Block中使用了__strong修饰符修饰的对象，那么当Block从栈复制到堆时，改对象为Block所有，这就容易引起循环引用，从而发生内存泄漏\n\n#### 如何使用Block作为方法的参数\n\n```\n- (void)blockAsParameter:(void (^)())block {\n    block(); // 执行block内部的代码\n}\n\n[self blockAsParameter:^{\n    NSLog(@\"\");\n}];\n```\n\n#### block的三种类型\n1. 不管在ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block `_NSConcreteGlobalBlock`，存储在内存中的代码区\n2. 在MRC下，block内部如果访问外部变量，这个block就是栈block `_NSConcreteStackBlock`，存储在内存中的栈上，当函数返回时会被销毁\n3. 在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block `_NSConcreteMallocBlock`，存储在内存的堆上，当引用计数为 0 时会被销毁\n4. 在ARC下，block内部如果访问了外部变量，这个block就是堆block，因为在ARC下，默认对block做一次copy操作\n\n### 总结一些block使用的注意点\n\n1.默认情况下，block内部可以访问外部变量，但是不能修改外部变量，如果想要修改外部变量，可以给外部变量加上`__block`关键字，block是复制其引用地址来实现访问的\n2. block作为属性应该用copy修饰，如果我们使用weak、assign来修饰block属性，block访问外部变量时类型就是栈block，而保存在栈中的block在其所在的函数、方法返回时，该block就会被销毁，在其他方法内部调用改block时，就会引发野指针错误。\n\n### 参考文献\n\n[黑幕背后的 __block 修饰符](http://chun.tips/2014/11/13/objc-block/)--分析了为什么不加__block修饰符就不能改变Block外部的局部变量\n\n[谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n","slug":"Block用法小结","published":1,"updated":"2018-08-31T09:44:54.769Z","_id":"cjlhoqwhg0006kj79942cg72h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇博客将系统整理一下Block相关的知识</p>\n<p>首先，先思考一个问题Block能做些什么？</p>\n<ul>\n<li>Block内部能够读取外部局部变量的值</li>\n<li>经过<code>__block</code>修饰符修饰的变量，Block内部不仅能够读取它的值，而且可以改变这个变量的值</li>\n<li>Block可以用来作为控制器之间的一个通信</li>\n<li>Block可以作为方法的参数</li>\n</ul>\n<h2 id=\"进一步深挖block的原理\"><a href=\"#进一步深挖block的原理\" class=\"headerlink\" title=\"进一步深挖block的原理\"></a>进一步深挖block的原理</h2><h4 id=\"为什么不加-block修饰符就不能改变Block外部的局部变量\"><a href=\"#为什么不加-block修饰符就不能改变Block外部的局部变量\" class=\"headerlink\" title=\"为什么不加__block修饰符就不能改变Block外部的局部变量?\"></a>为什么不加__block修饰符就不能改变Block外部的局部变量?</h4><p>对于block外的变量引用，block默认是将其复制到其数据结构中实现访问的，对于用<strong>block修饰的外部变量引用，block是复制其引用地址来实现访问的，所以加上</strong>block就能改变block外部的变量</p>\n<h4 id=\"Block如何作为控制器之间的一个通信？\"><a href=\"#Block如何作为控制器之间的一个通信？\" class=\"headerlink\" title=\"Block如何作为控制器之间的一个通信？\"></a>Block如何作为控制器之间的一个通信？</h4><p>举例说明：</p>\n<ol>\n<li><p>页面B的.h文件中声明一个block变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 方法一</div><div class=\"line\"></div><div class=\"line\">typedef void(^blo)(NSString *str);</div><div class=\"line\">@property (nonatomic, copy) blo block;</div><div class=\"line\"></div><div class=\"line\">// 方法二</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) void (^blo)(NSString *str);</div></pre></td></tr></table></figure>\n</li>\n<li><p>页面A中创建B页面，并调用Block变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 方法一</div><div class=\"line\"></div><div class=\"line\">B *b = [[B alloc] init];</div><div class=\"line\"></div><div class=\"line\">__weak A *weakself = self;</div><div class=\"line\">b.block = ^(NSString *str) &#123;</div><div class=\"line\">    weakself.str = str;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 方法二</div><div class=\"line\"></div><div class=\"line\">B *b = [[B alloc] init];</div><div class=\"line\"></div><div class=\"line\">__weak A *weakself = self;</div><div class=\"line\">b.blo = ^(NSString *str) &#123;</div><div class=\"line\">    weakself.str = str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在页面B中调用Block变量</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.block(&quot;string&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"为何A页面要用-weak修饰？\"><a href=\"#为何A页面要用-weak修饰？\" class=\"headerlink\" title=\"为何A页面要用__weak修饰？\"></a>为何A页面要用__weak修饰？</h4><p>使用<strong>weak修饰符是为了避免引起循环引用。如果在Block中使用了</strong>strong修饰符修饰的对象，那么当Block从栈复制到堆时，改对象为Block所有，这就容易引起循环引用，从而发生内存泄漏</p>\n<h4 id=\"如何使用Block作为方法的参数\"><a href=\"#如何使用Block作为方法的参数\" class=\"headerlink\" title=\"如何使用Block作为方法的参数\"></a>如何使用Block作为方法的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)blockAsParameter:(void (^)())block &#123;</div><div class=\"line\">    block(); // 执行block内部的代码</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[self blockAsParameter:^&#123;</div><div class=\"line\">    NSLog(@&quot;&quot;);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h4 id=\"block的三种类型\"><a href=\"#block的三种类型\" class=\"headerlink\" title=\"block的三种类型\"></a>block的三种类型</h4><ol>\n<li>不管在ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block <code>_NSConcreteGlobalBlock</code>，存储在内存中的代码区</li>\n<li>在MRC下，block内部如果访问外部变量，这个block就是栈block <code>_NSConcreteStackBlock</code>，存储在内存中的栈上，当函数返回时会被销毁</li>\n<li>在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block <code>_NSConcreteMallocBlock</code>，存储在内存的堆上，当引用计数为 0 时会被销毁</li>\n<li>在ARC下，block内部如果访问了外部变量，这个block就是堆block，因为在ARC下，默认对block做一次copy操作</li>\n</ol>\n<h3 id=\"总结一些block使用的注意点\"><a href=\"#总结一些block使用的注意点\" class=\"headerlink\" title=\"总结一些block使用的注意点\"></a>总结一些block使用的注意点</h3><p>1.默认情况下，block内部可以访问外部变量，但是不能修改外部变量，如果想要修改外部变量，可以给外部变量加上<code>__block</code>关键字，block是复制其引用地址来实现访问的</p>\n<ol>\n<li>block作为属性应该用copy修饰，如果我们使用weak、assign来修饰block属性，block访问外部变量时类型就是栈block，而保存在栈中的block在其所在的函数、方法返回时，该block就会被销毁，在其他方法内部调用改block时，就会引发野指针错误。</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"http://chun.tips/2014/11/13/objc-block/\" target=\"_blank\" rel=\"external\">黑幕背后的 __block 修饰符</a>–分析了为什么不加__block修饰符就不能改变Block外部的局部变量</p>\n<p><a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/\" target=\"_blank\" rel=\"external\">谈Objective-C block的实现</a></p>\n","excerpt":"","more":"<p>这篇博客将系统整理一下Block相关的知识</p>\n<p>首先，先思考一个问题Block能做些什么？</p>\n<ul>\n<li>Block内部能够读取外部局部变量的值</li>\n<li>经过<code>__block</code>修饰符修饰的变量，Block内部不仅能够读取它的值，而且可以改变这个变量的值</li>\n<li>Block可以用来作为控制器之间的一个通信</li>\n<li>Block可以作为方法的参数</li>\n</ul>\n<h2 id=\"进一步深挖block的原理\"><a href=\"#进一步深挖block的原理\" class=\"headerlink\" title=\"进一步深挖block的原理\"></a>进一步深挖block的原理</h2><h4 id=\"为什么不加-block修饰符就不能改变Block外部的局部变量\"><a href=\"#为什么不加-block修饰符就不能改变Block外部的局部变量\" class=\"headerlink\" title=\"为什么不加__block修饰符就不能改变Block外部的局部变量?\"></a>为什么不加__block修饰符就不能改变Block外部的局部变量?</h4><p>对于block外的变量引用，block默认是将其复制到其数据结构中实现访问的，对于用<strong>block修饰的外部变量引用，block是复制其引用地址来实现访问的，所以加上</strong>block就能改变block外部的变量</p>\n<h4 id=\"Block如何作为控制器之间的一个通信？\"><a href=\"#Block如何作为控制器之间的一个通信？\" class=\"headerlink\" title=\"Block如何作为控制器之间的一个通信？\"></a>Block如何作为控制器之间的一个通信？</h4><p>举例说明：</p>\n<ol>\n<li><p>页面B的.h文件中声明一个block变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 方法一</div><div class=\"line\"></div><div class=\"line\">typedef void(^blo)(NSString *str);</div><div class=\"line\">@property (nonatomic, copy) blo block;</div><div class=\"line\"></div><div class=\"line\">// 方法二</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) void (^blo)(NSString *str);</div></pre></td></tr></table></figure>\n</li>\n<li><p>页面A中创建B页面，并调用Block变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 方法一</div><div class=\"line\"></div><div class=\"line\">B *b = [[B alloc] init];</div><div class=\"line\"></div><div class=\"line\">__weak A *weakself = self;</div><div class=\"line\">b.block = ^(NSString *str) &#123;</div><div class=\"line\">    weakself.str = str;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 方法二</div><div class=\"line\"></div><div class=\"line\">B *b = [[B alloc] init];</div><div class=\"line\"></div><div class=\"line\">__weak A *weakself = self;</div><div class=\"line\">b.blo = ^(NSString *str) &#123;</div><div class=\"line\">    weakself.str = str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在页面B中调用Block变量</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.block(&quot;string&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"为何A页面要用-weak修饰？\"><a href=\"#为何A页面要用-weak修饰？\" class=\"headerlink\" title=\"为何A页面要用__weak修饰？\"></a>为何A页面要用__weak修饰？</h4><p>使用<strong>weak修饰符是为了避免引起循环引用。如果在Block中使用了</strong>strong修饰符修饰的对象，那么当Block从栈复制到堆时，改对象为Block所有，这就容易引起循环引用，从而发生内存泄漏</p>\n<h4 id=\"如何使用Block作为方法的参数\"><a href=\"#如何使用Block作为方法的参数\" class=\"headerlink\" title=\"如何使用Block作为方法的参数\"></a>如何使用Block作为方法的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)blockAsParameter:(void (^)())block &#123;</div><div class=\"line\">    block(); // 执行block内部的代码</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[self blockAsParameter:^&#123;</div><div class=\"line\">    NSLog(@&quot;&quot;);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h4 id=\"block的三种类型\"><a href=\"#block的三种类型\" class=\"headerlink\" title=\"block的三种类型\"></a>block的三种类型</h4><ol>\n<li>不管在ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block <code>_NSConcreteGlobalBlock</code>，存储在内存中的代码区</li>\n<li>在MRC下，block内部如果访问外部变量，这个block就是栈block <code>_NSConcreteStackBlock</code>，存储在内存中的栈上，当函数返回时会被销毁</li>\n<li>在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block <code>_NSConcreteMallocBlock</code>，存储在内存的堆上，当引用计数为 0 时会被销毁</li>\n<li>在ARC下，block内部如果访问了外部变量，这个block就是堆block，因为在ARC下，默认对block做一次copy操作</li>\n</ol>\n<h3 id=\"总结一些block使用的注意点\"><a href=\"#总结一些block使用的注意点\" class=\"headerlink\" title=\"总结一些block使用的注意点\"></a>总结一些block使用的注意点</h3><p>1.默认情况下，block内部可以访问外部变量，但是不能修改外部变量，如果想要修改外部变量，可以给外部变量加上<code>__block</code>关键字，block是复制其引用地址来实现访问的</p>\n<ol>\n<li>block作为属性应该用copy修饰，如果我们使用weak、assign来修饰block属性，block访问外部变量时类型就是栈block，而保存在栈中的block在其所在的函数、方法返回时，该block就会被销毁，在其他方法内部调用改block时，就会引发野指针错误。</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"http://chun.tips/2014/11/13/objc-block/\">黑幕背后的 __block 修饰符</a>–分析了为什么不加__block修饰符就不能改变Block外部的局部变量</p>\n<p><a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/\">谈Objective-C block的实现</a></p>\n"},{"title":"Bootstrap框架入门","date":"2017-04-07T08:47:00.000Z","_content":"### 前言\n近期利用业余时间在学习一些前端的基础知识，今天整理一下这段时间在使用bootstrap进行开发获得的一些收获，博客内容比较基础，仅为了个人总结，有错误之处还请大神指出~\n\n### Bootstrap\n[Bootstrap](http://getbootstrap.com)是Twitter推出的一个用于前端开发的开源工具包，目前比较常用的版本是Bootstrap3.3.7，国内有一个比较好的关于Bootstrap的中文网站，我们通过[这个网站](http://www.bootcss.com)可以很方便的进行Bootstrap学习\n\n#### Bootstrap的使用\n我们可以使用[Bootstrap 中文网](http://www.bootcss.com)专门为Bootstrap构建的免费的CDN加速服务\n```\n<!-- 最新版本的 Bootstrap 核心 CSS 文件 -->\n<link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n\n<!-- 可选的 Bootstrap 主题文件（一般不用引入） -->\n<link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\">\n\n<!-- 最新的 Bootstrap 核心 JavaScript 文件 -->\n<script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"></script>\n```\n#### Bootstrap的模板\n在浏览[Bootstrap 中文网](http://www.bootcss.com)时，我们能看到有一个实例精选模块，里面为我们提供了很多种不同应用场景下的模板，对于新手而言，学习这些模板的具体实现原理是一个非常不错的方法\n\n#### Bootstrap的组件\nBootstrap为我们提供了各种各样的组件，我们可以浏览这些[组件](http://v3.bootcss.com/components/)并尝试将他们运用到自己的项目中\n\n#### Bootstrap的扩展\n除了上述的基础功能外，还有很多基于Bootstrap开发的开源扩展，利用这些扩展可以很方便的帮助我们实现一些功能，最近我就使用了[bootstrap-table](http://bootstrap-table.wenzhixin.net.cn/zh-cn/getting-started/)扩展来帮助我实现一个报表功能\n\n\n","source":"_posts/Bootstrap框架入门.md","raw":"title: Bootstrap框架入门\ntags:\n  - Bootstrap\ncategories:\n  - 前端\ndate: 2017-04-07 16:47:00\n---\n### 前言\n近期利用业余时间在学习一些前端的基础知识，今天整理一下这段时间在使用bootstrap进行开发获得的一些收获，博客内容比较基础，仅为了个人总结，有错误之处还请大神指出~\n\n### Bootstrap\n[Bootstrap](http://getbootstrap.com)是Twitter推出的一个用于前端开发的开源工具包，目前比较常用的版本是Bootstrap3.3.7，国内有一个比较好的关于Bootstrap的中文网站，我们通过[这个网站](http://www.bootcss.com)可以很方便的进行Bootstrap学习\n\n#### Bootstrap的使用\n我们可以使用[Bootstrap 中文网](http://www.bootcss.com)专门为Bootstrap构建的免费的CDN加速服务\n```\n<!-- 最新版本的 Bootstrap 核心 CSS 文件 -->\n<link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n\n<!-- 可选的 Bootstrap 主题文件（一般不用引入） -->\n<link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\">\n\n<!-- 最新的 Bootstrap 核心 JavaScript 文件 -->\n<script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"></script>\n```\n#### Bootstrap的模板\n在浏览[Bootstrap 中文网](http://www.bootcss.com)时，我们能看到有一个实例精选模块，里面为我们提供了很多种不同应用场景下的模板，对于新手而言，学习这些模板的具体实现原理是一个非常不错的方法\n\n#### Bootstrap的组件\nBootstrap为我们提供了各种各样的组件，我们可以浏览这些[组件](http://v3.bootcss.com/components/)并尝试将他们运用到自己的项目中\n\n#### Bootstrap的扩展\n除了上述的基础功能外，还有很多基于Bootstrap开发的开源扩展，利用这些扩展可以很方便的帮助我们实现一些功能，最近我就使用了[bootstrap-table](http://bootstrap-table.wenzhixin.net.cn/zh-cn/getting-started/)扩展来帮助我实现一个报表功能\n\n\n","slug":"Bootstrap框架入门","published":1,"updated":"2018-08-31T09:45:46.251Z","_id":"cjlhoqwhj0008kj795hy6ixb5","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>近期利用业余时间在学习一些前端的基础知识，今天整理一下这段时间在使用bootstrap进行开发获得的一些收获，博客内容比较基础，仅为了个人总结，有错误之处还请大神指出~</p>\n<h3 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h3><p><a href=\"http://getbootstrap.com\" target=\"_blank\" rel=\"external\">Bootstrap</a>是Twitter推出的一个用于前端开发的开源工具包，目前比较常用的版本是Bootstrap3.3.7，国内有一个比较好的关于Bootstrap的中文网站，我们通过<a href=\"http://www.bootcss.com\" target=\"_blank\" rel=\"external\">这个网站</a>可以很方便的进行Bootstrap学习</p>\n<h4 id=\"Bootstrap的使用\"><a href=\"#Bootstrap的使用\" class=\"headerlink\" title=\"Bootstrap的使用\"></a>Bootstrap的使用</h4><p>我们可以使用<a href=\"http://www.bootcss.com\" target=\"_blank\" rel=\"external\">Bootstrap 中文网</a>专门为Bootstrap构建的免费的CDN加速服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</div><div class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Bootstrap的模板\"><a href=\"#Bootstrap的模板\" class=\"headerlink\" title=\"Bootstrap的模板\"></a>Bootstrap的模板</h4><p>在浏览<a href=\"http://www.bootcss.com\" target=\"_blank\" rel=\"external\">Bootstrap 中文网</a>时，我们能看到有一个实例精选模块，里面为我们提供了很多种不同应用场景下的模板，对于新手而言，学习这些模板的具体实现原理是一个非常不错的方法</p>\n<h4 id=\"Bootstrap的组件\"><a href=\"#Bootstrap的组件\" class=\"headerlink\" title=\"Bootstrap的组件\"></a>Bootstrap的组件</h4><p>Bootstrap为我们提供了各种各样的组件，我们可以浏览这些<a href=\"http://v3.bootcss.com/components/\" target=\"_blank\" rel=\"external\">组件</a>并尝试将他们运用到自己的项目中</p>\n<h4 id=\"Bootstrap的扩展\"><a href=\"#Bootstrap的扩展\" class=\"headerlink\" title=\"Bootstrap的扩展\"></a>Bootstrap的扩展</h4><p>除了上述的基础功能外，还有很多基于Bootstrap开发的开源扩展，利用这些扩展可以很方便的帮助我们实现一些功能，最近我就使用了<a href=\"http://bootstrap-table.wenzhixin.net.cn/zh-cn/getting-started/\" target=\"_blank\" rel=\"external\">bootstrap-table</a>扩展来帮助我实现一个报表功能</p>\n","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>近期利用业余时间在学习一些前端的基础知识，今天整理一下这段时间在使用bootstrap进行开发获得的一些收获，博客内容比较基础，仅为了个人总结，有错误之处还请大神指出~</p>\n<h3 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h3><p><a href=\"http://getbootstrap.com\">Bootstrap</a>是Twitter推出的一个用于前端开发的开源工具包，目前比较常用的版本是Bootstrap3.3.7，国内有一个比较好的关于Bootstrap的中文网站，我们通过<a href=\"http://www.bootcss.com\">这个网站</a>可以很方便的进行Bootstrap学习</p>\n<h4 id=\"Bootstrap的使用\"><a href=\"#Bootstrap的使用\" class=\"headerlink\" title=\"Bootstrap的使用\"></a>Bootstrap的使用</h4><p>我们可以使用<a href=\"http://www.bootcss.com\">Bootstrap 中文网</a>专门为Bootstrap构建的免费的CDN加速服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</div><div class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Bootstrap的模板\"><a href=\"#Bootstrap的模板\" class=\"headerlink\" title=\"Bootstrap的模板\"></a>Bootstrap的模板</h4><p>在浏览<a href=\"http://www.bootcss.com\">Bootstrap 中文网</a>时，我们能看到有一个实例精选模块，里面为我们提供了很多种不同应用场景下的模板，对于新手而言，学习这些模板的具体实现原理是一个非常不错的方法</p>\n<h4 id=\"Bootstrap的组件\"><a href=\"#Bootstrap的组件\" class=\"headerlink\" title=\"Bootstrap的组件\"></a>Bootstrap的组件</h4><p>Bootstrap为我们提供了各种各样的组件，我们可以浏览这些<a href=\"http://v3.bootcss.com/components/\">组件</a>并尝试将他们运用到自己的项目中</p>\n<h4 id=\"Bootstrap的扩展\"><a href=\"#Bootstrap的扩展\" class=\"headerlink\" title=\"Bootstrap的扩展\"></a>Bootstrap的扩展</h4><p>除了上述的基础功能外，还有很多基于Bootstrap开发的开源扩展，利用这些扩展可以很方便的帮助我们实现一些功能，最近我就使用了<a href=\"http://bootstrap-table.wenzhixin.net.cn/zh-cn/getting-started/\">bootstrap-table</a>扩展来帮助我实现一个报表功能</p>\n"},{"title":"Hexo多台电脑同步","date":"2016-10-24T07:00:00.000Z","_content":"\n使用Hexo搭建个人博客已经有一段时间了，在使用中发现一个问题，github上存放的并非是原始的博客文件而是经过hexo处理的html文件，这就导致无法在两台电脑上协同工作，多么悲伤的事情！\n难道我需要单独创建一个git项目来存放? 通过调研找到了一个方便快捷的管理源码的方法。\n\n### Hexo多台电脑同步方案\n\n1. 创建两个分支：master和hexo\n2. 设置hexo为默认分支，[github](https://www.github.com)的setting里可以设置\n3. git clone 拷贝仓库\n4. 进入仓库初始化hexo\n5. 配置hexo `_config.yml` 可参考[个人博客进阶--Hexo搭建博客](http://www.ileafly.com/2016/08/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/)\n6. 依次执行 `git add .` `git commit -m \"message\"` `git push origin hexo` 提交相关文件\n\n这样，在你的博客项目里就存在两个分支，master分支用来存放生成的今天网页，hexo分支用来存放网站的原始文件\n\n### 新电脑如何同步Hexo\n\n1. git clone 拷贝仓库\n2. 已安装hexo则直接使用，未安装Hexo只需要安装Hexo即可\n\n### 待尝试的同步方法\n有大神写了一个同步的脚本，只需要执行`hexo b`就可以达到同步的目的，还没有尝试，[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n\n### 参考地址\n[hexo多台电脑同步](https://www.zhihu.com/question/21193762)\n","source":"_posts/Hexo多台电脑同步.md","raw":"title: Hexo多台电脑同步\ntags:\n  - 博客\n  - ''\ncategories:\n  - 工具\n  - ''\ndate: 2016-10-24 15:00:00\n---\n\n使用Hexo搭建个人博客已经有一段时间了，在使用中发现一个问题，github上存放的并非是原始的博客文件而是经过hexo处理的html文件，这就导致无法在两台电脑上协同工作，多么悲伤的事情！\n难道我需要单独创建一个git项目来存放? 通过调研找到了一个方便快捷的管理源码的方法。\n\n### Hexo多台电脑同步方案\n\n1. 创建两个分支：master和hexo\n2. 设置hexo为默认分支，[github](https://www.github.com)的setting里可以设置\n3. git clone 拷贝仓库\n4. 进入仓库初始化hexo\n5. 配置hexo `_config.yml` 可参考[个人博客进阶--Hexo搭建博客](http://www.ileafly.com/2016/08/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/)\n6. 依次执行 `git add .` `git commit -m \"message\"` `git push origin hexo` 提交相关文件\n\n这样，在你的博客项目里就存在两个分支，master分支用来存放生成的今天网页，hexo分支用来存放网站的原始文件\n\n### 新电脑如何同步Hexo\n\n1. git clone 拷贝仓库\n2. 已安装hexo则直接使用，未安装Hexo只需要安装Hexo即可\n\n### 待尝试的同步方法\n有大神写了一个同步的脚本，只需要执行`hexo b`就可以达到同步的目的，还没有尝试，[hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n\n### 参考地址\n[hexo多台电脑同步](https://www.zhihu.com/question/21193762)\n","slug":"Hexo多台电脑同步","published":1,"updated":"2018-08-31T09:51:49.879Z","_id":"cjlhoqwhk0009kj79tww0y47x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用Hexo搭建个人博客已经有一段时间了，在使用中发现一个问题，github上存放的并非是原始的博客文件而是经过hexo处理的html文件，这就导致无法在两台电脑上协同工作，多么悲伤的事情！<br>难道我需要单独创建一个git项目来存放? 通过调研找到了一个方便快捷的管理源码的方法。</p>\n<h3 id=\"Hexo多台电脑同步方案\"><a href=\"#Hexo多台电脑同步方案\" class=\"headerlink\" title=\"Hexo多台电脑同步方案\"></a>Hexo多台电脑同步方案</h3><ol>\n<li>创建两个分支：master和hexo</li>\n<li>设置hexo为默认分支，<a href=\"https://www.github.com\" target=\"_blank\" rel=\"external\">github</a>的setting里可以设置</li>\n<li>git clone 拷贝仓库</li>\n<li>进入仓库初始化hexo</li>\n<li>配置hexo <code>_config.yml</code> 可参考<a href=\"http://www.ileafly.com/2016/08/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">个人博客进阶–Hexo搭建博客</a></li>\n<li>依次执行 <code>git add .</code> <code>git commit -m &quot;message&quot;</code> <code>git push origin hexo</code> 提交相关文件</li>\n</ol>\n<p>这样，在你的博客项目里就存在两个分支，master分支用来存放生成的今天网页，hexo分支用来存放网站的原始文件</p>\n<h3 id=\"新电脑如何同步Hexo\"><a href=\"#新电脑如何同步Hexo\" class=\"headerlink\" title=\"新电脑如何同步Hexo\"></a>新电脑如何同步Hexo</h3><ol>\n<li>git clone 拷贝仓库</li>\n<li>已安装hexo则直接使用，未安装Hexo只需要安装Hexo即可</li>\n</ol>\n<h3 id=\"待尝试的同步方法\"><a href=\"#待尝试的同步方法\" class=\"headerlink\" title=\"待尝试的同步方法\"></a>待尝试的同步方法</h3><p>有大神写了一个同步的脚本，只需要执行<code>hexo b</code>就可以达到同步的目的，还没有尝试，<a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"external\">hexo-git-backup</a></p>\n<h3 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h3><p><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"external\">hexo多台电脑同步</a></p>\n","excerpt":"","more":"<p>使用Hexo搭建个人博客已经有一段时间了，在使用中发现一个问题，github上存放的并非是原始的博客文件而是经过hexo处理的html文件，这就导致无法在两台电脑上协同工作，多么悲伤的事情！<br>难道我需要单独创建一个git项目来存放? 通过调研找到了一个方便快捷的管理源码的方法。</p>\n<h3 id=\"Hexo多台电脑同步方案\"><a href=\"#Hexo多台电脑同步方案\" class=\"headerlink\" title=\"Hexo多台电脑同步方案\"></a>Hexo多台电脑同步方案</h3><ol>\n<li>创建两个分支：master和hexo</li>\n<li>设置hexo为默认分支，<a href=\"https://www.github.com\">github</a>的setting里可以设置</li>\n<li>git clone 拷贝仓库</li>\n<li>进入仓库初始化hexo</li>\n<li>配置hexo <code>_config.yml</code> 可参考<a href=\"http://www.ileafly.com/2016/08/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">个人博客进阶–Hexo搭建博客</a></li>\n<li>依次执行 <code>git add .</code> <code>git commit -m &quot;message&quot;</code> <code>git push origin hexo</code> 提交相关文件</li>\n</ol>\n<p>这样，在你的博客项目里就存在两个分支，master分支用来存放生成的今天网页，hexo分支用来存放网站的原始文件</p>\n<h3 id=\"新电脑如何同步Hexo\"><a href=\"#新电脑如何同步Hexo\" class=\"headerlink\" title=\"新电脑如何同步Hexo\"></a>新电脑如何同步Hexo</h3><ol>\n<li>git clone 拷贝仓库</li>\n<li>已安装hexo则直接使用，未安装Hexo只需要安装Hexo即可</li>\n</ol>\n<h3 id=\"待尝试的同步方法\"><a href=\"#待尝试的同步方法\" class=\"headerlink\" title=\"待尝试的同步方法\"></a>待尝试的同步方法</h3><p>有大神写了一个同步的脚本，只需要执行<code>hexo b</code>就可以达到同步的目的，还没有尝试，<a href=\"https://github.com/coneycode/hexo-git-backup\">hexo-git-backup</a></p>\n<h3 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h3><p><a href=\"https://www.zhihu.com/question/21193762\">hexo多台电脑同步</a></p>\n"},{"title":"Markdown语法初探","date":"2016-08-11T02:19:00.000Z","_content":"\n[Markdown](https://zh.wikipedia.org/wiki/Markdown)是一种轻量级标记语言，我打算利用Markdown语言来写博客，这就需要我能够熟悉Markdown的一些常用方法，这篇博客就是对常用Markdown用法的一些总结。\n\n## 标题\n\n可以在标题内容前输入特定数量的#来实现对应级别的HTML样式的标题。列如：\n\n    # 一级标题\n    \n    #### 四级标题\n    \n另外，一级和二级标题还有一种写法：\n\n    一级标题\n    =====================\n    二级标题\n    ---------------------\n    \n## 换行\n\n在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入**至少两个空格**。\n\n## 引用\n\n> 这是一段被引用的内容\n> 引用结束\n\n\n## 链接\n\n    [链接文案](链接地址)\n    例如： [Markdown](https://zh.wikipedia.org/wiki/Markdown)\n\n## 图片\n\n    ![Alt text](image url)\n\n![foo](https://zh.wikipedia.org/static/images/project-logos/zhwiki.png)\n\n\n## 强调\n\n    *斜体* 或 _斜体_  \n    \n    **加重强调** 或 __加重强调__\n    \n## 参考\n\n[markdown语法参考](http://wowubuntu.com/markdown/)\n\n[markdown维基百科](https://zh.wikipedia.org/wiki/Markdown)\n\n","source":"_posts/Markdown语法初探.md","raw":"title: Markdown语法初探\ntags:\n  - Markdown\ncategories:\n  - 工具\n  - ''\ndate: 2016-08-11 10:19:00\n---\n\n[Markdown](https://zh.wikipedia.org/wiki/Markdown)是一种轻量级标记语言，我打算利用Markdown语言来写博客，这就需要我能够熟悉Markdown的一些常用方法，这篇博客就是对常用Markdown用法的一些总结。\n\n## 标题\n\n可以在标题内容前输入特定数量的#来实现对应级别的HTML样式的标题。列如：\n\n    # 一级标题\n    \n    #### 四级标题\n    \n另外，一级和二级标题还有一种写法：\n\n    一级标题\n    =====================\n    二级标题\n    ---------------------\n    \n## 换行\n\n在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入**至少两个空格**。\n\n## 引用\n\n> 这是一段被引用的内容\n> 引用结束\n\n\n## 链接\n\n    [链接文案](链接地址)\n    例如： [Markdown](https://zh.wikipedia.org/wiki/Markdown)\n\n## 图片\n\n    ![Alt text](image url)\n\n![foo](https://zh.wikipedia.org/static/images/project-logos/zhwiki.png)\n\n\n## 强调\n\n    *斜体* 或 _斜体_  \n    \n    **加重强调** 或 __加重强调__\n    \n## 参考\n\n[markdown语法参考](http://wowubuntu.com/markdown/)\n\n[markdown维基百科](https://zh.wikipedia.org/wiki/Markdown)\n\n","slug":"Markdown语法初探","published":1,"updated":"2018-08-31T09:49:37.592Z","_id":"cjlhoqwhn000dkj793xue9kv0","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">Markdown</a>是一种轻量级标记语言，我打算利用Markdown语言来写博客，这就需要我能够熟悉Markdown的一些常用方法，这篇博客就是对常用Markdown用法的一些总结。</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>可以在标题内容前输入特定数量的#来实现对应级别的HTML样式的标题。列如：</p>\n<pre><code># 一级标题\n\n#### 四级标题\n</code></pre><p>另外，一级和二级标题还有一种写法：</p>\n<pre><code>一级标题\n=====================\n二级标题\n---------------------\n</code></pre><h2 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h2><p>在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入<strong>至少两个空格</strong>。</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>这是一段被引用的内容<br>引用结束</p>\n</blockquote>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><pre><code>[链接文案](链接地址)\n例如： [Markdown](https://zh.wikipedia.org/wiki/Markdown)\n</code></pre><h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><pre><code>![Alt text](image url)\n</code></pre><p><img src=\"https://zh.wikipedia.org/static/images/project-logos/zhwiki.png\" alt=\"foo\"></p>\n<h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><pre><code>*斜体* 或 _斜体_  \n\n**加重强调** 或 __加重强调__\n</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">markdown语法参考</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">markdown维基百科</a></p>\n","excerpt":"","more":"<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">Markdown</a>是一种轻量级标记语言，我打算利用Markdown语言来写博客，这就需要我能够熟悉Markdown的一些常用方法，这篇博客就是对常用Markdown用法的一些总结。</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>可以在标题内容前输入特定数量的#来实现对应级别的HTML样式的标题。列如：</p>\n<pre><code># 一级标题\n\n#### 四级标题\n</code></pre><p>另外，一级和二级标题还有一种写法：</p>\n<pre><code>一级标题\n=====================\n二级标题\n---------------------\n</code></pre><h2 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h2><p>在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入<strong>至少两个空格</strong>。</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>这是一段被引用的内容<br>引用结束</p>\n</blockquote>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><pre><code>[链接文案](链接地址)\n例如： [Markdown](https://zh.wikipedia.org/wiki/Markdown)\n</code></pre><h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><pre><code>![Alt text](image url)\n</code></pre><p><img src=\"https://zh.wikipedia.org/static/images/project-logos/zhwiki.png\" alt=\"foo\"></p>\n<h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><pre><code>*斜体* 或 _斜体_  \n\n**加重强调** 或 __加重强调__\n</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://wowubuntu.com/markdown/\">markdown语法参考</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Markdown\">markdown维基百科</a></p>\n"},{"title":"EPUB文件格式解析","date":"2017-07-20T09:45:00.000Z","_content":"\n### 背景知识\n\n`EPUB`是Electronic Publication的缩写，是一种电子图书标准，`EPUB`是一个自由的开发标准，属于一种可以自动重新编排的内容，也就是说`EPUB`格式的图书，它的文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。\n\n### 文件组成\n\n一个未经加密处理的epub电子书由以下三部分组成：\n\n1. META-INF（文件夹，里面有一个container.xml文件）\n2. OEBPS （文件夹，包含images文件夹、很多xhtml文件、css文件和content.opf文件）\n3. mimetype\n\n#### 文件mimetype\n每个epub电子书均包含一个mimetype的文件，且内容不变，用以说明epub的文件格式。\n```\napplication/epub+zip\n```\n\n#### 文件夹META-INF\nMETA-INF用于存放容器信息，默认情况下此目录只包含一个文件container.xml，文件内容如下：\n```\n<?xml version=\"1.0\"?>\n<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n    <rootfiles>\n        <rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\"/>\n    </rootfiles>\n</container>\n```\ncontainer.xml文件的主要功能用于告诉阅读器，电子书的根文件的路径和打开格式\n\n#### 文件夹OEBPS\n\nOEBPS目录用于存放OPF文档、CSS文档、NCX文档\n\n#### 文件OPF\nOPF文档是epub的核心文件，且是一个标准的xml文件，依据OPF规范，此文件的根元素为`<package>`\n```\n<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"2.0\" unique-identifier=\"uuid_id\">\n```\n其内容主要由五部分组成：\n\n1. <metadata>\n   元数据信息，这个标签里面是书籍的出版信息，由两个子元素组成\n   - <dc-title> 标题\n   - <dc-creator> 责任人\n   - <dc-subject> 主题词、关键词\n   - <dc-descributor> 内容描述\n   - <dc-date> 日期\n   - <dc-type> 类型\n   - <dc-publisher> 出版者\n   - <dc-contributor> 发行者\n   - <dc-format> 格式\n   - <dc-identifier> 标识信息\n   - <dc-source> 来源信息\n   - <dc-language> 语言\n   - <dc-relation> 相关资料\n   - <dc-coverage> 覆盖范围\n   - <dc-rights> 权限描述\n   \n2. <manifest>\n   文件列表，列出书籍出版的所有文件，但是不包括 mimetype、container.xml、content.opf，由一个个子元素构成\n   ```\n   <item id=\"\" href=\"\" media-type=\"\">\n   ```\n   - id 文件的id号\n   - href 文件的相对路径\n   - media-type 文件的媒体类型\n   \n   ```\n   <manifest>\n    <item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\" />\n    <item href=\"cover.xhtml\" id=\"cover\" media-type=\"application/xhtml+xml\"/>\n    <item href=\"copyright.xhtml\" id=\"copyright\" media-type=\"application/xhtml+xml\"/>\n    <item href=\"catalog.xhtml\" id=\"catalog\" media-type=\"application/xhtml+xml\"/>\n    <item href=\"chap0.xhtml\" id=\"chap0\" media-type=\"application/xhtml+xml\"/>\n    </manifest>\n   \n   ```\n   \n3. <spine toc=\"ncx\">\n   \n   提供书籍的线性阅读次序，由一个个子元素构成\n   ```\n   <itemref idref=\"copyright\">\n   ```\n   - idref 即参考manifest列出的id\n   \n4. <guide>\n   指南，一次列出电子书的特定页面\n\n   ```\n   <guide>\n    <reference href=\"cover.xhtml\" type=\"text\" title=\"封面\"/>\n    <reference href=\"catalog.xhtml\" type=\"text\" title=\"目录\"/>\n   </guide>\n   ```\n5. <tour>\n    导读，可以根据读者水平或阅读目的，按一定的次序，选择电子书的部分页面组成导读\n\n\n#### NCX文件\n\nNCX文件是epub电子书的另一个重要文件，用于制作电子书的目录。.ncx文件中最主要的节点是navMap,navMap节点是由许多navPoint节点组成\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n    <head>\n        <meta content=\"178_0\" name=\"dtb:uid\"/>\n        <meta content=\"2\" name=\"dtb:depth\"/>\n        <meta content=\"0\" name=\"dtb:totalPageCount\"/>\n        <meta content=\"0\" name=\"dtb:maxPageNumber\"/>\n    </head>\n    <docTitle>\n        <text>1984</text>\n    </docTitle>\n    <docAuthor>\n        <text>[英] 乔治·奥威尔</text>\n    </docAuthor>\n    <navMap>\n        <navPoint id=\"catalog\" playOrder=\"0\">\n            <navLabel>\n                <text>目录</text>\n            </navLabel>\n            <content src=\"catalog.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap0\" playOrder=\"1\">\n            <navLabel>\n                <text>前言</text>\n            </navLabel>\n            <content src=\"chap0.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap1\" playOrder=\"2\">\n            <navLabel>\n                <text>　　第一部</text>\n            </navLabel>\n            <content src=\"chap1.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap2\" playOrder=\"3\">\n            <navLabel>\n                <text>　　第1节</text>\n            </navLabel>\n            <content src=\"chap2.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap3\" playOrder=\"4\">\n            <navLabel>\n                <text>　　第2节</text>\n            </navLabel>\n            <content src=\"chap3.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap4\" playOrder=\"5\">\n            <navLabel>\n                <text>　　第3节</text>\n            </navLabel>\n            <content src=\"chap4.xhtml\"/>\n        </navPoint>\n    </navMap>\n</ncx>\n```\n\n### 开源项目\n\n目前支持`EPUB`格式的开源阅读器有：\n\n#### iOS 阅读器\n\n- [Reader](https://github.com/GGGHub/Reader)--一款基于CoreText实现的电子书阅读器，支持txt，epub格式\n- [FolioReaderKit](https://github.com/FolioReader/FolioReaderKit)--Swift版的ePub阅读器\n- [KFEpubKit](https://github.com/ricobeck/KFEpubKit)--支持iOS和OSX的epub阅读器\n- [Reader](https://github.com/vfr/Reader)--pdf阅读器\n\n#### Android 阅读器\n\n- [BookReader](https://github.com/JustWayward/BookReader)--一款比较完整的阅读器，支持txt/pdf/epub书籍阅读\n- [FBReader](https://github.com/geometer/FBReader)--C++项目，支持多平台的阅读器\n- [FolioReader-Android](https://github.com/FolioReader/FolioReader-Android)--FolioReader的android版本\n\n","source":"_posts/EPUB文件格式解析.md","raw":"title: EPUB文件格式解析\ntags:\n  - iOS进阶\n  - epub\n  - reader\n  - ''\n  - ''\n  - ''\ncategories:\n  - iOS\ndate: 2017-07-20 17:45:00\n---\n\n### 背景知识\n\n`EPUB`是Electronic Publication的缩写，是一种电子图书标准，`EPUB`是一个自由的开发标准，属于一种可以自动重新编排的内容，也就是说`EPUB`格式的图书，它的文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。\n\n### 文件组成\n\n一个未经加密处理的epub电子书由以下三部分组成：\n\n1. META-INF（文件夹，里面有一个container.xml文件）\n2. OEBPS （文件夹，包含images文件夹、很多xhtml文件、css文件和content.opf文件）\n3. mimetype\n\n#### 文件mimetype\n每个epub电子书均包含一个mimetype的文件，且内容不变，用以说明epub的文件格式。\n```\napplication/epub+zip\n```\n\n#### 文件夹META-INF\nMETA-INF用于存放容器信息，默认情况下此目录只包含一个文件container.xml，文件内容如下：\n```\n<?xml version=\"1.0\"?>\n<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n    <rootfiles>\n        <rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\"/>\n    </rootfiles>\n</container>\n```\ncontainer.xml文件的主要功能用于告诉阅读器，电子书的根文件的路径和打开格式\n\n#### 文件夹OEBPS\n\nOEBPS目录用于存放OPF文档、CSS文档、NCX文档\n\n#### 文件OPF\nOPF文档是epub的核心文件，且是一个标准的xml文件，依据OPF规范，此文件的根元素为`<package>`\n```\n<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"2.0\" unique-identifier=\"uuid_id\">\n```\n其内容主要由五部分组成：\n\n1. <metadata>\n   元数据信息，这个标签里面是书籍的出版信息，由两个子元素组成\n   - <dc-title> 标题\n   - <dc-creator> 责任人\n   - <dc-subject> 主题词、关键词\n   - <dc-descributor> 内容描述\n   - <dc-date> 日期\n   - <dc-type> 类型\n   - <dc-publisher> 出版者\n   - <dc-contributor> 发行者\n   - <dc-format> 格式\n   - <dc-identifier> 标识信息\n   - <dc-source> 来源信息\n   - <dc-language> 语言\n   - <dc-relation> 相关资料\n   - <dc-coverage> 覆盖范围\n   - <dc-rights> 权限描述\n   \n2. <manifest>\n   文件列表，列出书籍出版的所有文件，但是不包括 mimetype、container.xml、content.opf，由一个个子元素构成\n   ```\n   <item id=\"\" href=\"\" media-type=\"\">\n   ```\n   - id 文件的id号\n   - href 文件的相对路径\n   - media-type 文件的媒体类型\n   \n   ```\n   <manifest>\n    <item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\" />\n    <item href=\"cover.xhtml\" id=\"cover\" media-type=\"application/xhtml+xml\"/>\n    <item href=\"copyright.xhtml\" id=\"copyright\" media-type=\"application/xhtml+xml\"/>\n    <item href=\"catalog.xhtml\" id=\"catalog\" media-type=\"application/xhtml+xml\"/>\n    <item href=\"chap0.xhtml\" id=\"chap0\" media-type=\"application/xhtml+xml\"/>\n    </manifest>\n   \n   ```\n   \n3. <spine toc=\"ncx\">\n   \n   提供书籍的线性阅读次序，由一个个子元素构成\n   ```\n   <itemref idref=\"copyright\">\n   ```\n   - idref 即参考manifest列出的id\n   \n4. <guide>\n   指南，一次列出电子书的特定页面\n\n   ```\n   <guide>\n    <reference href=\"cover.xhtml\" type=\"text\" title=\"封面\"/>\n    <reference href=\"catalog.xhtml\" type=\"text\" title=\"目录\"/>\n   </guide>\n   ```\n5. <tour>\n    导读，可以根据读者水平或阅读目的，按一定的次序，选择电子书的部分页面组成导读\n\n\n#### NCX文件\n\nNCX文件是epub电子书的另一个重要文件，用于制作电子书的目录。.ncx文件中最主要的节点是navMap,navMap节点是由许多navPoint节点组成\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n    <head>\n        <meta content=\"178_0\" name=\"dtb:uid\"/>\n        <meta content=\"2\" name=\"dtb:depth\"/>\n        <meta content=\"0\" name=\"dtb:totalPageCount\"/>\n        <meta content=\"0\" name=\"dtb:maxPageNumber\"/>\n    </head>\n    <docTitle>\n        <text>1984</text>\n    </docTitle>\n    <docAuthor>\n        <text>[英] 乔治·奥威尔</text>\n    </docAuthor>\n    <navMap>\n        <navPoint id=\"catalog\" playOrder=\"0\">\n            <navLabel>\n                <text>目录</text>\n            </navLabel>\n            <content src=\"catalog.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap0\" playOrder=\"1\">\n            <navLabel>\n                <text>前言</text>\n            </navLabel>\n            <content src=\"chap0.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap1\" playOrder=\"2\">\n            <navLabel>\n                <text>　　第一部</text>\n            </navLabel>\n            <content src=\"chap1.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap2\" playOrder=\"3\">\n            <navLabel>\n                <text>　　第1节</text>\n            </navLabel>\n            <content src=\"chap2.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap3\" playOrder=\"4\">\n            <navLabel>\n                <text>　　第2节</text>\n            </navLabel>\n            <content src=\"chap3.xhtml\"/>\n        </navPoint>\n        <navPoint id=\"chap4\" playOrder=\"5\">\n            <navLabel>\n                <text>　　第3节</text>\n            </navLabel>\n            <content src=\"chap4.xhtml\"/>\n        </navPoint>\n    </navMap>\n</ncx>\n```\n\n### 开源项目\n\n目前支持`EPUB`格式的开源阅读器有：\n\n#### iOS 阅读器\n\n- [Reader](https://github.com/GGGHub/Reader)--一款基于CoreText实现的电子书阅读器，支持txt，epub格式\n- [FolioReaderKit](https://github.com/FolioReader/FolioReaderKit)--Swift版的ePub阅读器\n- [KFEpubKit](https://github.com/ricobeck/KFEpubKit)--支持iOS和OSX的epub阅读器\n- [Reader](https://github.com/vfr/Reader)--pdf阅读器\n\n#### Android 阅读器\n\n- [BookReader](https://github.com/JustWayward/BookReader)--一款比较完整的阅读器，支持txt/pdf/epub书籍阅读\n- [FBReader](https://github.com/geometer/FBReader)--C++项目，支持多平台的阅读器\n- [FolioReader-Android](https://github.com/FolioReader/FolioReader-Android)--FolioReader的android版本\n\n","slug":"EPUB文件格式解析","published":1,"updated":"2018-08-31T09:43:07.167Z","_id":"cjlhoqwhp000fkj79xgwza4py","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><p><code>EPUB</code>是Electronic Publication的缩写，是一种电子图书标准，<code>EPUB</code>是一个自由的开发标准，属于一种可以自动重新编排的内容，也就是说<code>EPUB</code>格式的图书，它的文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。</p>\n<h3 id=\"文件组成\"><a href=\"#文件组成\" class=\"headerlink\" title=\"文件组成\"></a>文件组成</h3><p>一个未经加密处理的epub电子书由以下三部分组成：</p>\n<ol>\n<li>META-INF（文件夹，里面有一个container.xml文件）</li>\n<li>OEBPS （文件夹，包含images文件夹、很多xhtml文件、css文件和content.opf文件）</li>\n<li>mimetype</li>\n</ol>\n<h4 id=\"文件mimetype\"><a href=\"#文件mimetype\" class=\"headerlink\" title=\"文件mimetype\"></a>文件mimetype</h4><p>每个epub电子书均包含一个mimetype的文件，且内容不变，用以说明epub的文件格式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">application/epub+zip</div></pre></td></tr></table></figure></p>\n<h4 id=\"文件夹META-INF\"><a href=\"#文件夹META-INF\" class=\"headerlink\" title=\"文件夹META-INF\"></a>文件夹META-INF</h4><p>META-INF用于存放容器信息，默认情况下此目录只包含一个文件container.xml，文件内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class=\"line\">&lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt;</div><div class=\"line\">    &lt;rootfiles&gt;</div><div class=\"line\">        &lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt;</div><div class=\"line\">    &lt;/rootfiles&gt;</div><div class=\"line\">&lt;/container&gt;</div></pre></td></tr></table></figure></p>\n<p>container.xml文件的主要功能用于告诉阅读器，电子书的根文件的路径和打开格式</p>\n<h4 id=\"文件夹OEBPS\"><a href=\"#文件夹OEBPS\" class=\"headerlink\" title=\"文件夹OEBPS\"></a>文件夹OEBPS</h4><p>OEBPS目录用于存放OPF文档、CSS文档、NCX文档</p>\n<h4 id=\"文件OPF\"><a href=\"#文件OPF\" class=\"headerlink\" title=\"文件OPF\"></a>文件OPF</h4><p>OPF文档是epub的核心文件，且是一个标准的xml文件，依据OPF规范，此文件的根元素为<code>&lt;package&gt;</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot; unique-identifier=&quot;uuid_id&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>其内容主要由五部分组成：</p>\n<ol>\n<li><p><metadata><br>元数据信息，这个标签里面是书籍的出版信息，由两个子元素组成</metadata></p>\n<ul>\n<li><dc-title> 标题</dc-title></li>\n<li><dc-creator> 责任人</dc-creator></li>\n<li><dc-subject> 主题词、关键词</dc-subject></li>\n<li><dc-descributor> 内容描述</dc-descributor></li>\n<li><dc-date> 日期</dc-date></li>\n<li><dc-type> 类型</dc-type></li>\n<li><dc-publisher> 出版者</dc-publisher></li>\n<li><dc-contributor> 发行者</dc-contributor></li>\n<li><dc-format> 格式</dc-format></li>\n<li><dc-identifier> 标识信息</dc-identifier></li>\n<li><dc-source> 来源信息</dc-source></li>\n<li><dc-language> 语言</dc-language></li>\n<li><dc-relation> 相关资料</dc-relation></li>\n<li><dc-coverage> 覆盖范围</dc-coverage></li>\n<li><dc-rights> 权限描述</dc-rights></li>\n</ul>\n</li>\n<li><p><manifest><br>文件列表，列出书籍出版的所有文件，但是不包括 mimetype、container.xml、content.opf，由一个个子元素构成</manifest></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;item id=&quot;&quot; href=&quot;&quot; media-type=&quot;&quot;&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>id 文件的id号</li>\n<li>href 文件的相对路径</li>\n<li>media-type 文件的媒体类型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;manifest&gt;</div><div class=\"line\"> &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot; /&gt;</div><div class=\"line\"> &lt;item href=&quot;cover.xhtml&quot; id=&quot;cover&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;item href=&quot;copyright.xhtml&quot; id=&quot;copyright&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;item href=&quot;catalog.xhtml&quot; id=&quot;catalog&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;item href=&quot;chap0.xhtml&quot; id=&quot;chap0&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;/manifest&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><spine toc=\"ncx\">\n\n<p>提供书籍的线性阅读次序，由一个个子元素构成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;itemref idref=&quot;copyright&quot;&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>idref 即参考manifest列出的id</li>\n</ul>\n</spine></li>\n<li><p><guide><br>指南，一次列出电子书的特定页面</guide></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;guide&gt;</div><div class=\"line\"> &lt;reference href=&quot;cover.xhtml&quot; type=&quot;text&quot; title=&quot;封面&quot;/&gt;</div><div class=\"line\"> &lt;reference href=&quot;catalog.xhtml&quot; type=&quot;text&quot; title=&quot;目录&quot;/&gt;</div><div class=\"line\">&lt;/guide&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p><tour><br> 导读，可以根据读者水平或阅读目的，按一定的次序，选择电子书的部分页面组成导读</tour></p>\n</li>\n</ol>\n<h4 id=\"NCX文件\"><a href=\"#NCX文件\" class=\"headerlink\" title=\"NCX文件\"></a>NCX文件</h4><p>NCX文件是epub电子书的另一个重要文件，用于制作电子书的目录。.ncx文件中最主要的节点是navMap,navMap节点是由许多navPoint节点组成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot;&gt;</div><div class=\"line\">    &lt;head&gt;</div><div class=\"line\">        &lt;meta content=&quot;178_0&quot; name=&quot;dtb:uid&quot;/&gt;</div><div class=\"line\">        &lt;meta content=&quot;2&quot; name=&quot;dtb:depth&quot;/&gt;</div><div class=\"line\">        &lt;meta content=&quot;0&quot; name=&quot;dtb:totalPageCount&quot;/&gt;</div><div class=\"line\">        &lt;meta content=&quot;0&quot; name=&quot;dtb:maxPageNumber&quot;/&gt;</div><div class=\"line\">    &lt;/head&gt;</div><div class=\"line\">    &lt;docTitle&gt;</div><div class=\"line\">        &lt;text&gt;1984&lt;/text&gt;</div><div class=\"line\">    &lt;/docTitle&gt;</div><div class=\"line\">    &lt;docAuthor&gt;</div><div class=\"line\">        &lt;text&gt;[英] 乔治·奥威尔&lt;/text&gt;</div><div class=\"line\">    &lt;/docAuthor&gt;</div><div class=\"line\">    &lt;navMap&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;catalog&quot; playOrder=&quot;0&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;目录&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;catalog.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap0&quot; playOrder=&quot;1&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;前言&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap0.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap1&quot; playOrder=&quot;2&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第一部&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap1.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap2&quot; playOrder=&quot;3&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第1节&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap2.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap3&quot; playOrder=&quot;4&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第2节&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap3.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap4&quot; playOrder=&quot;5&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第3节&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap4.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">    &lt;/navMap&gt;</div><div class=\"line\">&lt;/ncx&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h3><p>目前支持<code>EPUB</code>格式的开源阅读器有：</p>\n<h4 id=\"iOS-阅读器\"><a href=\"#iOS-阅读器\" class=\"headerlink\" title=\"iOS 阅读器\"></a>iOS 阅读器</h4><ul>\n<li><a href=\"https://github.com/GGGHub/Reader\" target=\"_blank\" rel=\"external\">Reader</a>–一款基于CoreText实现的电子书阅读器，支持txt，epub格式</li>\n<li><a href=\"https://github.com/FolioReader/FolioReaderKit\" target=\"_blank\" rel=\"external\">FolioReaderKit</a>–Swift版的ePub阅读器</li>\n<li><a href=\"https://github.com/ricobeck/KFEpubKit\" target=\"_blank\" rel=\"external\">KFEpubKit</a>–支持iOS和OSX的epub阅读器</li>\n<li><a href=\"https://github.com/vfr/Reader\" target=\"_blank\" rel=\"external\">Reader</a>–pdf阅读器</li>\n</ul>\n<h4 id=\"Android-阅读器\"><a href=\"#Android-阅读器\" class=\"headerlink\" title=\"Android 阅读器\"></a>Android 阅读器</h4><ul>\n<li><a href=\"https://github.com/JustWayward/BookReader\" target=\"_blank\" rel=\"external\">BookReader</a>–一款比较完整的阅读器，支持txt/pdf/epub书籍阅读</li>\n<li><a href=\"https://github.com/geometer/FBReader\" target=\"_blank\" rel=\"external\">FBReader</a>–C++项目，支持多平台的阅读器</li>\n<li><a href=\"https://github.com/FolioReader/FolioReader-Android\" target=\"_blank\" rel=\"external\">FolioReader-Android</a>–FolioReader的android版本</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><p><code>EPUB</code>是Electronic Publication的缩写，是一种电子图书标准，<code>EPUB</code>是一个自由的开发标准，属于一种可以自动重新编排的内容，也就是说<code>EPUB</code>格式的图书，它的文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。</p>\n<h3 id=\"文件组成\"><a href=\"#文件组成\" class=\"headerlink\" title=\"文件组成\"></a>文件组成</h3><p>一个未经加密处理的epub电子书由以下三部分组成：</p>\n<ol>\n<li>META-INF（文件夹，里面有一个container.xml文件）</li>\n<li>OEBPS （文件夹，包含images文件夹、很多xhtml文件、css文件和content.opf文件）</li>\n<li>mimetype</li>\n</ol>\n<h4 id=\"文件mimetype\"><a href=\"#文件mimetype\" class=\"headerlink\" title=\"文件mimetype\"></a>文件mimetype</h4><p>每个epub电子书均包含一个mimetype的文件，且内容不变，用以说明epub的文件格式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">application/epub+zip</div></pre></td></tr></table></figure></p>\n<h4 id=\"文件夹META-INF\"><a href=\"#文件夹META-INF\" class=\"headerlink\" title=\"文件夹META-INF\"></a>文件夹META-INF</h4><p>META-INF用于存放容器信息，默认情况下此目录只包含一个文件container.xml，文件内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class=\"line\">&lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt;</div><div class=\"line\">    &lt;rootfiles&gt;</div><div class=\"line\">        &lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt;</div><div class=\"line\">    &lt;/rootfiles&gt;</div><div class=\"line\">&lt;/container&gt;</div></pre></td></tr></table></figure></p>\n<p>container.xml文件的主要功能用于告诉阅读器，电子书的根文件的路径和打开格式</p>\n<h4 id=\"文件夹OEBPS\"><a href=\"#文件夹OEBPS\" class=\"headerlink\" title=\"文件夹OEBPS\"></a>文件夹OEBPS</h4><p>OEBPS目录用于存放OPF文档、CSS文档、NCX文档</p>\n<h4 id=\"文件OPF\"><a href=\"#文件OPF\" class=\"headerlink\" title=\"文件OPF\"></a>文件OPF</h4><p>OPF文档是epub的核心文件，且是一个标准的xml文件，依据OPF规范，此文件的根元素为<code>&lt;package&gt;</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot; unique-identifier=&quot;uuid_id&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p>其内容主要由五部分组成：</p>\n<ol>\n<li><p><metadata><br>元数据信息，这个标签里面是书籍的出版信息，由两个子元素组成</p>\n<ul>\n<li><dc-title> 标题</li>\n<li><dc-creator> 责任人</li>\n<li><dc-subject> 主题词、关键词</li>\n<li><dc-descributor> 内容描述</li>\n<li><dc-date> 日期</li>\n<li><dc-type> 类型</li>\n<li><dc-publisher> 出版者</li>\n<li><dc-contributor> 发行者</li>\n<li><dc-format> 格式</li>\n<li><dc-identifier> 标识信息</li>\n<li><dc-source> 来源信息</li>\n<li><dc-language> 语言</li>\n<li><dc-relation> 相关资料</li>\n<li><dc-coverage> 覆盖范围</li>\n<li><dc-rights> 权限描述</li>\n</ul>\n</li>\n<li><p><manifest><br>文件列表，列出书籍出版的所有文件，但是不包括 mimetype、container.xml、content.opf，由一个个子元素构成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;item id=&quot;&quot; href=&quot;&quot; media-type=&quot;&quot;&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>id 文件的id号</li>\n<li>href 文件的相对路径</li>\n<li>media-type 文件的媒体类型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;manifest&gt;</div><div class=\"line\"> &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot; /&gt;</div><div class=\"line\"> &lt;item href=&quot;cover.xhtml&quot; id=&quot;cover&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;item href=&quot;copyright.xhtml&quot; id=&quot;copyright&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;item href=&quot;catalog.xhtml&quot; id=&quot;catalog&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;item href=&quot;chap0.xhtml&quot; id=&quot;chap0&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;</div><div class=\"line\"> &lt;/manifest&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><spine toc=\"ncx\">\n\n<p>提供书籍的线性阅读次序，由一个个子元素构成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;itemref idref=&quot;copyright&quot;&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>idref 即参考manifest列出的id</li>\n</ul>\n</li>\n<li><p><guide><br>指南，一次列出电子书的特定页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;guide&gt;</div><div class=\"line\"> &lt;reference href=&quot;cover.xhtml&quot; type=&quot;text&quot; title=&quot;封面&quot;/&gt;</div><div class=\"line\"> &lt;reference href=&quot;catalog.xhtml&quot; type=&quot;text&quot; title=&quot;目录&quot;/&gt;</div><div class=\"line\">&lt;/guide&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p><tour><br> 导读，可以根据读者水平或阅读目的，按一定的次序，选择电子书的部分页面组成导读</p>\n</li>\n</ol>\n<h4 id=\"NCX文件\"><a href=\"#NCX文件\" class=\"headerlink\" title=\"NCX文件\"></a>NCX文件</h4><p>NCX文件是epub电子书的另一个重要文件，用于制作电子书的目录。.ncx文件中最主要的节点是navMap,navMap节点是由许多navPoint节点组成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot;&gt;</div><div class=\"line\">    &lt;head&gt;</div><div class=\"line\">        &lt;meta content=&quot;178_0&quot; name=&quot;dtb:uid&quot;/&gt;</div><div class=\"line\">        &lt;meta content=&quot;2&quot; name=&quot;dtb:depth&quot;/&gt;</div><div class=\"line\">        &lt;meta content=&quot;0&quot; name=&quot;dtb:totalPageCount&quot;/&gt;</div><div class=\"line\">        &lt;meta content=&quot;0&quot; name=&quot;dtb:maxPageNumber&quot;/&gt;</div><div class=\"line\">    &lt;/head&gt;</div><div class=\"line\">    &lt;docTitle&gt;</div><div class=\"line\">        &lt;text&gt;1984&lt;/text&gt;</div><div class=\"line\">    &lt;/docTitle&gt;</div><div class=\"line\">    &lt;docAuthor&gt;</div><div class=\"line\">        &lt;text&gt;[英] 乔治·奥威尔&lt;/text&gt;</div><div class=\"line\">    &lt;/docAuthor&gt;</div><div class=\"line\">    &lt;navMap&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;catalog&quot; playOrder=&quot;0&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;目录&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;catalog.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap0&quot; playOrder=&quot;1&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;前言&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap0.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap1&quot; playOrder=&quot;2&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第一部&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap1.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap2&quot; playOrder=&quot;3&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第1节&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap2.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap3&quot; playOrder=&quot;4&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第2节&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap3.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">        &lt;navPoint id=&quot;chap4&quot; playOrder=&quot;5&quot;&gt;</div><div class=\"line\">            &lt;navLabel&gt;</div><div class=\"line\">                &lt;text&gt;　　第3节&lt;/text&gt;</div><div class=\"line\">            &lt;/navLabel&gt;</div><div class=\"line\">            &lt;content src=&quot;chap4.xhtml&quot;/&gt;</div><div class=\"line\">        &lt;/navPoint&gt;</div><div class=\"line\">    &lt;/navMap&gt;</div><div class=\"line\">&lt;/ncx&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h3><p>目前支持<code>EPUB</code>格式的开源阅读器有：</p>\n<h4 id=\"iOS-阅读器\"><a href=\"#iOS-阅读器\" class=\"headerlink\" title=\"iOS 阅读器\"></a>iOS 阅读器</h4><ul>\n<li><a href=\"https://github.com/GGGHub/Reader\">Reader</a>–一款基于CoreText实现的电子书阅读器，支持txt，epub格式</li>\n<li><a href=\"https://github.com/FolioReader/FolioReaderKit\">FolioReaderKit</a>–Swift版的ePub阅读器</li>\n<li><a href=\"https://github.com/ricobeck/KFEpubKit\">KFEpubKit</a>–支持iOS和OSX的epub阅读器</li>\n<li><a href=\"https://github.com/vfr/Reader\">Reader</a>–pdf阅读器</li>\n</ul>\n<h4 id=\"Android-阅读器\"><a href=\"#Android-阅读器\" class=\"headerlink\" title=\"Android 阅读器\"></a>Android 阅读器</h4><ul>\n<li><a href=\"https://github.com/JustWayward/BookReader\">BookReader</a>–一款比较完整的阅读器，支持txt/pdf/epub书籍阅读</li>\n<li><a href=\"https://github.com/geometer/FBReader\">FBReader</a>–C++项目，支持多平台的阅读器</li>\n<li><a href=\"https://github.com/FolioReader/FolioReader-Android\">FolioReader-Android</a>–FolioReader的android版本</li>\n</ul>\n"},{"title":"NS_UNAVAILABLE和NS_DESIGNATED是什么","date":"2017-12-14T11:15:00.000Z","_content":"经常我们在阅读一些开源项目的源码时会发现有时候作者会在声明的方法后面添加`NS_UNAVAILABLE`、`NS_EDSIGNATED_INITIALIZER`这样的关键字。这表示什么意思呢？\n\n其实，这两个关键字是苹果提供给我们来约束定义方式，使得接口更加清晰的。\n\n下面就来跟大家解释一下这两个字段的具体作用：\n\n## NS_UNAVAILABLE\n\n`NS_UNAVAILABLE`的作用是直接禁止此方法的使用，一般常见用法如下：\n```\n+ (instancetype)new NS_UNAVAILABLE;\n+ (instancetype)init NS_UNAVAILABLE;\n```\n这样就不能直接使用这两种创建实例的方法，而需要使用开源库自定义的初始化方法，从而确保了创建实例的统一性\n\n## NS_EDSIGNATED_INITIALIZER\n\n`NS_EDSIGNATED_INITIALIZER`的作用是指定构造器，通常来说指定初始化函数对一个类来说非常重要，参数也会比较多，为了适应不同的初始化需求就有了便利初始化函数。\n\n```\n- (instancetype)initWithName:(NSString *)name NS_EDSIGNATED_INITIALIZER;\n```\n声明指定构造器函数的一个目的是帮助规范代码，找到程序中潜在问题。\n\n在Objective-C中，指定初始化函数的使用有一些规范：\n\n- 子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数\n- 如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其他初始化函数，不能调用super的初始化函数。\n","source":"_posts/NS-UNAVAILABLE和NS-DESIGNATED是什么.md","raw":"title: NS_UNAVAILABLE和NS_DESIGNATED是什么\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2017-12-14 19:15:00\n---\n经常我们在阅读一些开源项目的源码时会发现有时候作者会在声明的方法后面添加`NS_UNAVAILABLE`、`NS_EDSIGNATED_INITIALIZER`这样的关键字。这表示什么意思呢？\n\n其实，这两个关键字是苹果提供给我们来约束定义方式，使得接口更加清晰的。\n\n下面就来跟大家解释一下这两个字段的具体作用：\n\n## NS_UNAVAILABLE\n\n`NS_UNAVAILABLE`的作用是直接禁止此方法的使用，一般常见用法如下：\n```\n+ (instancetype)new NS_UNAVAILABLE;\n+ (instancetype)init NS_UNAVAILABLE;\n```\n这样就不能直接使用这两种创建实例的方法，而需要使用开源库自定义的初始化方法，从而确保了创建实例的统一性\n\n## NS_EDSIGNATED_INITIALIZER\n\n`NS_EDSIGNATED_INITIALIZER`的作用是指定构造器，通常来说指定初始化函数对一个类来说非常重要，参数也会比较多，为了适应不同的初始化需求就有了便利初始化函数。\n\n```\n- (instancetype)initWithName:(NSString *)name NS_EDSIGNATED_INITIALIZER;\n```\n声明指定构造器函数的一个目的是帮助规范代码，找到程序中潜在问题。\n\n在Objective-C中，指定初始化函数的使用有一些规范：\n\n- 子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数\n- 如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其他初始化函数，不能调用super的初始化函数。\n","slug":"NS-UNAVAILABLE和NS-DESIGNATED是什么","published":1,"updated":"2018-08-31T09:42:02.638Z","_id":"cjlhoqwhs000jkj79wc53ibf2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>经常我们在阅读一些开源项目的源码时会发现有时候作者会在声明的方法后面添加<code>NS_UNAVAILABLE</code>、<code>NS_EDSIGNATED_INITIALIZER</code>这样的关键字。这表示什么意思呢？</p>\n<p>其实，这两个关键字是苹果提供给我们来约束定义方式，使得接口更加清晰的。</p>\n<p>下面就来跟大家解释一下这两个字段的具体作用：</p>\n<h2 id=\"NS-UNAVAILABLE\"><a href=\"#NS-UNAVAILABLE\" class=\"headerlink\" title=\"NS_UNAVAILABLE\"></a>NS_UNAVAILABLE</h2><p><code>NS_UNAVAILABLE</code>的作用是直接禁止此方法的使用，一般常见用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (instancetype)new NS_UNAVAILABLE;</div><div class=\"line\">+ (instancetype)init NS_UNAVAILABLE;</div></pre></td></tr></table></figure></p>\n<p>这样就不能直接使用这两种创建实例的方法，而需要使用开源库自定义的初始化方法，从而确保了创建实例的统一性</p>\n<h2 id=\"NS-EDSIGNATED-INITIALIZER\"><a href=\"#NS-EDSIGNATED-INITIALIZER\" class=\"headerlink\" title=\"NS_EDSIGNATED_INITIALIZER\"></a>NS_EDSIGNATED_INITIALIZER</h2><p><code>NS_EDSIGNATED_INITIALIZER</code>的作用是指定构造器，通常来说指定初始化函数对一个类来说非常重要，参数也会比较多，为了适应不同的初始化需求就有了便利初始化函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)initWithName:(NSString *)name NS_EDSIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>\n<p>声明指定构造器函数的一个目的是帮助规范代码，找到程序中潜在问题。</p>\n<p>在Objective-C中，指定初始化函数的使用有一些规范：</p>\n<ul>\n<li>子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数</li>\n<li>如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其他初始化函数，不能调用super的初始化函数。</li>\n</ul>\n","excerpt":"","more":"<p>经常我们在阅读一些开源项目的源码时会发现有时候作者会在声明的方法后面添加<code>NS_UNAVAILABLE</code>、<code>NS_EDSIGNATED_INITIALIZER</code>这样的关键字。这表示什么意思呢？</p>\n<p>其实，这两个关键字是苹果提供给我们来约束定义方式，使得接口更加清晰的。</p>\n<p>下面就来跟大家解释一下这两个字段的具体作用：</p>\n<h2 id=\"NS-UNAVAILABLE\"><a href=\"#NS-UNAVAILABLE\" class=\"headerlink\" title=\"NS_UNAVAILABLE\"></a>NS_UNAVAILABLE</h2><p><code>NS_UNAVAILABLE</code>的作用是直接禁止此方法的使用，一般常见用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (instancetype)new NS_UNAVAILABLE;</div><div class=\"line\">+ (instancetype)init NS_UNAVAILABLE;</div></pre></td></tr></table></figure></p>\n<p>这样就不能直接使用这两种创建实例的方法，而需要使用开源库自定义的初始化方法，从而确保了创建实例的统一性</p>\n<h2 id=\"NS-EDSIGNATED-INITIALIZER\"><a href=\"#NS-EDSIGNATED-INITIALIZER\" class=\"headerlink\" title=\"NS_EDSIGNATED_INITIALIZER\"></a>NS_EDSIGNATED_INITIALIZER</h2><p><code>NS_EDSIGNATED_INITIALIZER</code>的作用是指定构造器，通常来说指定初始化函数对一个类来说非常重要，参数也会比较多，为了适应不同的初始化需求就有了便利初始化函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)initWithName:(NSString *)name NS_EDSIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>\n<p>声明指定构造器函数的一个目的是帮助规范代码，找到程序中潜在问题。</p>\n<p>在Objective-C中，指定初始化函数的使用有一些规范：</p>\n<ul>\n<li>子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数</li>\n<li>如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其他初始化函数，不能调用super的初始化函数。</li>\n</ul>\n"},{"title":"ReactNative入门","date":"2016-11-02T01:32:00.000Z","_content":"\n### 安装\n\n#### Homebrew\n\n[Homebrew](http://brew.sh/)是Mac系统的包管理器，我们要使用它安装NodeJS和一些其他必须的工具。\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n#### Node.JS\n\n使用Homebrew安装[Node.js](https://nodejs.org/en/)\n\n```shell\nbrew install node\n```\n\n安装完成后最好设置npm镜像以加速安装过程\n\n```sh\nnpm config set registry https://registry.npm.taobao.org --global\nnpm config set disturl https://npm.taobao.org/dist --global\n```\n\n#### React Native的命令行工具(react-native-cli)\n\nReact Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务等任务。\n\n```shell\nnpm install -g react-native-cli\n```\n\n#### Xcode\n\nReact Native目前需要Xcode 7.0或更高版本。\n\n### 推荐安装的工具\n\n#### Watchman\n\n[Watchman](https://facebook.github.io/watchman/docs/install.html)是由Facebook提供的监视文件系统变更的工具。安装此工具可以提供开发时的性能\n\n```shell\nbrew install watchman\n```\n\n#### Flow\n\n[Flow](https://www.flowtype.org/)是一个静态的JS类型检查工具。(新手建议跳过，降低学习成本)\n\n```shell\nbrew install flow\n```\n\n#### Sublime Text 3\n\n[Sublime](http://www.sublimetext.com)是一款开源的编辑器，支持插件安装。\n\n##### React Native开发推荐的一些插件\n\n1. ReactJS: 支持React开发，代码提示，高亮显示\n\n2. Emmet: 前端开发必备\n\n3. Terminal: 在sublime中打开终端并定位到当前目录\n\n4. react-native-snippets: react native的代码片段\n\n   ​\n\n#### 测试安装\n\n```shell\nreact-native init ReactNativeDemo\ncd ReactNativeDemo\nreact-native run-ios\n```\n\n在测试过程中遇到一个问题导致编译失败，报错的原因是Watchman没有安装，于是我又尝试用Homebrew安装Watchman，结果在快要完成的时候报错了，报错的原因是未正确安装Command Line Tools,执行`xcode-select --install`，安装完成后再次安装Watchman，并运行通过。\n\n### 参考文章\n\n[ReactNative搭建开发环境](http://reactnative.cn/docs/0.36/getting-started.html#content)\n\n[用Sublime 3作为ReactNative的开发IDE](http://www.jianshu.com/p/2ddfff095e90)\n\n","source":"_posts/ReactNative入门.md","raw":"title: ReactNative入门\ntags:\n  - RN\ncategories:\n  - ReactNative\ndate: 2016-11-02 09:32:00\n---\n\n### 安装\n\n#### Homebrew\n\n[Homebrew](http://brew.sh/)是Mac系统的包管理器，我们要使用它安装NodeJS和一些其他必须的工具。\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n#### Node.JS\n\n使用Homebrew安装[Node.js](https://nodejs.org/en/)\n\n```shell\nbrew install node\n```\n\n安装完成后最好设置npm镜像以加速安装过程\n\n```sh\nnpm config set registry https://registry.npm.taobao.org --global\nnpm config set disturl https://npm.taobao.org/dist --global\n```\n\n#### React Native的命令行工具(react-native-cli)\n\nReact Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务等任务。\n\n```shell\nnpm install -g react-native-cli\n```\n\n#### Xcode\n\nReact Native目前需要Xcode 7.0或更高版本。\n\n### 推荐安装的工具\n\n#### Watchman\n\n[Watchman](https://facebook.github.io/watchman/docs/install.html)是由Facebook提供的监视文件系统变更的工具。安装此工具可以提供开发时的性能\n\n```shell\nbrew install watchman\n```\n\n#### Flow\n\n[Flow](https://www.flowtype.org/)是一个静态的JS类型检查工具。(新手建议跳过，降低学习成本)\n\n```shell\nbrew install flow\n```\n\n#### Sublime Text 3\n\n[Sublime](http://www.sublimetext.com)是一款开源的编辑器，支持插件安装。\n\n##### React Native开发推荐的一些插件\n\n1. ReactJS: 支持React开发，代码提示，高亮显示\n\n2. Emmet: 前端开发必备\n\n3. Terminal: 在sublime中打开终端并定位到当前目录\n\n4. react-native-snippets: react native的代码片段\n\n   ​\n\n#### 测试安装\n\n```shell\nreact-native init ReactNativeDemo\ncd ReactNativeDemo\nreact-native run-ios\n```\n\n在测试过程中遇到一个问题导致编译失败，报错的原因是Watchman没有安装，于是我又尝试用Homebrew安装Watchman，结果在快要完成的时候报错了，报错的原因是未正确安装Command Line Tools,执行`xcode-select --install`，安装完成后再次安装Watchman，并运行通过。\n\n### 参考文章\n\n[ReactNative搭建开发环境](http://reactnative.cn/docs/0.36/getting-started.html#content)\n\n[用Sublime 3作为ReactNative的开发IDE](http://www.jianshu.com/p/2ddfff095e90)\n\n","slug":"ReactNative入门","published":1,"updated":"2018-08-31T09:53:49.237Z","_id":"cjlhoqwht000lkj79h7ui4jj4","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h4 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h4><p><a href=\"http://brew.sh/\" target=\"_blank\" rel=\"external\">Homebrew</a>是Mac系统的包管理器，我们要使用它安装NodeJS和一些其他必须的工具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"Node-JS\"><a href=\"#Node-JS\" class=\"headerlink\" title=\"Node.JS\"></a>Node.JS</h4><p>使用Homebrew安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install node</div></pre></td></tr></table></figure>\n<p>安装完成后最好设置npm镜像以加速安装过程</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org --global</div><div class=\"line\">npm config <span class=\"built_in\">set</span> disturl https://npm.taobao.org/dist --global</div></pre></td></tr></table></figure>\n<h4 id=\"React-Native的命令行工具-react-native-cli\"><a href=\"#React-Native的命令行工具-react-native-cli\" class=\"headerlink\" title=\"React Native的命令行工具(react-native-cli)\"></a>React Native的命令行工具(react-native-cli)</h4><p>React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务等任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g react-native-cli</div></pre></td></tr></table></figure>\n<h4 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h4><p>React Native目前需要Xcode 7.0或更高版本。</p>\n<h3 id=\"推荐安装的工具\"><a href=\"#推荐安装的工具\" class=\"headerlink\" title=\"推荐安装的工具\"></a>推荐安装的工具</h3><h4 id=\"Watchman\"><a href=\"#Watchman\" class=\"headerlink\" title=\"Watchman\"></a>Watchman</h4><p><a href=\"https://facebook.github.io/watchman/docs/install.html\" target=\"_blank\" rel=\"external\">Watchman</a>是由Facebook提供的监视文件系统变更的工具。安装此工具可以提供开发时的性能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install watchman</div></pre></td></tr></table></figure>\n<h4 id=\"Flow\"><a href=\"#Flow\" class=\"headerlink\" title=\"Flow\"></a>Flow</h4><p><a href=\"https://www.flowtype.org/\" target=\"_blank\" rel=\"external\">Flow</a>是一个静态的JS类型检查工具。(新手建议跳过，降低学习成本)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install flow</div></pre></td></tr></table></figure>\n<h4 id=\"Sublime-Text-3\"><a href=\"#Sublime-Text-3\" class=\"headerlink\" title=\"Sublime Text 3\"></a>Sublime Text 3</h4><p><a href=\"http://www.sublimetext.com\" target=\"_blank\" rel=\"external\">Sublime</a>是一款开源的编辑器，支持插件安装。</p>\n<h5 id=\"React-Native开发推荐的一些插件\"><a href=\"#React-Native开发推荐的一些插件\" class=\"headerlink\" title=\"React Native开发推荐的一些插件\"></a>React Native开发推荐的一些插件</h5><ol>\n<li><p>ReactJS: 支持React开发，代码提示，高亮显示</p>\n</li>\n<li><p>Emmet: 前端开发必备</p>\n</li>\n<li><p>Terminal: 在sublime中打开终端并定位到当前目录</p>\n</li>\n<li><p>react-native-snippets: react native的代码片段</p>\n<p>​</p>\n</li>\n</ol>\n<h4 id=\"测试安装\"><a href=\"#测试安装\" class=\"headerlink\" title=\"测试安装\"></a>测试安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init ReactNativeDemo</div><div class=\"line\">cd ReactNativeDemo</div><div class=\"line\">react-native run-ios</div></pre></td></tr></table></figure>\n<p>在测试过程中遇到一个问题导致编译失败，报错的原因是Watchman没有安装，于是我又尝试用Homebrew安装Watchman，结果在快要完成的时候报错了，报错的原因是未正确安装Command Line Tools,执行<code>xcode-select --install</code>，安装完成后再次安装Watchman，并运行通过。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://reactnative.cn/docs/0.36/getting-started.html#content\" target=\"_blank\" rel=\"external\">ReactNative搭建开发环境</a></p>\n<p><a href=\"http://www.jianshu.com/p/2ddfff095e90\" target=\"_blank\" rel=\"external\">用Sublime 3作为ReactNative的开发IDE</a></p>\n","excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h4 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h4><p><a href=\"http://brew.sh/\">Homebrew</a>是Mac系统的包管理器，我们要使用它安装NodeJS和一些其他必须的工具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"Node-JS\"><a href=\"#Node-JS\" class=\"headerlink\" title=\"Node.JS\"></a>Node.JS</h4><p>使用Homebrew安装<a href=\"https://nodejs.org/en/\">Node.js</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install node</div></pre></td></tr></table></figure>\n<p>安装完成后最好设置npm镜像以加速安装过程</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org --global</div><div class=\"line\">npm config <span class=\"built_in\">set</span> disturl https://npm.taobao.org/dist --global</div></pre></td></tr></table></figure>\n<h4 id=\"React-Native的命令行工具-react-native-cli\"><a href=\"#React-Native的命令行工具-react-native-cli\" class=\"headerlink\" title=\"React Native的命令行工具(react-native-cli)\"></a>React Native的命令行工具(react-native-cli)</h4><p>React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务等任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g react-native-cli</div></pre></td></tr></table></figure>\n<h4 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h4><p>React Native目前需要Xcode 7.0或更高版本。</p>\n<h3 id=\"推荐安装的工具\"><a href=\"#推荐安装的工具\" class=\"headerlink\" title=\"推荐安装的工具\"></a>推荐安装的工具</h3><h4 id=\"Watchman\"><a href=\"#Watchman\" class=\"headerlink\" title=\"Watchman\"></a>Watchman</h4><p><a href=\"https://facebook.github.io/watchman/docs/install.html\">Watchman</a>是由Facebook提供的监视文件系统变更的工具。安装此工具可以提供开发时的性能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install watchman</div></pre></td></tr></table></figure>\n<h4 id=\"Flow\"><a href=\"#Flow\" class=\"headerlink\" title=\"Flow\"></a>Flow</h4><p><a href=\"https://www.flowtype.org/\">Flow</a>是一个静态的JS类型检查工具。(新手建议跳过，降低学习成本)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install flow</div></pre></td></tr></table></figure>\n<h4 id=\"Sublime-Text-3\"><a href=\"#Sublime-Text-3\" class=\"headerlink\" title=\"Sublime Text 3\"></a>Sublime Text 3</h4><p><a href=\"http://www.sublimetext.com\">Sublime</a>是一款开源的编辑器，支持插件安装。</p>\n<h5 id=\"React-Native开发推荐的一些插件\"><a href=\"#React-Native开发推荐的一些插件\" class=\"headerlink\" title=\"React Native开发推荐的一些插件\"></a>React Native开发推荐的一些插件</h5><ol>\n<li><p>ReactJS: 支持React开发，代码提示，高亮显示</p>\n</li>\n<li><p>Emmet: 前端开发必备</p>\n</li>\n<li><p>Terminal: 在sublime中打开终端并定位到当前目录</p>\n</li>\n<li><p>react-native-snippets: react native的代码片段</p>\n<p>​</p>\n</li>\n</ol>\n<h4 id=\"测试安装\"><a href=\"#测试安装\" class=\"headerlink\" title=\"测试安装\"></a>测试安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init ReactNativeDemo</div><div class=\"line\">cd ReactNativeDemo</div><div class=\"line\">react-native run-ios</div></pre></td></tr></table></figure>\n<p>在测试过程中遇到一个问题导致编译失败，报错的原因是Watchman没有安装，于是我又尝试用Homebrew安装Watchman，结果在快要完成的时候报错了，报错的原因是未正确安装Command Line Tools,执行<code>xcode-select --install</code>，安装完成后再次安装Watchman，并运行通过。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://reactnative.cn/docs/0.36/getting-started.html#content\">ReactNative搭建开发环境</a></p>\n<p><a href=\"http://www.jianshu.com/p/2ddfff095e90\">用Sublime 3作为ReactNative的开发IDE</a></p>\n"},{"title":"PHP与iOS之间的AES加解密","date":"2017-03-06T10:12:00.000Z","_content":"\n## 前言\n在项目开发过程中，为了保证传输数据的安全性，我们经常要对传输的内容进行加密处理，以增加别人破解的成本。常用的加密算法有很多，今天我们先围绕`AES`加密算法进行一个使用总结\n\n### AES算法介绍\n`AES`是高级加密标准(Advanced Encryption Standard)的缩写，在密码学中又被称为Rijndael加密法，如果想对`AES`的背景有更多的了解可以移步到[维基百科-高级加密标准](https://zh.wikipedia.org/wiki/高级加密标准)\n\n`AES`加密时需要统一四个参数：\n- 密钥长度 (Key Size)\n- 加密模式 (Cipher Mode)\n- 填充方式 (Padding)\n- 初始向量 (Initialization Vector)\n\n由于前后端开发所使用的语言不统一，导致经常出现前后端之间互相不能解密的情况出现，其实，无论什么语言系统，`AES`的算法总是相同的，导致结果不一致的原因在于**上述的四个参数不一致**，下面就来了解一下这四个参数的含义\n\n#### 密钥长度\n`AES`算法下，key的长度有三种：128、192、256 bits，三种不同密钥长度就需要我们传入的key传入不同长度的字符串，例如我们选择AES-128,那我们定的key需要是长度为16的字符串\n\n#### 加密模式\n`AES`属于块加密，块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式，为了保持前后端统一，我们选择ECB模式\n\n#### 填充方式\n由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充\n\n#### 初始向量\n使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等\n\n## 代码实现\n### PHP端代码实现\n```\n<?php\n/*\n * 定义类cryptAES 专用于AES加解密\n * 初始化时传入密钥长度、加密Key、初始向量、加密模式四个字段\n */\nclass cryptAES\n{\n    public $iv = null;\n    public $key = null;\n    public $bit = 128;\n    private $cipher;\n\n    public function __construct($bit, $key, $iv, $mode)\n    {\n        if(empty($bit) || empty($key) || empty($iv) || empty($mode))\n        {\n            return NULL;\n        }\n\n        $this->bit = $bit;\n        $this->key = $key;\n        $this->iv = $iv;\n        $this->mode = $mode;\n\n        switch($this->bit)\n        {\n            case 192 : $this->cipher = MCRYPT_RIJNDAEL_192; break;\n            case 256 : $this->cipher = MCRYPT_RIJNDAEL_256; break;\n            default : $this->cipher = MCRYPT_RIJNDAEL_128;\n        }\n        switch($this->mode)\n        {\n            case 'ecb' : $this->mode = MCRYPT_MODE_ECB; break;\n            case 'cfb' : $this->mode = MCRYPT_MODE_CFB; break;\n            case 'ofb' : $this->mode = MCRYPT_MODE_OFB; break;\n            case 'nofb' : $this->mode = MCRYPT_MODE_NOFB; break;\n            default : $this->mode = MCRYPT_MODE_CBC;\n        }\n    }\n\n        /*\n         * 加密数据并返回\n         */\n    public function encrypt($data)\n    {\n        $data = base64_encode(mcrypt_encrypt($this->cipher, $this->key, $data, $this->mode, $this->iv));\n        return $data;\n    }\n\n        /*\n         * 解密数据并返回\n         */\n    public function decrypt($data)\n    {\n        $data = mcrypt_decrypt($this->cipher, $this->key, base64_decode($data), $this->mode, $this->iv);\n        $data = rtrim(rtrim($data), \"\\x00..\\x1F\");\n        return $data;\n    }\n}\n```\n\n### iOS端代码实现\n```\n// NSString+AESSecurity.h\n@interface NSString (AESSecurity)\n\n+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key;\n\n+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key;\n\n@end\n\n// NSString+AESSecurity.m\n#import \"NSString+AESSecurity.h\"\n\n#import <CommonCrypto/CommonCrypto.h>\n\n// 初始向量\nNSString *const kInitVector = @\"0123456789\";\n\n// 密钥长度\nsize_t const kKeySize = kCCKeySizeAES128;\n\n@implementation NSString (AESSecurity)\n\n+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key {\n    \n    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];\n    NSUInteger dataLength = contentData.length;\n    \n    // 为结束符'\\\\0' +1\n    char keyPtr[kKeySize + 1];\n    memset(keyPtr, 0, sizeof(keyPtr));\n    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];\n    \n    size_t encryptSize = dataLength + kCCBlockSizeAES128;\n    void *encryptedBytes = malloc(encryptSize);\n    size_t actualOutSize = 0;\n    \n    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];\n    \n    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,\n                                          kCCAlgorithmAES128,\n                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式\n                                          keyPtr,\n                                          kKeySize,\n                                          initVector.bytes,\n                                          contentData.bytes,\n                                          dataLength,\n                                          encryptedBytes,\n                                          encryptSize,\n                                          &actualOutSize);\n    \n    if (cryptStatus == kCCSuccess) {\n        // 对加密后的数据进行 base64 编码\n        return [[NSData dataWithBytesNoCopy:encryptedBytes length:actualOutSize] base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];\n    }\n    free(encryptedBytes);\n    return nil;\n}\n\n+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key {//\n    // 把 base64 String 转换成 NSData\n    NSData *contentData = [[NSData alloc] initWithBase64EncodedString:content options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    NSUInteger dataLength = contentData.length;\n    \n    char keyPtr[kKeySize + 1];\n    memset(keyPtr, 0, sizeof(keyPtr));\n    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];\n    \n    size_t decryptSize = dataLength + kCCBlockSizeAES128;\n    void *decryptedBytes = malloc(decryptSize);\n    size_t actualOutSize = 0;\n    \n    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];\n    \n    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,\n                                          kCCAlgorithmAES,\n                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式\n                                          keyPtr,\n                                          kKeySize,\n                                          initVector.bytes,\n                                          contentData.bytes,\n                                          dataLength,\n                                          decryptedBytes,\n                                          decryptSize,\n                                          &actualOutSize);\n    \n    if (cryptStatus == kCCSuccess) {\n        return [[NSString alloc] initWithData:[NSData dataWithBytesNoCopy:decryptedBytes length:actualOutSize] encoding:NSUTF8StringEncoding];\n    }\n    \n    free(decryptedBytes);\n    return nil;\n}\n\n@end\n\n```\n\n### 注意点\n\n在iOS上，字符串经过加解密后可能会在数据中添加一些[操作符](http://baike.baidu.com/view/1112575.htm)这会导致我们想进一步处理解密后的字符串时会处理失败，例如，当我们想将解密后的json字符串转成字典时，可能会抛出`Garbage at End`的错误，解决方案如下：\n\n1. 将字符串中的所有控制符替换成空字符\n```\nNSString *newStr = [oldStr stringByTrimmingCharactersInSet:[NSCharacterSet controlCharacterSet]];\n```\n2. 将处理后的字符串进行json序列化操作\n```\nNSError *err = nil;\n            \nNSData *jsondata = [str dataUsingEncoding:NSUTF8StringEncoding];\n            \nNSArray *arr = [NSJSONSerialization JSONObjectWithData:jsondata options:NSJSONReadingMutableLeaves error:&err];\n```\n---\n附上相关模块的代码\n\n[AESSecurity-PHP](https://github.com/luzhiyongGit/AESSecurity-PHP)\n\n[AESSecurity-iOS](https://github.com/luzhiyongGit/AESSecurity-iOS)\n\n欢迎star和fork~\n\n\n","source":"_posts/PHP与iOS之间的AES加解密.md","raw":"title: PHP与iOS之间的AES加解密\ntags:\n  - iOS基础\n  - ''\n  - ''\n  - 加密\ncategories:\n  - iOS\n  - PHP\n  - ''\ndate: 2017-03-06 18:12:00\n---\n\n## 前言\n在项目开发过程中，为了保证传输数据的安全性，我们经常要对传输的内容进行加密处理，以增加别人破解的成本。常用的加密算法有很多，今天我们先围绕`AES`加密算法进行一个使用总结\n\n### AES算法介绍\n`AES`是高级加密标准(Advanced Encryption Standard)的缩写，在密码学中又被称为Rijndael加密法，如果想对`AES`的背景有更多的了解可以移步到[维基百科-高级加密标准](https://zh.wikipedia.org/wiki/高级加密标准)\n\n`AES`加密时需要统一四个参数：\n- 密钥长度 (Key Size)\n- 加密模式 (Cipher Mode)\n- 填充方式 (Padding)\n- 初始向量 (Initialization Vector)\n\n由于前后端开发所使用的语言不统一，导致经常出现前后端之间互相不能解密的情况出现，其实，无论什么语言系统，`AES`的算法总是相同的，导致结果不一致的原因在于**上述的四个参数不一致**，下面就来了解一下这四个参数的含义\n\n#### 密钥长度\n`AES`算法下，key的长度有三种：128、192、256 bits，三种不同密钥长度就需要我们传入的key传入不同长度的字符串，例如我们选择AES-128,那我们定的key需要是长度为16的字符串\n\n#### 加密模式\n`AES`属于块加密，块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式，为了保持前后端统一，我们选择ECB模式\n\n#### 填充方式\n由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充\n\n#### 初始向量\n使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等\n\n## 代码实现\n### PHP端代码实现\n```\n<?php\n/*\n * 定义类cryptAES 专用于AES加解密\n * 初始化时传入密钥长度、加密Key、初始向量、加密模式四个字段\n */\nclass cryptAES\n{\n    public $iv = null;\n    public $key = null;\n    public $bit = 128;\n    private $cipher;\n\n    public function __construct($bit, $key, $iv, $mode)\n    {\n        if(empty($bit) || empty($key) || empty($iv) || empty($mode))\n        {\n            return NULL;\n        }\n\n        $this->bit = $bit;\n        $this->key = $key;\n        $this->iv = $iv;\n        $this->mode = $mode;\n\n        switch($this->bit)\n        {\n            case 192 : $this->cipher = MCRYPT_RIJNDAEL_192; break;\n            case 256 : $this->cipher = MCRYPT_RIJNDAEL_256; break;\n            default : $this->cipher = MCRYPT_RIJNDAEL_128;\n        }\n        switch($this->mode)\n        {\n            case 'ecb' : $this->mode = MCRYPT_MODE_ECB; break;\n            case 'cfb' : $this->mode = MCRYPT_MODE_CFB; break;\n            case 'ofb' : $this->mode = MCRYPT_MODE_OFB; break;\n            case 'nofb' : $this->mode = MCRYPT_MODE_NOFB; break;\n            default : $this->mode = MCRYPT_MODE_CBC;\n        }\n    }\n\n        /*\n         * 加密数据并返回\n         */\n    public function encrypt($data)\n    {\n        $data = base64_encode(mcrypt_encrypt($this->cipher, $this->key, $data, $this->mode, $this->iv));\n        return $data;\n    }\n\n        /*\n         * 解密数据并返回\n         */\n    public function decrypt($data)\n    {\n        $data = mcrypt_decrypt($this->cipher, $this->key, base64_decode($data), $this->mode, $this->iv);\n        $data = rtrim(rtrim($data), \"\\x00..\\x1F\");\n        return $data;\n    }\n}\n```\n\n### iOS端代码实现\n```\n// NSString+AESSecurity.h\n@interface NSString (AESSecurity)\n\n+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key;\n\n+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key;\n\n@end\n\n// NSString+AESSecurity.m\n#import \"NSString+AESSecurity.h\"\n\n#import <CommonCrypto/CommonCrypto.h>\n\n// 初始向量\nNSString *const kInitVector = @\"0123456789\";\n\n// 密钥长度\nsize_t const kKeySize = kCCKeySizeAES128;\n\n@implementation NSString (AESSecurity)\n\n+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key {\n    \n    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];\n    NSUInteger dataLength = contentData.length;\n    \n    // 为结束符'\\\\0' +1\n    char keyPtr[kKeySize + 1];\n    memset(keyPtr, 0, sizeof(keyPtr));\n    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];\n    \n    size_t encryptSize = dataLength + kCCBlockSizeAES128;\n    void *encryptedBytes = malloc(encryptSize);\n    size_t actualOutSize = 0;\n    \n    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];\n    \n    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,\n                                          kCCAlgorithmAES128,\n                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式\n                                          keyPtr,\n                                          kKeySize,\n                                          initVector.bytes,\n                                          contentData.bytes,\n                                          dataLength,\n                                          encryptedBytes,\n                                          encryptSize,\n                                          &actualOutSize);\n    \n    if (cryptStatus == kCCSuccess) {\n        // 对加密后的数据进行 base64 编码\n        return [[NSData dataWithBytesNoCopy:encryptedBytes length:actualOutSize] base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];\n    }\n    free(encryptedBytes);\n    return nil;\n}\n\n+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key {//\n    // 把 base64 String 转换成 NSData\n    NSData *contentData = [[NSData alloc] initWithBase64EncodedString:content options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    NSUInteger dataLength = contentData.length;\n    \n    char keyPtr[kKeySize + 1];\n    memset(keyPtr, 0, sizeof(keyPtr));\n    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];\n    \n    size_t decryptSize = dataLength + kCCBlockSizeAES128;\n    void *decryptedBytes = malloc(decryptSize);\n    size_t actualOutSize = 0;\n    \n    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];\n    \n    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,\n                                          kCCAlgorithmAES,\n                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式\n                                          keyPtr,\n                                          kKeySize,\n                                          initVector.bytes,\n                                          contentData.bytes,\n                                          dataLength,\n                                          decryptedBytes,\n                                          decryptSize,\n                                          &actualOutSize);\n    \n    if (cryptStatus == kCCSuccess) {\n        return [[NSString alloc] initWithData:[NSData dataWithBytesNoCopy:decryptedBytes length:actualOutSize] encoding:NSUTF8StringEncoding];\n    }\n    \n    free(decryptedBytes);\n    return nil;\n}\n\n@end\n\n```\n\n### 注意点\n\n在iOS上，字符串经过加解密后可能会在数据中添加一些[操作符](http://baike.baidu.com/view/1112575.htm)这会导致我们想进一步处理解密后的字符串时会处理失败，例如，当我们想将解密后的json字符串转成字典时，可能会抛出`Garbage at End`的错误，解决方案如下：\n\n1. 将字符串中的所有控制符替换成空字符\n```\nNSString *newStr = [oldStr stringByTrimmingCharactersInSet:[NSCharacterSet controlCharacterSet]];\n```\n2. 将处理后的字符串进行json序列化操作\n```\nNSError *err = nil;\n            \nNSData *jsondata = [str dataUsingEncoding:NSUTF8StringEncoding];\n            \nNSArray *arr = [NSJSONSerialization JSONObjectWithData:jsondata options:NSJSONReadingMutableLeaves error:&err];\n```\n---\n附上相关模块的代码\n\n[AESSecurity-PHP](https://github.com/luzhiyongGit/AESSecurity-PHP)\n\n[AESSecurity-iOS](https://github.com/luzhiyongGit/AESSecurity-iOS)\n\n欢迎star和fork~\n\n\n","slug":"PHP与iOS之间的AES加解密","published":1,"updated":"2018-08-31T09:46:29.116Z","_id":"cjlhoqwhv000qkj79n7ztt8u1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目开发过程中，为了保证传输数据的安全性，我们经常要对传输的内容进行加密处理，以增加别人破解的成本。常用的加密算法有很多，今天我们先围绕<code>AES</code>加密算法进行一个使用总结</p>\n<h3 id=\"AES算法介绍\"><a href=\"#AES算法介绍\" class=\"headerlink\" title=\"AES算法介绍\"></a>AES算法介绍</h3><p><code>AES</code>是高级加密标准(Advanced Encryption Standard)的缩写，在密码学中又被称为Rijndael加密法，如果想对<code>AES</code>的背景有更多的了解可以移步到<a href=\"https://zh.wikipedia.org/wiki/高级加密标准\" target=\"_blank\" rel=\"external\">维基百科-高级加密标准</a></p>\n<p><code>AES</code>加密时需要统一四个参数：</p>\n<ul>\n<li>密钥长度 (Key Size)</li>\n<li>加密模式 (Cipher Mode)</li>\n<li>填充方式 (Padding)</li>\n<li>初始向量 (Initialization Vector)</li>\n</ul>\n<p>由于前后端开发所使用的语言不统一，导致经常出现前后端之间互相不能解密的情况出现，其实，无论什么语言系统，<code>AES</code>的算法总是相同的，导致结果不一致的原因在于<strong>上述的四个参数不一致</strong>，下面就来了解一下这四个参数的含义</p>\n<h4 id=\"密钥长度\"><a href=\"#密钥长度\" class=\"headerlink\" title=\"密钥长度\"></a>密钥长度</h4><p><code>AES</code>算法下，key的长度有三种：128、192、256 bits，三种不同密钥长度就需要我们传入的key传入不同长度的字符串，例如我们选择AES-128,那我们定的key需要是长度为16的字符串</p>\n<h4 id=\"加密模式\"><a href=\"#加密模式\" class=\"headerlink\" title=\"加密模式\"></a>加密模式</h4><p><code>AES</code>属于块加密，块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式，为了保持前后端统一，我们选择ECB模式</p>\n<h4 id=\"填充方式\"><a href=\"#填充方式\" class=\"headerlink\" title=\"填充方式\"></a>填充方式</h4><p>由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充</p>\n<h4 id=\"初始向量\"><a href=\"#初始向量\" class=\"headerlink\" title=\"初始向量\"></a>初始向量</h4><p>使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"PHP端代码实现\"><a href=\"#PHP端代码实现\" class=\"headerlink\" title=\"PHP端代码实现\"></a>PHP端代码实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">/*</div><div class=\"line\"> * 定义类cryptAES 专用于AES加解密</div><div class=\"line\"> * 初始化时传入密钥长度、加密Key、初始向量、加密模式四个字段</div><div class=\"line\"> */</div><div class=\"line\">class cryptAES</div><div class=\"line\">&#123;</div><div class=\"line\">    public $iv = null;</div><div class=\"line\">    public $key = null;</div><div class=\"line\">    public $bit = 128;</div><div class=\"line\">    private $cipher;</div><div class=\"line\"></div><div class=\"line\">    public function __construct($bit, $key, $iv, $mode)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if(empty($bit) || empty($key) || empty($iv) || empty($mode))</div><div class=\"line\">        &#123;</div><div class=\"line\">            return NULL;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        $this-&gt;bit = $bit;</div><div class=\"line\">        $this-&gt;key = $key;</div><div class=\"line\">        $this-&gt;iv = $iv;</div><div class=\"line\">        $this-&gt;mode = $mode;</div><div class=\"line\"></div><div class=\"line\">        switch($this-&gt;bit)</div><div class=\"line\">        &#123;</div><div class=\"line\">            case 192 : $this-&gt;cipher = MCRYPT_RIJNDAEL_192; break;</div><div class=\"line\">            case 256 : $this-&gt;cipher = MCRYPT_RIJNDAEL_256; break;</div><div class=\"line\">            default : $this-&gt;cipher = MCRYPT_RIJNDAEL_128;</div><div class=\"line\">        &#125;</div><div class=\"line\">        switch($this-&gt;mode)</div><div class=\"line\">        &#123;</div><div class=\"line\">            case &apos;ecb&apos; : $this-&gt;mode = MCRYPT_MODE_ECB; break;</div><div class=\"line\">            case &apos;cfb&apos; : $this-&gt;mode = MCRYPT_MODE_CFB; break;</div><div class=\"line\">            case &apos;ofb&apos; : $this-&gt;mode = MCRYPT_MODE_OFB; break;</div><div class=\"line\">            case &apos;nofb&apos; : $this-&gt;mode = MCRYPT_MODE_NOFB; break;</div><div class=\"line\">            default : $this-&gt;mode = MCRYPT_MODE_CBC;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * 加密数据并返回</div><div class=\"line\">         */</div><div class=\"line\">    public function encrypt($data)</div><div class=\"line\">    &#123;</div><div class=\"line\">        $data = base64_encode(mcrypt_encrypt($this-&gt;cipher, $this-&gt;key, $data, $this-&gt;mode, $this-&gt;iv));</div><div class=\"line\">        return $data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * 解密数据并返回</div><div class=\"line\">         */</div><div class=\"line\">    public function decrypt($data)</div><div class=\"line\">    &#123;</div><div class=\"line\">        $data = mcrypt_decrypt($this-&gt;cipher, $this-&gt;key, base64_decode($data), $this-&gt;mode, $this-&gt;iv);</div><div class=\"line\">        $data = rtrim(rtrim($data), &quot;\\x00..\\x1F&quot;);</div><div class=\"line\">        return $data;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"iOS端代码实现\"><a href=\"#iOS端代码实现\" class=\"headerlink\" title=\"iOS端代码实现\"></a>iOS端代码实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\">// NSString+AESSecurity.h</div><div class=\"line\">@interface NSString (AESSecurity)</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">// NSString+AESSecurity.m</div><div class=\"line\">#import &quot;NSString+AESSecurity.h&quot;</div><div class=\"line\"></div><div class=\"line\">#import &lt;CommonCrypto/CommonCrypto.h&gt;</div><div class=\"line\"></div><div class=\"line\">// 初始向量</div><div class=\"line\">NSString *const kInitVector = @&quot;0123456789&quot;;</div><div class=\"line\"></div><div class=\"line\">// 密钥长度</div><div class=\"line\">size_t const kKeySize = kCCKeySizeAES128;</div><div class=\"line\"></div><div class=\"line\">@implementation NSString (AESSecurity)</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key &#123;</div><div class=\"line\">    </div><div class=\"line\">    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">    NSUInteger dataLength = contentData.length;</div><div class=\"line\">    </div><div class=\"line\">    // 为结束符&apos;\\\\0&apos; +1</div><div class=\"line\">    char keyPtr[kKeySize + 1];</div><div class=\"line\">    memset(keyPtr, 0, sizeof(keyPtr));</div><div class=\"line\">    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    size_t encryptSize = dataLength + kCCBlockSizeAES128;</div><div class=\"line\">    void *encryptedBytes = malloc(encryptSize);</div><div class=\"line\">    size_t actualOutSize = 0;</div><div class=\"line\">    </div><div class=\"line\">    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</div><div class=\"line\">                                          kCCAlgorithmAES128,</div><div class=\"line\">                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式</div><div class=\"line\">                                          keyPtr,</div><div class=\"line\">                                          kKeySize,</div><div class=\"line\">                                          initVector.bytes,</div><div class=\"line\">                                          contentData.bytes,</div><div class=\"line\">                                          dataLength,</div><div class=\"line\">                                          encryptedBytes,</div><div class=\"line\">                                          encryptSize,</div><div class=\"line\">                                          &amp;actualOutSize);</div><div class=\"line\">    </div><div class=\"line\">    if (cryptStatus == kCCSuccess) &#123;</div><div class=\"line\">        // 对加密后的数据进行 base64 编码</div><div class=\"line\">        return [[NSData dataWithBytesNoCopy:encryptedBytes length:actualOutSize] base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(encryptedBytes);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key &#123;//</div><div class=\"line\">    // 把 base64 String 转换成 NSData</div><div class=\"line\">    NSData *contentData = [[NSData alloc] initWithBase64EncodedString:content options:NSDataBase64DecodingIgnoreUnknownCharacters];</div><div class=\"line\">    NSUInteger dataLength = contentData.length;</div><div class=\"line\">    </div><div class=\"line\">    char keyPtr[kKeySize + 1];</div><div class=\"line\">    memset(keyPtr, 0, sizeof(keyPtr));</div><div class=\"line\">    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    size_t decryptSize = dataLength + kCCBlockSizeAES128;</div><div class=\"line\">    void *decryptedBytes = malloc(decryptSize);</div><div class=\"line\">    size_t actualOutSize = 0;</div><div class=\"line\">    </div><div class=\"line\">    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</div><div class=\"line\">                                          kCCAlgorithmAES,</div><div class=\"line\">                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式</div><div class=\"line\">                                          keyPtr,</div><div class=\"line\">                                          kKeySize,</div><div class=\"line\">                                          initVector.bytes,</div><div class=\"line\">                                          contentData.bytes,</div><div class=\"line\">                                          dataLength,</div><div class=\"line\">                                          decryptedBytes,</div><div class=\"line\">                                          decryptSize,</div><div class=\"line\">                                          &amp;actualOutSize);</div><div class=\"line\">    </div><div class=\"line\">    if (cryptStatus == kCCSuccess) &#123;</div><div class=\"line\">        return [[NSString alloc] initWithData:[NSData dataWithBytesNoCopy:decryptedBytes length:actualOutSize] encoding:NSUTF8StringEncoding];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    free(decryptedBytes);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>在iOS上，字符串经过加解密后可能会在数据中添加一些<a href=\"http://baike.baidu.com/view/1112575.htm\" target=\"_blank\" rel=\"external\">操作符</a>这会导致我们想进一步处理解密后的字符串时会处理失败，例如，当我们想将解密后的json字符串转成字典时，可能会抛出<code>Garbage at End</code>的错误，解决方案如下：</p>\n<ol>\n<li><p>将字符串中的所有控制符替换成空字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *newStr = [oldStr stringByTrimmingCharactersInSet:[NSCharacterSet controlCharacterSet]];</div></pre></td></tr></table></figure>\n</li>\n<li><p>将处理后的字符串进行json序列化操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSError *err = nil;</div><div class=\"line\">            </div><div class=\"line\">NSData *jsondata = [str dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">            </div><div class=\"line\">NSArray *arr = [NSJSONSerialization JSONObjectWithData:jsondata options:NSJSONReadingMutableLeaves error:&amp;err];</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p>附上相关模块的代码</p>\n<p><a href=\"https://github.com/luzhiyongGit/AESSecurity-PHP\" target=\"_blank\" rel=\"external\">AESSecurity-PHP</a></p>\n<p><a href=\"https://github.com/luzhiyongGit/AESSecurity-iOS\" target=\"_blank\" rel=\"external\">AESSecurity-iOS</a></p>\n<p>欢迎star和fork~</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目开发过程中，为了保证传输数据的安全性，我们经常要对传输的内容进行加密处理，以增加别人破解的成本。常用的加密算法有很多，今天我们先围绕<code>AES</code>加密算法进行一个使用总结</p>\n<h3 id=\"AES算法介绍\"><a href=\"#AES算法介绍\" class=\"headerlink\" title=\"AES算法介绍\"></a>AES算法介绍</h3><p><code>AES</code>是高级加密标准(Advanced Encryption Standard)的缩写，在密码学中又被称为Rijndael加密法，如果想对<code>AES</code>的背景有更多的了解可以移步到<a href=\"https://zh.wikipedia.org/wiki/高级加密标准\">维基百科-高级加密标准</a></p>\n<p><code>AES</code>加密时需要统一四个参数：</p>\n<ul>\n<li>密钥长度 (Key Size)</li>\n<li>加密模式 (Cipher Mode)</li>\n<li>填充方式 (Padding)</li>\n<li>初始向量 (Initialization Vector)</li>\n</ul>\n<p>由于前后端开发所使用的语言不统一，导致经常出现前后端之间互相不能解密的情况出现，其实，无论什么语言系统，<code>AES</code>的算法总是相同的，导致结果不一致的原因在于<strong>上述的四个参数不一致</strong>，下面就来了解一下这四个参数的含义</p>\n<h4 id=\"密钥长度\"><a href=\"#密钥长度\" class=\"headerlink\" title=\"密钥长度\"></a>密钥长度</h4><p><code>AES</code>算法下，key的长度有三种：128、192、256 bits，三种不同密钥长度就需要我们传入的key传入不同长度的字符串，例如我们选择AES-128,那我们定的key需要是长度为16的字符串</p>\n<h4 id=\"加密模式\"><a href=\"#加密模式\" class=\"headerlink\" title=\"加密模式\"></a>加密模式</h4><p><code>AES</code>属于块加密，块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式，为了保持前后端统一，我们选择ECB模式</p>\n<h4 id=\"填充方式\"><a href=\"#填充方式\" class=\"headerlink\" title=\"填充方式\"></a>填充方式</h4><p>由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充</p>\n<h4 id=\"初始向量\"><a href=\"#初始向量\" class=\"headerlink\" title=\"初始向量\"></a>初始向量</h4><p>使用除ECB以外的其他加密模式均需要传入一个初始向量，其大小与Block Size相等</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"PHP端代码实现\"><a href=\"#PHP端代码实现\" class=\"headerlink\" title=\"PHP端代码实现\"></a>PHP端代码实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">/*</div><div class=\"line\"> * 定义类cryptAES 专用于AES加解密</div><div class=\"line\"> * 初始化时传入密钥长度、加密Key、初始向量、加密模式四个字段</div><div class=\"line\"> */</div><div class=\"line\">class cryptAES</div><div class=\"line\">&#123;</div><div class=\"line\">    public $iv = null;</div><div class=\"line\">    public $key = null;</div><div class=\"line\">    public $bit = 128;</div><div class=\"line\">    private $cipher;</div><div class=\"line\"></div><div class=\"line\">    public function __construct($bit, $key, $iv, $mode)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if(empty($bit) || empty($key) || empty($iv) || empty($mode))</div><div class=\"line\">        &#123;</div><div class=\"line\">            return NULL;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        $this-&gt;bit = $bit;</div><div class=\"line\">        $this-&gt;key = $key;</div><div class=\"line\">        $this-&gt;iv = $iv;</div><div class=\"line\">        $this-&gt;mode = $mode;</div><div class=\"line\"></div><div class=\"line\">        switch($this-&gt;bit)</div><div class=\"line\">        &#123;</div><div class=\"line\">            case 192 : $this-&gt;cipher = MCRYPT_RIJNDAEL_192; break;</div><div class=\"line\">            case 256 : $this-&gt;cipher = MCRYPT_RIJNDAEL_256; break;</div><div class=\"line\">            default : $this-&gt;cipher = MCRYPT_RIJNDAEL_128;</div><div class=\"line\">        &#125;</div><div class=\"line\">        switch($this-&gt;mode)</div><div class=\"line\">        &#123;</div><div class=\"line\">            case &apos;ecb&apos; : $this-&gt;mode = MCRYPT_MODE_ECB; break;</div><div class=\"line\">            case &apos;cfb&apos; : $this-&gt;mode = MCRYPT_MODE_CFB; break;</div><div class=\"line\">            case &apos;ofb&apos; : $this-&gt;mode = MCRYPT_MODE_OFB; break;</div><div class=\"line\">            case &apos;nofb&apos; : $this-&gt;mode = MCRYPT_MODE_NOFB; break;</div><div class=\"line\">            default : $this-&gt;mode = MCRYPT_MODE_CBC;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * 加密数据并返回</div><div class=\"line\">         */</div><div class=\"line\">    public function encrypt($data)</div><div class=\"line\">    &#123;</div><div class=\"line\">        $data = base64_encode(mcrypt_encrypt($this-&gt;cipher, $this-&gt;key, $data, $this-&gt;mode, $this-&gt;iv));</div><div class=\"line\">        return $data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * 解密数据并返回</div><div class=\"line\">         */</div><div class=\"line\">    public function decrypt($data)</div><div class=\"line\">    &#123;</div><div class=\"line\">        $data = mcrypt_decrypt($this-&gt;cipher, $this-&gt;key, base64_decode($data), $this-&gt;mode, $this-&gt;iv);</div><div class=\"line\">        $data = rtrim(rtrim($data), &quot;\\x00..\\x1F&quot;);</div><div class=\"line\">        return $data;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"iOS端代码实现\"><a href=\"#iOS端代码实现\" class=\"headerlink\" title=\"iOS端代码实现\"></a>iOS端代码实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\">// NSString+AESSecurity.h</div><div class=\"line\">@interface NSString (AESSecurity)</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">// NSString+AESSecurity.m</div><div class=\"line\">#import &quot;NSString+AESSecurity.h&quot;</div><div class=\"line\"></div><div class=\"line\">#import &lt;CommonCrypto/CommonCrypto.h&gt;</div><div class=\"line\"></div><div class=\"line\">// 初始向量</div><div class=\"line\">NSString *const kInitVector = @&quot;0123456789&quot;;</div><div class=\"line\"></div><div class=\"line\">// 密钥长度</div><div class=\"line\">size_t const kKeySize = kCCKeySizeAES128;</div><div class=\"line\"></div><div class=\"line\">@implementation NSString (AESSecurity)</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)encrypyAES:(NSString *)content key:(NSString *)key &#123;</div><div class=\"line\">    </div><div class=\"line\">    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">    NSUInteger dataLength = contentData.length;</div><div class=\"line\">    </div><div class=\"line\">    // 为结束符&apos;\\\\0&apos; +1</div><div class=\"line\">    char keyPtr[kKeySize + 1];</div><div class=\"line\">    memset(keyPtr, 0, sizeof(keyPtr));</div><div class=\"line\">    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    size_t encryptSize = dataLength + kCCBlockSizeAES128;</div><div class=\"line\">    void *encryptedBytes = malloc(encryptSize);</div><div class=\"line\">    size_t actualOutSize = 0;</div><div class=\"line\">    </div><div class=\"line\">    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</div><div class=\"line\">                                          kCCAlgorithmAES128,</div><div class=\"line\">                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式</div><div class=\"line\">                                          keyPtr,</div><div class=\"line\">                                          kKeySize,</div><div class=\"line\">                                          initVector.bytes,</div><div class=\"line\">                                          contentData.bytes,</div><div class=\"line\">                                          dataLength,</div><div class=\"line\">                                          encryptedBytes,</div><div class=\"line\">                                          encryptSize,</div><div class=\"line\">                                          &amp;actualOutSize);</div><div class=\"line\">    </div><div class=\"line\">    if (cryptStatus == kCCSuccess) &#123;</div><div class=\"line\">        // 对加密后的数据进行 base64 编码</div><div class=\"line\">        return [[NSData dataWithBytesNoCopy:encryptedBytes length:actualOutSize] base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(encryptedBytes);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)descryptAES:(NSString *)content key:(NSString *)key &#123;//</div><div class=\"line\">    // 把 base64 String 转换成 NSData</div><div class=\"line\">    NSData *contentData = [[NSData alloc] initWithBase64EncodedString:content options:NSDataBase64DecodingIgnoreUnknownCharacters];</div><div class=\"line\">    NSUInteger dataLength = contentData.length;</div><div class=\"line\">    </div><div class=\"line\">    char keyPtr[kKeySize + 1];</div><div class=\"line\">    memset(keyPtr, 0, sizeof(keyPtr));</div><div class=\"line\">    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    size_t decryptSize = dataLength + kCCBlockSizeAES128;</div><div class=\"line\">    void *decryptedBytes = malloc(decryptSize);</div><div class=\"line\">    size_t actualOutSize = 0;</div><div class=\"line\">    </div><div class=\"line\">    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">    </div><div class=\"line\">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</div><div class=\"line\">                                          kCCAlgorithmAES,</div><div class=\"line\">                                          kCCOptionPKCS7Padding | kCCOptionECBMode, // 加密模式</div><div class=\"line\">                                          keyPtr,</div><div class=\"line\">                                          kKeySize,</div><div class=\"line\">                                          initVector.bytes,</div><div class=\"line\">                                          contentData.bytes,</div><div class=\"line\">                                          dataLength,</div><div class=\"line\">                                          decryptedBytes,</div><div class=\"line\">                                          decryptSize,</div><div class=\"line\">                                          &amp;actualOutSize);</div><div class=\"line\">    </div><div class=\"line\">    if (cryptStatus == kCCSuccess) &#123;</div><div class=\"line\">        return [[NSString alloc] initWithData:[NSData dataWithBytesNoCopy:decryptedBytes length:actualOutSize] encoding:NSUTF8StringEncoding];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    free(decryptedBytes);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>在iOS上，字符串经过加解密后可能会在数据中添加一些<a href=\"http://baike.baidu.com/view/1112575.htm\">操作符</a>这会导致我们想进一步处理解密后的字符串时会处理失败，例如，当我们想将解密后的json字符串转成字典时，可能会抛出<code>Garbage at End</code>的错误，解决方案如下：</p>\n<ol>\n<li><p>将字符串中的所有控制符替换成空字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *newStr = [oldStr stringByTrimmingCharactersInSet:[NSCharacterSet controlCharacterSet]];</div></pre></td></tr></table></figure>\n</li>\n<li><p>将处理后的字符串进行json序列化操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSError *err = nil;</div><div class=\"line\">            </div><div class=\"line\">NSData *jsondata = [str dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\">            </div><div class=\"line\">NSArray *arr = [NSJSONSerialization JSONObjectWithData:jsondata options:NSJSONReadingMutableLeaves error:&amp;err];</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p>附上相关模块的代码</p>\n<p><a href=\"https://github.com/luzhiyongGit/AESSecurity-PHP\">AESSecurity-PHP</a></p>\n<p><a href=\"https://github.com/luzhiyongGit/AESSecurity-iOS\">AESSecurity-iOS</a></p>\n<p>欢迎star和fork~</p>\n"},{"title":"UIWebView加载本地html","date":"2017-02-16T06:19:00.000Z","_content":"\nUIWebView除了能加载网页地址外还可以加载本地html，加载的方式主要有两种\n\n#### 读取本地html内容，加载内容\n```\nNSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];\nNSURL *baseURL = [NSURL URLWithString:mainBundlePath];\nNSString *htmlPath = [NSString stringWithFormat:@\"%@/index.html\", mainBundlePath];\nNSString *htmlContent = [NSString stringWithContentsOfFile:htmlPath encoding:NSUTF8StringEncoding error:nil];\n[_webView loadHTMLString:htmlString baseURL:baseURL];\n```\n#### 通过本地html地址加载内容\n```\nNSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];\nNSURL *baseURL = [NSURL URLWithString:mainBundlePath];\nNSURLRequest *request = [NSURLRequest requestWithURL:baseURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];\n[_webView loadRequest:request];\n\n```\n有些情况下，我们不仅要能加载本地html，还需要给本地html传递参数，这种情况下我们只能通过方法二来进行参数传递\n```\nNSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];\nNSURL *baseURL = [NSURL URLWithString:mainBundlePath];\nNSString *queryString = [NSString stringWithFormat:@\"%@/index.html?key=value\", mainBundlePath];\nNSURL *queryURL = [NSURL URLWithString:queryString];\nNSURLRequest *request = [NSURLRequest requestWithURL:queryURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];\n[_webView loadRequest:request];\n```\n\n","source":"_posts/UIWebView加载本地html.md","raw":"title: UIWebView加载本地html\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2017-02-16 14:19:00\n---\n\nUIWebView除了能加载网页地址外还可以加载本地html，加载的方式主要有两种\n\n#### 读取本地html内容，加载内容\n```\nNSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];\nNSURL *baseURL = [NSURL URLWithString:mainBundlePath];\nNSString *htmlPath = [NSString stringWithFormat:@\"%@/index.html\", mainBundlePath];\nNSString *htmlContent = [NSString stringWithContentsOfFile:htmlPath encoding:NSUTF8StringEncoding error:nil];\n[_webView loadHTMLString:htmlString baseURL:baseURL];\n```\n#### 通过本地html地址加载内容\n```\nNSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];\nNSURL *baseURL = [NSURL URLWithString:mainBundlePath];\nNSURLRequest *request = [NSURLRequest requestWithURL:baseURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];\n[_webView loadRequest:request];\n\n```\n有些情况下，我们不仅要能加载本地html，还需要给本地html传递参数，这种情况下我们只能通过方法二来进行参数传递\n```\nNSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];\nNSURL *baseURL = [NSURL URLWithString:mainBundlePath];\nNSString *queryString = [NSString stringWithFormat:@\"%@/index.html?key=value\", mainBundlePath];\nNSURL *queryURL = [NSURL URLWithString:queryString];\nNSURLRequest *request = [NSURLRequest requestWithURL:queryURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];\n[_webView loadRequest:request];\n```\n\n","slug":"UIWebView加载本地html","published":1,"updated":"2018-08-31T09:47:37.049Z","_id":"cjlhoqwhw000skj79wg6y0rmj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>UIWebView除了能加载网页地址外还可以加载本地html，加载的方式主要有两种</p>\n<h4 id=\"读取本地html内容，加载内容\"><a href=\"#读取本地html内容，加载内容\" class=\"headerlink\" title=\"读取本地html内容，加载内容\"></a>读取本地html内容，加载内容</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">NSURL *baseURL = [NSURL URLWithString:mainBundlePath];</div><div class=\"line\">NSString *htmlPath = [NSString stringWithFormat:@&quot;%@/index.html&quot;, mainBundlePath];</div><div class=\"line\">NSString *htmlContent = [NSString stringWithContentsOfFile:htmlPath encoding:NSUTF8StringEncoding error:nil];</div><div class=\"line\">[_webView loadHTMLString:htmlString baseURL:baseURL];</div></pre></td></tr></table></figure>\n<h4 id=\"通过本地html地址加载内容\"><a href=\"#通过本地html地址加载内容\" class=\"headerlink\" title=\"通过本地html地址加载内容\"></a>通过本地html地址加载内容</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">NSURL *baseURL = [NSURL URLWithString:mainBundlePath];</div><div class=\"line\">NSURLRequest *request = [NSURLRequest requestWithURL:baseURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];</div><div class=\"line\">[_webView loadRequest:request];</div></pre></td></tr></table></figure>\n<p>有些情况下，我们不仅要能加载本地html，还需要给本地html传递参数，这种情况下我们只能通过方法二来进行参数传递<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">NSURL *baseURL = [NSURL URLWithString:mainBundlePath];</div><div class=\"line\">NSString *queryString = [NSString stringWithFormat:@&quot;%@/index.html?key=value&quot;, mainBundlePath];</div><div class=\"line\">NSURL *queryURL = [NSURL URLWithString:queryString];</div><div class=\"line\">NSURLRequest *request = [NSURLRequest requestWithURL:queryURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];</div><div class=\"line\">[_webView loadRequest:request];</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>UIWebView除了能加载网页地址外还可以加载本地html，加载的方式主要有两种</p>\n<h4 id=\"读取本地html内容，加载内容\"><a href=\"#读取本地html内容，加载内容\" class=\"headerlink\" title=\"读取本地html内容，加载内容\"></a>读取本地html内容，加载内容</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">NSURL *baseURL = [NSURL URLWithString:mainBundlePath];</div><div class=\"line\">NSString *htmlPath = [NSString stringWithFormat:@&quot;%@/index.html&quot;, mainBundlePath];</div><div class=\"line\">NSString *htmlContent = [NSString stringWithContentsOfFile:htmlPath encoding:NSUTF8StringEncoding error:nil];</div><div class=\"line\">[_webView loadHTMLString:htmlString baseURL:baseURL];</div></pre></td></tr></table></figure>\n<h4 id=\"通过本地html地址加载内容\"><a href=\"#通过本地html地址加载内容\" class=\"headerlink\" title=\"通过本地html地址加载内容\"></a>通过本地html地址加载内容</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">NSURL *baseURL = [NSURL URLWithString:mainBundlePath];</div><div class=\"line\">NSURLRequest *request = [NSURLRequest requestWithURL:baseURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];</div><div class=\"line\">[_webView loadRequest:request];</div></pre></td></tr></table></figure>\n<p>有些情况下，我们不仅要能加载本地html，还需要给本地html传递参数，这种情况下我们只能通过方法二来进行参数传递<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *mainBundlePath = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">NSURL *baseURL = [NSURL URLWithString:mainBundlePath];</div><div class=\"line\">NSString *queryString = [NSString stringWithFormat:@&quot;%@/index.html?key=value&quot;, mainBundlePath];</div><div class=\"line\">NSURL *queryURL = [NSURL URLWithString:queryString];</div><div class=\"line\">NSURLRequest *request = [NSURLRequest requestWithURL:queryURL cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:(NSTimeInterval)10.0 ];</div><div class=\"line\">[_webView loadRequest:request];</div></pre></td></tr></table></figure></p>\n"},{"title":"SDWebImage与YYWebImage加载gif对比","date":"2017-08-16T08:53:00.000Z","_content":"\n很多应用为了丰富运营策略都需要支持gif图片，`SDWebImage`和`YYWebImage`已经为我们提供了这方面的支持，我们只需要按照对应的文档进行支持即可。但是在实际使用中发现`SDWebImage`和`YYWebImage`在性能方面存在着较大的差距，这里就给大家进行一个对比\n\n## SDWebImage加载gif\n\n`SDWebImage`将gif资源中的每一张image写入到内存中，通过`animatedImageWithImages`的方式播放动画，这样做的好处是gif轮播时直接从内存中读取资源就好，降低了CPU的使用，以空间换取流畅度，但是这也会导致当同时加载的gif数量增加时内存问题暴露的尤其明显\n\n## YYWebImage加载gif\n\n`YYWebImage`是每次从缓存中读取需要展示的image，这样就不需要为gif的每一张image都开辟空间，每次都是从一份gif资源中读取每一张image，以一定的帧率从缓冲区中解析出当前的image，这必然需要消耗CPU，所以`YYWebImage`相比较`SDWebImage`更消耗CPU，但是这也带来了内存的大幅降低\n\n## 通过Demo对比\n\n[SDWebImage和YYWebImage加载gif图片对比Demo](https://github.com/luzhiyongGit/WebImageDemo)","source":"_posts/SDWebImage与YYWebImage加载gif对比.md","raw":"title: SDWebImage与YYWebImage加载gif对比\ntags:\n  - iOS进阶\ncategories:\n  - iOS\ndate: 2017-08-16 16:53:00\n---\n\n很多应用为了丰富运营策略都需要支持gif图片，`SDWebImage`和`YYWebImage`已经为我们提供了这方面的支持，我们只需要按照对应的文档进行支持即可。但是在实际使用中发现`SDWebImage`和`YYWebImage`在性能方面存在着较大的差距，这里就给大家进行一个对比\n\n## SDWebImage加载gif\n\n`SDWebImage`将gif资源中的每一张image写入到内存中，通过`animatedImageWithImages`的方式播放动画，这样做的好处是gif轮播时直接从内存中读取资源就好，降低了CPU的使用，以空间换取流畅度，但是这也会导致当同时加载的gif数量增加时内存问题暴露的尤其明显\n\n## YYWebImage加载gif\n\n`YYWebImage`是每次从缓存中读取需要展示的image，这样就不需要为gif的每一张image都开辟空间，每次都是从一份gif资源中读取每一张image，以一定的帧率从缓冲区中解析出当前的image，这必然需要消耗CPU，所以`YYWebImage`相比较`SDWebImage`更消耗CPU，但是这也带来了内存的大幅降低\n\n## 通过Demo对比\n\n[SDWebImage和YYWebImage加载gif图片对比Demo](https://github.com/luzhiyongGit/WebImageDemo)","slug":"SDWebImage与YYWebImage加载gif对比","published":1,"updated":"2018-08-31T09:40:37.788Z","_id":"cjlhoqwhy000vkj79m85k45di","comments":1,"layout":"post","photos":[],"link":"","content":"<p>很多应用为了丰富运营策略都需要支持gif图片，<code>SDWebImage</code>和<code>YYWebImage</code>已经为我们提供了这方面的支持，我们只需要按照对应的文档进行支持即可。但是在实际使用中发现<code>SDWebImage</code>和<code>YYWebImage</code>在性能方面存在着较大的差距，这里就给大家进行一个对比</p>\n<h2 id=\"SDWebImage加载gif\"><a href=\"#SDWebImage加载gif\" class=\"headerlink\" title=\"SDWebImage加载gif\"></a>SDWebImage加载gif</h2><p><code>SDWebImage</code>将gif资源中的每一张image写入到内存中，通过<code>animatedImageWithImages</code>的方式播放动画，这样做的好处是gif轮播时直接从内存中读取资源就好，降低了CPU的使用，以空间换取流畅度，但是这也会导致当同时加载的gif数量增加时内存问题暴露的尤其明显</p>\n<h2 id=\"YYWebImage加载gif\"><a href=\"#YYWebImage加载gif\" class=\"headerlink\" title=\"YYWebImage加载gif\"></a>YYWebImage加载gif</h2><p><code>YYWebImage</code>是每次从缓存中读取需要展示的image，这样就不需要为gif的每一张image都开辟空间，每次都是从一份gif资源中读取每一张image，以一定的帧率从缓冲区中解析出当前的image，这必然需要消耗CPU，所以<code>YYWebImage</code>相比较<code>SDWebImage</code>更消耗CPU，但是这也带来了内存的大幅降低</p>\n<h2 id=\"通过Demo对比\"><a href=\"#通过Demo对比\" class=\"headerlink\" title=\"通过Demo对比\"></a>通过Demo对比</h2><p><a href=\"https://github.com/luzhiyongGit/WebImageDemo\" target=\"_blank\" rel=\"external\">SDWebImage和YYWebImage加载gif图片对比Demo</a></p>\n","excerpt":"","more":"<p>很多应用为了丰富运营策略都需要支持gif图片，<code>SDWebImage</code>和<code>YYWebImage</code>已经为我们提供了这方面的支持，我们只需要按照对应的文档进行支持即可。但是在实际使用中发现<code>SDWebImage</code>和<code>YYWebImage</code>在性能方面存在着较大的差距，这里就给大家进行一个对比</p>\n<h2 id=\"SDWebImage加载gif\"><a href=\"#SDWebImage加载gif\" class=\"headerlink\" title=\"SDWebImage加载gif\"></a>SDWebImage加载gif</h2><p><code>SDWebImage</code>将gif资源中的每一张image写入到内存中，通过<code>animatedImageWithImages</code>的方式播放动画，这样做的好处是gif轮播时直接从内存中读取资源就好，降低了CPU的使用，以空间换取流畅度，但是这也会导致当同时加载的gif数量增加时内存问题暴露的尤其明显</p>\n<h2 id=\"YYWebImage加载gif\"><a href=\"#YYWebImage加载gif\" class=\"headerlink\" title=\"YYWebImage加载gif\"></a>YYWebImage加载gif</h2><p><code>YYWebImage</code>是每次从缓存中读取需要展示的image，这样就不需要为gif的每一张image都开辟空间，每次都是从一份gif资源中读取每一张image，以一定的帧率从缓冲区中解析出当前的image，这必然需要消耗CPU，所以<code>YYWebImage</code>相比较<code>SDWebImage</code>更消耗CPU，但是这也带来了内存的大幅降低</p>\n<h2 id=\"通过Demo对比\"><a href=\"#通过Demo对比\" class=\"headerlink\" title=\"通过Demo对比\"></a>通过Demo对比</h2><p><a href=\"https://github.com/luzhiyongGit/WebImageDemo\">SDWebImage和YYWebImage加载gif图片对比Demo</a></p>\n"},{"title":"Mac搭建基于Eclipse的J2EE开发环境","date":"2017-12-14T11:21:00.000Z","_content":"虽然网上有各种Mac环境下搭建基于Eclipse的J2EE开发环境的博客，但是在实际参考中或多或少存在着一些偏差，经过一段时间的努力，总算是成功搭建完成并跑通了项目，这里做一个总结供大家参考。\n## 安装JDK\n- 打开终端输入`java -version`判断是否已安装java运行环境\n- 如果未安装则下载JDK并进行安装 [下载地址](http://www.oracle.com/technetwork/java/javaee/downloads/java-ee-sdk-7-jdk-7u21-downloads-1956231.html)\n## 安装Tomcat\n- 在[Apache官网](http://tomcat.apache.org)下载最新的tomcat二进制包\n- 将二进制包解压后改名为Tomcat，并复制到你希望存放的目录，一般存放在`/Library`目录下\n- 通过终端修改Tomcat的权限 `sudo chmod 755 /Library/Tomcat`\n- 执行`/Library/Tomcat/bin/startup.sh`启动Tomcat\n- 打开[http://localhost:8080](http://localhost:8080)验证Tomcat是否安装成功\n\n![](http://upload-images.jianshu.io/upload_images/260268-fcc36bece30a4fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n## 安装Eclipse\n\n- 访问[Eclipse官方首页](http://www.eclipse.org/home/index.php)下载安装包\n- 执行`Eclipse installer`，将Eclipse拖入应用程序中\n- 打开Eclipse设置工作空间\n\n## 配置Eclipse\n\n- Eclipse 偏好设置\n- java Installed JREs\n- Add 选择`Standard VM`\n- Directory 选择本地安装的JDK的路径\n  JDK路径查询命令行\n ```\n  ls -l `which java`\n ```\n- 选中新添加的JRE\n- 右击项目\n- 选择`Java Build Path`\n- Add 选择`User Library`\n- 选择Tomcat\n- 配置完成\n\n","source":"_posts/Mac搭建基于Eclipse的J2EE开发环境.md","raw":"title: Mac搭建基于Eclipse的J2EE开发环境\ntags:\n  - ''\ncategories: []\ndate: 2017-12-14 19:21:00\n---\n虽然网上有各种Mac环境下搭建基于Eclipse的J2EE开发环境的博客，但是在实际参考中或多或少存在着一些偏差，经过一段时间的努力，总算是成功搭建完成并跑通了项目，这里做一个总结供大家参考。\n## 安装JDK\n- 打开终端输入`java -version`判断是否已安装java运行环境\n- 如果未安装则下载JDK并进行安装 [下载地址](http://www.oracle.com/technetwork/java/javaee/downloads/java-ee-sdk-7-jdk-7u21-downloads-1956231.html)\n## 安装Tomcat\n- 在[Apache官网](http://tomcat.apache.org)下载最新的tomcat二进制包\n- 将二进制包解压后改名为Tomcat，并复制到你希望存放的目录，一般存放在`/Library`目录下\n- 通过终端修改Tomcat的权限 `sudo chmod 755 /Library/Tomcat`\n- 执行`/Library/Tomcat/bin/startup.sh`启动Tomcat\n- 打开[http://localhost:8080](http://localhost:8080)验证Tomcat是否安装成功\n\n![](http://upload-images.jianshu.io/upload_images/260268-fcc36bece30a4fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n## 安装Eclipse\n\n- 访问[Eclipse官方首页](http://www.eclipse.org/home/index.php)下载安装包\n- 执行`Eclipse installer`，将Eclipse拖入应用程序中\n- 打开Eclipse设置工作空间\n\n## 配置Eclipse\n\n- Eclipse 偏好设置\n- java Installed JREs\n- Add 选择`Standard VM`\n- Directory 选择本地安装的JDK的路径\n  JDK路径查询命令行\n ```\n  ls -l `which java`\n ```\n- 选中新添加的JRE\n- 右击项目\n- 选择`Java Build Path`\n- Add 选择`User Library`\n- 选择Tomcat\n- 配置完成\n\n","slug":"Mac搭建基于Eclipse的J2EE开发环境","published":1,"updated":"2018-08-31T09:37:07.325Z","_id":"cjlhoqwhz000xkj79ovq6sghs","comments":1,"layout":"post","photos":[],"link":"","content":"<p>虽然网上有各种Mac环境下搭建基于Eclipse的J2EE开发环境的博客，但是在实际参考中或多或少存在着一些偏差，经过一段时间的努力，总算是成功搭建完成并跑通了项目，这里做一个总结供大家参考。</p>\n<h2 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h2><ul>\n<li>打开终端输入<code>java -version</code>判断是否已安装java运行环境</li>\n<li>如果未安装则下载JDK并进行安装 <a href=\"http://www.oracle.com/technetwork/java/javaee/downloads/java-ee-sdk-7-jdk-7u21-downloads-1956231.html\" target=\"_blank\" rel=\"external\">下载地址</a><h2 id=\"安装Tomcat\"><a href=\"#安装Tomcat\" class=\"headerlink\" title=\"安装Tomcat\"></a>安装Tomcat</h2></li>\n<li>在<a href=\"http://tomcat.apache.org\" target=\"_blank\" rel=\"external\">Apache官网</a>下载最新的tomcat二进制包</li>\n<li>将二进制包解压后改名为Tomcat，并复制到你希望存放的目录，一般存放在<code>/Library</code>目录下</li>\n<li>通过终端修改Tomcat的权限 <code>sudo chmod 755 /Library/Tomcat</code></li>\n<li>执行<code>/Library/Tomcat/bin/startup.sh</code>启动Tomcat</li>\n<li>打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"external\">http://localhost:8080</a>验证Tomcat是否安装成功</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/260268-fcc36bece30a4fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<h2 id=\"安装Eclipse\"><a href=\"#安装Eclipse\" class=\"headerlink\" title=\"安装Eclipse\"></a>安装Eclipse</h2><ul>\n<li>访问<a href=\"http://www.eclipse.org/home/index.php\" target=\"_blank\" rel=\"external\">Eclipse官方首页</a>下载安装包</li>\n<li>执行<code>Eclipse installer</code>，将Eclipse拖入应用程序中</li>\n<li>打开Eclipse设置工作空间</li>\n</ul>\n<h2 id=\"配置Eclipse\"><a href=\"#配置Eclipse\" class=\"headerlink\" title=\"配置Eclipse\"></a>配置Eclipse</h2><ul>\n<li>Eclipse 偏好设置</li>\n<li>java Installed JREs</li>\n<li>Add 选择<code>Standard VM</code></li>\n<li><p>Directory 选择本地安装的JDK的路径<br>JDK路径查询命令行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ls -l `which java`</div></pre></td></tr></table></figure>\n</li>\n<li><p>选中新添加的JRE</p>\n</li>\n<li>右击项目</li>\n<li>选择<code>Java Build Path</code></li>\n<li>Add 选择<code>User Library</code></li>\n<li>选择Tomcat</li>\n<li>配置完成</li>\n</ul>\n","excerpt":"","more":"<p>虽然网上有各种Mac环境下搭建基于Eclipse的J2EE开发环境的博客，但是在实际参考中或多或少存在着一些偏差，经过一段时间的努力，总算是成功搭建完成并跑通了项目，这里做一个总结供大家参考。</p>\n<h2 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h2><ul>\n<li>打开终端输入<code>java -version</code>判断是否已安装java运行环境</li>\n<li>如果未安装则下载JDK并进行安装 <a href=\"http://www.oracle.com/technetwork/java/javaee/downloads/java-ee-sdk-7-jdk-7u21-downloads-1956231.html\">下载地址</a><h2 id=\"安装Tomcat\"><a href=\"#安装Tomcat\" class=\"headerlink\" title=\"安装Tomcat\"></a>安装Tomcat</h2></li>\n<li>在<a href=\"http://tomcat.apache.org\">Apache官网</a>下载最新的tomcat二进制包</li>\n<li>将二进制包解压后改名为Tomcat，并复制到你希望存放的目录，一般存放在<code>/Library</code>目录下</li>\n<li>通过终端修改Tomcat的权限 <code>sudo chmod 755 /Library/Tomcat</code></li>\n<li>执行<code>/Library/Tomcat/bin/startup.sh</code>启动Tomcat</li>\n<li>打开<a href=\"http://localhost:8080\">http://localhost:8080</a>验证Tomcat是否安装成功</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/260268-fcc36bece30a4fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<h2 id=\"安装Eclipse\"><a href=\"#安装Eclipse\" class=\"headerlink\" title=\"安装Eclipse\"></a>安装Eclipse</h2><ul>\n<li>访问<a href=\"http://www.eclipse.org/home/index.php\">Eclipse官方首页</a>下载安装包</li>\n<li>执行<code>Eclipse installer</code>，将Eclipse拖入应用程序中</li>\n<li>打开Eclipse设置工作空间</li>\n</ul>\n<h2 id=\"配置Eclipse\"><a href=\"#配置Eclipse\" class=\"headerlink\" title=\"配置Eclipse\"></a>配置Eclipse</h2><ul>\n<li>Eclipse 偏好设置</li>\n<li>java Installed JREs</li>\n<li>Add 选择<code>Standard VM</code></li>\n<li><p>Directory 选择本地安装的JDK的路径<br>JDK路径查询命令行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ls -l `which java`</div></pre></td></tr></table></figure>\n</li>\n<li><p>选中新添加的JRE</p>\n</li>\n<li>右击项目</li>\n<li>选择<code>Java Build Path</code></li>\n<li>Add 选择<code>User Library</code></li>\n<li>选择Tomcat</li>\n<li>配置完成</li>\n</ul>\n"},{"title":"ZYLoading--自定义Loading控件","date":"2017-12-14T11:20:00.000Z","_content":"移动端项目的开发离不开loading控件，通常为了能快速在项目中实现loading效果我们有几个主流的开源库可以选择：\n[MBProgressHUD](https://github.com/jdg/MBProgressHUD)、[SVProgressHUD](https://github.com/SVProgressHUD/SVProgressHUD)等\n\n然后，为了能让整体项目的loading效果显得更加贴切我就想创建一个loading控件，希望此控件能够比较方便的开启、停止loading效果，而且能易于集成和更换logo。\n\n为了达到这个目的，我创建了一个名为[ZYLoading](https://github.com/luzhiyongGit/ZYLoading.git)的控件，下面就为大家分享一下我这个控件的原理以及使用方法。\n\n## 原理分析\n\n此控件的核心思想是利用runtime机制给分类增加成员属性，通过给UIView扩展开启、停止loading的方法，从而实现任何UIView的实例都能方便的开启、停止loading动画\n\n```\n#import \"UIView+ZYLoadingView.h\"\n\n#import <objc/runtime.h>\n\nstatic char LoadingViewKey;\n\n@implementation UIView (ZYLoadingView)\n\n#pragma mark - Setter\n\n// 将创建的ZYLoadingView实例关联到分类\n- (void)setLoadingView:(ZYLoadingView *)loadingView {\n    [self willChangeValueForKey:@\"LoadingViewKey\"];\n    objc_setAssociatedObject(self, &LoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    [self didChangeValueForKey:@\"LoadingViewKey\"];\n}\n\n// 获取关联的ZYLoadingView\n- (ZYLoadingView *)loadingView {\n    return objc_getAssociatedObject(self, &LoadingViewKey);\n}\n\n// 开启动画\n- (void)beginLoading {\n    if (!self.loadingView) {\n        self.loadingView = [[ZYLoadingView alloc] initWithFrame:self.bounds];\n    }\n    \n    [self addSubview:self.loadingView];\n    \n    [self.loadingView startAnimation];\n}\n\n// 停止动画\n- (void)endLoading {\n    if (self.loadingView) {\n        [self.loadingView stopAnimation];\n    }\n}\n\n@end\n\n```\n\n## 使用方法\n\n##### 通过一组图片组合成动画\n\n```\n// 通过枚举选择图片组合动画\nZYLoadingConfigInstance.loadingType = ZYLoadingAnimateImages;\n// 图片名称\nZYLoadingConfigInstance.animateImageName = @\"zy_loading_\";\n// 图片尺寸\nZYLoadingConfigInstance.loopImageSize = CGSizeMake(37, 13);\n// 动画过渡时长\nZYLoadingConfigInstance.duration = 1.f;\n```\n\n##### 通过一张图旋转形成动画\n\n```\n// 通过枚举选择通过旋转图片展现loading动画\nZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;\n// 图片名称\nZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@\"loading_circle\"];\n// 图片尺寸    \nZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);\n// 动画过渡时长    \nZYLoadingConfigInstance.duration = 0.25f;\n```\n\n##### 通过一张图片旋转，另一张图片渐隐渐显组合成动画\n\n```\n// 通过枚举选择通过旋转图片展现loading动画    ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;\n// 图片名称\nZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@\"loading_circle\"];\n// 图片尺寸    \nZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);\n// logo图片名称\nZYLoadingConfigInstance.logoImage = [UIImage imageNamed:@\"loading_zhangyu\"];\n// logo图片尺寸\nZYLoadingConfigInstance.logoImageSize = CGSizeMake(40, 40);\n// 动画过渡时长\nZYLoadingConfigInstance.duration = 0.25f;\n```\n\n##### 开启、停止动画\n\n```\n// 开启动画\n[self.view beginLoading];\n\n// 停止动画\n[self.view endLoading];\n```\n\n你也可以直接参考github上的[ZYLoading](https://github.com/luzhiyongGit/ZYLoading.git)","source":"_posts/ZYLoading-自定义Loading控件.md","raw":"title: ZYLoading--自定义Loading控件\ntags:\n  - iOS进阶\n  - ''\n  - ''\ncategories:\n  - iOS\ndate: 2017-12-14 19:20:00\n---\n移动端项目的开发离不开loading控件，通常为了能快速在项目中实现loading效果我们有几个主流的开源库可以选择：\n[MBProgressHUD](https://github.com/jdg/MBProgressHUD)、[SVProgressHUD](https://github.com/SVProgressHUD/SVProgressHUD)等\n\n然后，为了能让整体项目的loading效果显得更加贴切我就想创建一个loading控件，希望此控件能够比较方便的开启、停止loading效果，而且能易于集成和更换logo。\n\n为了达到这个目的，我创建了一个名为[ZYLoading](https://github.com/luzhiyongGit/ZYLoading.git)的控件，下面就为大家分享一下我这个控件的原理以及使用方法。\n\n## 原理分析\n\n此控件的核心思想是利用runtime机制给分类增加成员属性，通过给UIView扩展开启、停止loading的方法，从而实现任何UIView的实例都能方便的开启、停止loading动画\n\n```\n#import \"UIView+ZYLoadingView.h\"\n\n#import <objc/runtime.h>\n\nstatic char LoadingViewKey;\n\n@implementation UIView (ZYLoadingView)\n\n#pragma mark - Setter\n\n// 将创建的ZYLoadingView实例关联到分类\n- (void)setLoadingView:(ZYLoadingView *)loadingView {\n    [self willChangeValueForKey:@\"LoadingViewKey\"];\n    objc_setAssociatedObject(self, &LoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    [self didChangeValueForKey:@\"LoadingViewKey\"];\n}\n\n// 获取关联的ZYLoadingView\n- (ZYLoadingView *)loadingView {\n    return objc_getAssociatedObject(self, &LoadingViewKey);\n}\n\n// 开启动画\n- (void)beginLoading {\n    if (!self.loadingView) {\n        self.loadingView = [[ZYLoadingView alloc] initWithFrame:self.bounds];\n    }\n    \n    [self addSubview:self.loadingView];\n    \n    [self.loadingView startAnimation];\n}\n\n// 停止动画\n- (void)endLoading {\n    if (self.loadingView) {\n        [self.loadingView stopAnimation];\n    }\n}\n\n@end\n\n```\n\n## 使用方法\n\n##### 通过一组图片组合成动画\n\n```\n// 通过枚举选择图片组合动画\nZYLoadingConfigInstance.loadingType = ZYLoadingAnimateImages;\n// 图片名称\nZYLoadingConfigInstance.animateImageName = @\"zy_loading_\";\n// 图片尺寸\nZYLoadingConfigInstance.loopImageSize = CGSizeMake(37, 13);\n// 动画过渡时长\nZYLoadingConfigInstance.duration = 1.f;\n```\n\n##### 通过一张图旋转形成动画\n\n```\n// 通过枚举选择通过旋转图片展现loading动画\nZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;\n// 图片名称\nZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@\"loading_circle\"];\n// 图片尺寸    \nZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);\n// 动画过渡时长    \nZYLoadingConfigInstance.duration = 0.25f;\n```\n\n##### 通过一张图片旋转，另一张图片渐隐渐显组合成动画\n\n```\n// 通过枚举选择通过旋转图片展现loading动画    ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;\n// 图片名称\nZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@\"loading_circle\"];\n// 图片尺寸    \nZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);\n// logo图片名称\nZYLoadingConfigInstance.logoImage = [UIImage imageNamed:@\"loading_zhangyu\"];\n// logo图片尺寸\nZYLoadingConfigInstance.logoImageSize = CGSizeMake(40, 40);\n// 动画过渡时长\nZYLoadingConfigInstance.duration = 0.25f;\n```\n\n##### 开启、停止动画\n\n```\n// 开启动画\n[self.view beginLoading];\n\n// 停止动画\n[self.view endLoading];\n```\n\n你也可以直接参考github上的[ZYLoading](https://github.com/luzhiyongGit/ZYLoading.git)","slug":"ZYLoading-自定义Loading控件","published":1,"updated":"2018-08-31T09:41:45.721Z","_id":"cjlhoqwi00012kj790mkj9wrm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>移动端项目的开发离不开loading控件，通常为了能快速在项目中实现loading效果我们有几个主流的开源库可以选择：<br><a href=\"https://github.com/jdg/MBProgressHUD\" target=\"_blank\" rel=\"external\">MBProgressHUD</a>、<a href=\"https://github.com/SVProgressHUD/SVProgressHUD\" target=\"_blank\" rel=\"external\">SVProgressHUD</a>等</p>\n<p>然后，为了能让整体项目的loading效果显得更加贴切我就想创建一个loading控件，希望此控件能够比较方便的开启、停止loading效果，而且能易于集成和更换logo。</p>\n<p>为了达到这个目的，我创建了一个名为<a href=\"https://github.com/luzhiyongGit/ZYLoading.git\" target=\"_blank\" rel=\"external\">ZYLoading</a>的控件，下面就为大家分享一下我这个控件的原理以及使用方法。</p>\n<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>此控件的核心思想是利用runtime机制给分类增加成员属性，通过给UIView扩展开启、停止loading的方法，从而实现任何UIView的实例都能方便的开启、停止loading动画</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+ZYLoadingView.h&quot;</div><div class=\"line\"></div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">static char LoadingViewKey;</div><div class=\"line\"></div><div class=\"line\">@implementation UIView (ZYLoadingView)</div><div class=\"line\"></div><div class=\"line\">#pragma mark - Setter</div><div class=\"line\"></div><div class=\"line\">// 将创建的ZYLoadingView实例关联到分类</div><div class=\"line\">- (void)setLoadingView:(ZYLoadingView *)loadingView &#123;</div><div class=\"line\">    [self willChangeValueForKey:@&quot;LoadingViewKey&quot;];</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;LoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">    [self didChangeValueForKey:@&quot;LoadingViewKey&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 获取关联的ZYLoadingView</div><div class=\"line\">- (ZYLoadingView *)loadingView &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, &amp;LoadingViewKey);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 开启动画</div><div class=\"line\">- (void)beginLoading &#123;</div><div class=\"line\">    if (!self.loadingView) &#123;</div><div class=\"line\">        self.loadingView = [[ZYLoadingView alloc] initWithFrame:self.bounds];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    [self addSubview:self.loadingView];</div><div class=\"line\">    </div><div class=\"line\">    [self.loadingView startAnimation];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 停止动画</div><div class=\"line\">- (void)endLoading &#123;</div><div class=\"line\">    if (self.loadingView) &#123;</div><div class=\"line\">        [self.loadingView stopAnimation];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><h5 id=\"通过一组图片组合成动画\"><a href=\"#通过一组图片组合成动画\" class=\"headerlink\" title=\"通过一组图片组合成动画\"></a>通过一组图片组合成动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 通过枚举选择图片组合动画</div><div class=\"line\">ZYLoadingConfigInstance.loadingType = ZYLoadingAnimateImages;</div><div class=\"line\">// 图片名称</div><div class=\"line\">ZYLoadingConfigInstance.animateImageName = @&quot;zy_loading_&quot;;</div><div class=\"line\">// 图片尺寸</div><div class=\"line\">ZYLoadingConfigInstance.loopImageSize = CGSizeMake(37, 13);</div><div class=\"line\">// 动画过渡时长</div><div class=\"line\">ZYLoadingConfigInstance.duration = 1.f;</div></pre></td></tr></table></figure>\n<h5 id=\"通过一张图旋转形成动画\"><a href=\"#通过一张图旋转形成动画\" class=\"headerlink\" title=\"通过一张图旋转形成动画\"></a>通过一张图旋转形成动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 通过枚举选择通过旋转图片展现loading动画</div><div class=\"line\">ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;</div><div class=\"line\">// 图片名称</div><div class=\"line\">ZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@&quot;loading_circle&quot;];</div><div class=\"line\">// 图片尺寸    </div><div class=\"line\">ZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);</div><div class=\"line\">// 动画过渡时长    </div><div class=\"line\">ZYLoadingConfigInstance.duration = 0.25f;</div></pre></td></tr></table></figure>\n<h5 id=\"通过一张图片旋转，另一张图片渐隐渐显组合成动画\"><a href=\"#通过一张图片旋转，另一张图片渐隐渐显组合成动画\" class=\"headerlink\" title=\"通过一张图片旋转，另一张图片渐隐渐显组合成动画\"></a>通过一张图片旋转，另一张图片渐隐渐显组合成动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 通过枚举选择通过旋转图片展现loading动画    ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;</div><div class=\"line\">// 图片名称</div><div class=\"line\">ZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@&quot;loading_circle&quot;];</div><div class=\"line\">// 图片尺寸    </div><div class=\"line\">ZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);</div><div class=\"line\">// logo图片名称</div><div class=\"line\">ZYLoadingConfigInstance.logoImage = [UIImage imageNamed:@&quot;loading_zhangyu&quot;];</div><div class=\"line\">// logo图片尺寸</div><div class=\"line\">ZYLoadingConfigInstance.logoImageSize = CGSizeMake(40, 40);</div><div class=\"line\">// 动画过渡时长</div><div class=\"line\">ZYLoadingConfigInstance.duration = 0.25f;</div></pre></td></tr></table></figure>\n<h5 id=\"开启、停止动画\"><a href=\"#开启、停止动画\" class=\"headerlink\" title=\"开启、停止动画\"></a>开启、停止动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 开启动画</div><div class=\"line\">[self.view beginLoading];</div><div class=\"line\"></div><div class=\"line\">// 停止动画</div><div class=\"line\">[self.view endLoading];</div></pre></td></tr></table></figure>\n<p>你也可以直接参考github上的<a href=\"https://github.com/luzhiyongGit/ZYLoading.git\" target=\"_blank\" rel=\"external\">ZYLoading</a></p>\n","excerpt":"","more":"<p>移动端项目的开发离不开loading控件，通常为了能快速在项目中实现loading效果我们有几个主流的开源库可以选择：<br><a href=\"https://github.com/jdg/MBProgressHUD\">MBProgressHUD</a>、<a href=\"https://github.com/SVProgressHUD/SVProgressHUD\">SVProgressHUD</a>等</p>\n<p>然后，为了能让整体项目的loading效果显得更加贴切我就想创建一个loading控件，希望此控件能够比较方便的开启、停止loading效果，而且能易于集成和更换logo。</p>\n<p>为了达到这个目的，我创建了一个名为<a href=\"https://github.com/luzhiyongGit/ZYLoading.git\">ZYLoading</a>的控件，下面就为大家分享一下我这个控件的原理以及使用方法。</p>\n<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>此控件的核心思想是利用runtime机制给分类增加成员属性，通过给UIView扩展开启、停止loading的方法，从而实现任何UIView的实例都能方便的开启、停止loading动画</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+ZYLoadingView.h&quot;</div><div class=\"line\"></div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">static char LoadingViewKey;</div><div class=\"line\"></div><div class=\"line\">@implementation UIView (ZYLoadingView)</div><div class=\"line\"></div><div class=\"line\">#pragma mark - Setter</div><div class=\"line\"></div><div class=\"line\">// 将创建的ZYLoadingView实例关联到分类</div><div class=\"line\">- (void)setLoadingView:(ZYLoadingView *)loadingView &#123;</div><div class=\"line\">    [self willChangeValueForKey:@&quot;LoadingViewKey&quot;];</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;LoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">    [self didChangeValueForKey:@&quot;LoadingViewKey&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 获取关联的ZYLoadingView</div><div class=\"line\">- (ZYLoadingView *)loadingView &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, &amp;LoadingViewKey);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 开启动画</div><div class=\"line\">- (void)beginLoading &#123;</div><div class=\"line\">    if (!self.loadingView) &#123;</div><div class=\"line\">        self.loadingView = [[ZYLoadingView alloc] initWithFrame:self.bounds];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    [self addSubview:self.loadingView];</div><div class=\"line\">    </div><div class=\"line\">    [self.loadingView startAnimation];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 停止动画</div><div class=\"line\">- (void)endLoading &#123;</div><div class=\"line\">    if (self.loadingView) &#123;</div><div class=\"line\">        [self.loadingView stopAnimation];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><h5 id=\"通过一组图片组合成动画\"><a href=\"#通过一组图片组合成动画\" class=\"headerlink\" title=\"通过一组图片组合成动画\"></a>通过一组图片组合成动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 通过枚举选择图片组合动画</div><div class=\"line\">ZYLoadingConfigInstance.loadingType = ZYLoadingAnimateImages;</div><div class=\"line\">// 图片名称</div><div class=\"line\">ZYLoadingConfigInstance.animateImageName = @&quot;zy_loading_&quot;;</div><div class=\"line\">// 图片尺寸</div><div class=\"line\">ZYLoadingConfigInstance.loopImageSize = CGSizeMake(37, 13);</div><div class=\"line\">// 动画过渡时长</div><div class=\"line\">ZYLoadingConfigInstance.duration = 1.f;</div></pre></td></tr></table></figure>\n<h5 id=\"通过一张图旋转形成动画\"><a href=\"#通过一张图旋转形成动画\" class=\"headerlink\" title=\"通过一张图旋转形成动画\"></a>通过一张图旋转形成动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 通过枚举选择通过旋转图片展现loading动画</div><div class=\"line\">ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;</div><div class=\"line\">// 图片名称</div><div class=\"line\">ZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@&quot;loading_circle&quot;];</div><div class=\"line\">// 图片尺寸    </div><div class=\"line\">ZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);</div><div class=\"line\">// 动画过渡时长    </div><div class=\"line\">ZYLoadingConfigInstance.duration = 0.25f;</div></pre></td></tr></table></figure>\n<h5 id=\"通过一张图片旋转，另一张图片渐隐渐显组合成动画\"><a href=\"#通过一张图片旋转，另一张图片渐隐渐显组合成动画\" class=\"headerlink\" title=\"通过一张图片旋转，另一张图片渐隐渐显组合成动画\"></a>通过一张图片旋转，另一张图片渐隐渐显组合成动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 通过枚举选择通过旋转图片展现loading动画    ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;</div><div class=\"line\">// 图片名称</div><div class=\"line\">ZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@&quot;loading_circle&quot;];</div><div class=\"line\">// 图片尺寸    </div><div class=\"line\">ZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);</div><div class=\"line\">// logo图片名称</div><div class=\"line\">ZYLoadingConfigInstance.logoImage = [UIImage imageNamed:@&quot;loading_zhangyu&quot;];</div><div class=\"line\">// logo图片尺寸</div><div class=\"line\">ZYLoadingConfigInstance.logoImageSize = CGSizeMake(40, 40);</div><div class=\"line\">// 动画过渡时长</div><div class=\"line\">ZYLoadingConfigInstance.duration = 0.25f;</div></pre></td></tr></table></figure>\n<h5 id=\"开启、停止动画\"><a href=\"#开启、停止动画\" class=\"headerlink\" title=\"开启、停止动画\"></a>开启、停止动画</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 开启动画</div><div class=\"line\">[self.view beginLoading];</div><div class=\"line\"></div><div class=\"line\">// 停止动画</div><div class=\"line\">[self.view endLoading];</div></pre></td></tr></table></figure>\n<p>你也可以直接参考github上的<a href=\"https://github.com/luzhiyongGit/ZYLoading.git\">ZYLoading</a></p>\n"},{"title":"React-Native之Navigator","date":"2016-11-24T03:26:00.000Z","_content":"\n#### 结合官方文档，简单使用Navigator\n\nReact Native内置了navigation组件，在[官方文档](http://facebook.github.io/react-native/docs/using-navigators.html)中对于如何使用Navigator有了一个简要的说明，下面就让我们跟随文档进行学习。 \n\n1. 页面搭建\n\n   根据文档的描述，我们需要先创建一个文件命名为`MyScene.js`，内容如下：\n\n   ```javascript\n   // 导入需要使用的组件\n   import React, { Component } from 'react';\n   import { View, Text, Navigator } from 'react-native';\n\n   // 声明MyScene类，并设置为外部可以引用\n   export default class MyScene extends Component {\n     static get defaultProps() {\n       return {\n         title: 'MyScene'\n       };\n     }\n\n     // 绘制界面\n     render() {\n       return (\n         <View style={{height: 200, top: 64}}>\n           <Text>Hi! My name is {this.props.title}.</Text>\n         </View>\n       )\n     }\n   }\n   ```\n\n​      创建完`MyScene.js`后我们就需要进入到`index.ios.js`中进行更改。 \n\n```javascript\n// 导入需要用到的组件\nimport React, { Component } from 'react';\nimport { AppRegistry } from 'react-native';\n\n// 导入需要引用的文件\nimport MyScene from './MyScene';\n\n// 声明入口类\nclass YoDawgApp extends Component {\n  // 绘制界面，通过加载 MyScene\n  render() {\n    return (\n      <MyScene />\n    )\n  }\n}\n// 注册入口类\nAppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n```\n\n​      进行上述操作后运行项目来看一下效果：\n\n![React-Native之Navigator_1](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_1.png)\n\n显然，跟我们想要的效果差很远。       \n\n2. 使用Navigator\n\n   接下来我们就需要利用`Navigator`组件，修改`index.ios.js`文件\n\n   ```javascript\n   // 导入需要用到的组件\n   import React, { Component } from 'react';\n   import { AppRegistry } from 'react-native';\n\n   // 导入需要引用的文件\n   import MyScene from './MyScene';\n\n   // 声明入口类\n   class YoDawgApp extends Component {\n     // 绘制界面，通过加载 MyScene\n     render() {\n       return (\n         // 创建一个Navigator 并嵌套 MyScene\n         <Navigator\n            initialRoute={{ title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) => {\n              return <MyScene title={route.title} />\n            }}\n         />\n       )\n     }\n   }\n   // 注册入口类\n   AppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n   ```\n\n   进行上述操作后我们再次运行项目：\n\n   ![React-Native之Navigator_2.png](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_2.png)\n\n   比较两次的运行结果，似乎只是文案内容发生了改变，让我们继续下去看到更多的变化\n\n3. 加入`push` `pop` \n\n   `navigator`给我们提供了`push` `pop` 操作，我们来继续修改`index.ios.js`\n\n   ```javascript\n   // 导入需要用到的组件\n   import React, { Component } from 'react';\n   import { AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity } from 'react-native';\n\n   // 导入需要引用的文件\n   import MyScene from './MyScene';\n\n   // 声明入口类\n   class YoDawgApp extends Component {\n     // 绘制界面，通过加载 MyScene\n     render() {\n       return (\n         // 创建一个Navigator 并嵌套 MyScene\n         <Navigator\n            initialRoute={{ title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) => {\n              return <MyScene title={route.title} \n                 // push操作调用函数\n                  onForward={ () => {\n                    const nextIndex = route.index + 1;\n                    navigator.push({\n                       title: 'Scene ' + nextIndex,\n                       index: nextIndex,\n                    });\n                  }}\n     \n                 // pop操作调用函数\n                  onBack={ () => {\n                    if (route.index > 0) {\n                      navigator.pop();\n                    }\n                  }}\n              />\n            }}\n         />\n       )\n     }\n   }\n   // 注册入口类\n   AppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n   ```\n\n   现在我们在`MyScene.js` 里添加上点击事件，并调用`onForward`和`onBack`方法看看会有怎样的效果\n\n   ```javascript\n   // 导入需要使用的组件\n   import React, { Component } from 'react';\n   import { View, Text, Navigator, TouchableHighlight } from 'react-native';\n\n   // 声明MyScene类，并设置为外部可以引用\n   export default class MyScene extends Component {\n     static get defaultProps() {\n       return {\n         title: 'MyScene'\n       };\n     }\n\n     // 绘制界面\n     render() {\n       return (\n         <View style={{height: 200, top: 64}}>\n           <Text>Hi! My name is {this.props.title}.</Text>\n         // 添加两个可点击区域，分别用于push和pop\n           <TouchableHighlight onPress={this.props.onForward}>\n              <Text>Tap me to load the next scene</Text>\n           </TouchableHighlight>\n           <TouchableHighlight onPress={this.props.onBack}>\n              <Text>Tap me to go back</Text>\n           </TouchableHighlight>\n         </View>\n       )\n     }\n   }\n\n   MyScene.propTypes = {\n     title: PropTypes.string.isRequired,\n     onForward: PropTypes.func.isRequired,\n     onBack: PropTypes.func.isRequired,\n   };\n   ```\n\n   再次运行项目看一下效果：\n\n   ![React-Native之Navigator_3.png](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_3.png)\n\n   点击`Tap me to load the next scene`能够push下一个页面\n\n   点击`Tap me to go back`能够pop到上一个页面\n\n   看来我们已经顺利集成了`Navigator` ,不过，似乎还缺少什么？\n\n4. 显示Navigator Bar\n\n   通过上述操作我们能够正常实现`Navigator` 的`push` 和`pop` 操作啦，但是，我们一直没有看到导航栏，这是因为在`React Native`中我们需要额外设置才能够展现`Navigator Bar` ，下面就让我们来继续修改`index.ios.js`\n\n   ```javascript\n   // 导入需要用到的组件\n   import React, { Component } from 'react';\n   import { AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity } from 'react-native';\n\n   // 导入需要引用的文件\n   import MyScene from './MyScene';\n\n   // 声明入口类\n   class YoDawgApp extends Component {\n     // 绘制界面，通过加载 MyScene\n     render() {\n       return (\n         // 创建一个Navigator 并嵌套 MyScene\n         <Navigator\n            initialRoute={{ title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) => {\n              return <MyScene title={route.title} \n                 // push操作调用函数\n                  onForward={ () => {\n                    const nextIndex = route.index + 1;\n                    navigator.push({\n                       title: 'Scene ' + nextIndex,\n                       index: nextIndex,\n                    });\n                  }}\n     \n                 // pop操作调用函数\n                  onBack={ () => {\n                    if (route.index > 0) {\n                      navigator.pop();\n                    }\n                  }}\n              />\n            }}\n            // 增加navigationBar\n             navigationBar={\n                     \t<Navigator.NavigationBar\n                          routeMapper={NavigationBarRouteMapper}\n                          style={{backgroundColor:'#fff',\n                                  borderColor:'#dddddd',\n                                  borderWidth:1,\n                                  height: 64}}\n                     \t/>\n            }\n         />\n       )\n     }\n   }\n\n   // 导航栏的Mapper\n   var NavigationBarRouteMapper = {\n     // 左键\n     LeftButton(route, navigator, index, navState) {\n       if (index > 0) {\n         return (\n           <View style={styles.navContainer}>\n             <TouchableOpacity\n               underlayColor='transparent'\n               onPress={() => {if (index > 0) {navigator.pop()}}}>\n               <Text style={styles.leftNavButtonText}>\n                 后退\n               </Text>\n             </TouchableOpacity>\n           </View>\n         );\n       } else {\n         return null;\n       }\n     },\n     // 右键\n     RightButton(route, navigator, index, navState) {\n       if (route.onPress)\n         return (\n           <View style={styles.navContainer}>\n             <TouchableOpacity\n               onPress={() => route.onPress()}>\n               <Text style={styles.rightNavButtonText}>\n                 {route.rightText || '右键'}\n               </Text>\n             </TouchableOpacity>\n           </View>\n         );\n     },\n     // 标题\n     Title(route, navigator, index, navState) {\n       return (\n         <View style={styles.navContainer}>\n           <Text style={styles.title}>\n             应用标题\n           </Text>\n         </View>\n       );\n     }\n   };\n\n   var styles = StyleSheet.create({\n     navBar: {\n         backgroundColor:'#fff',\n         borderColor:'#dddddd',\n         borderWidth:1,\n         height: 64\n     },\n     navBarTitleText: {\n       fontWeight: '500',\n     },\n     navBarLeftButton: {\n       paddingLeft: 5,\n     },\n     navBarRightButton: {\n         marginRight:5,\n     },\n     icon: {\n         width:30,\n         height:30,\n         marginTop:6,\n         textAlign:'center'\n     }\n   });\n\n   // 注册入口类\n   AppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n   ```\n\n   我们来最后看一下效果：\n\n   ![React-Native之Navigator_4](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_4.png)\n\n   ![React-Native之Navigator_5](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_5.png)\n\n   ​\n\n","source":"_posts/React-Native之Navigator.md","raw":"title: React-Native之Navigator\ntags: []\ncategories:\n  - ReactNative\ndate: 2016-11-24 11:26:00\n---\n\n#### 结合官方文档，简单使用Navigator\n\nReact Native内置了navigation组件，在[官方文档](http://facebook.github.io/react-native/docs/using-navigators.html)中对于如何使用Navigator有了一个简要的说明，下面就让我们跟随文档进行学习。 \n\n1. 页面搭建\n\n   根据文档的描述，我们需要先创建一个文件命名为`MyScene.js`，内容如下：\n\n   ```javascript\n   // 导入需要使用的组件\n   import React, { Component } from 'react';\n   import { View, Text, Navigator } from 'react-native';\n\n   // 声明MyScene类，并设置为外部可以引用\n   export default class MyScene extends Component {\n     static get defaultProps() {\n       return {\n         title: 'MyScene'\n       };\n     }\n\n     // 绘制界面\n     render() {\n       return (\n         <View style={{height: 200, top: 64}}>\n           <Text>Hi! My name is {this.props.title}.</Text>\n         </View>\n       )\n     }\n   }\n   ```\n\n​      创建完`MyScene.js`后我们就需要进入到`index.ios.js`中进行更改。 \n\n```javascript\n// 导入需要用到的组件\nimport React, { Component } from 'react';\nimport { AppRegistry } from 'react-native';\n\n// 导入需要引用的文件\nimport MyScene from './MyScene';\n\n// 声明入口类\nclass YoDawgApp extends Component {\n  // 绘制界面，通过加载 MyScene\n  render() {\n    return (\n      <MyScene />\n    )\n  }\n}\n// 注册入口类\nAppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n```\n\n​      进行上述操作后运行项目来看一下效果：\n\n![React-Native之Navigator_1](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_1.png)\n\n显然，跟我们想要的效果差很远。       \n\n2. 使用Navigator\n\n   接下来我们就需要利用`Navigator`组件，修改`index.ios.js`文件\n\n   ```javascript\n   // 导入需要用到的组件\n   import React, { Component } from 'react';\n   import { AppRegistry } from 'react-native';\n\n   // 导入需要引用的文件\n   import MyScene from './MyScene';\n\n   // 声明入口类\n   class YoDawgApp extends Component {\n     // 绘制界面，通过加载 MyScene\n     render() {\n       return (\n         // 创建一个Navigator 并嵌套 MyScene\n         <Navigator\n            initialRoute={{ title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) => {\n              return <MyScene title={route.title} />\n            }}\n         />\n       )\n     }\n   }\n   // 注册入口类\n   AppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n   ```\n\n   进行上述操作后我们再次运行项目：\n\n   ![React-Native之Navigator_2.png](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_2.png)\n\n   比较两次的运行结果，似乎只是文案内容发生了改变，让我们继续下去看到更多的变化\n\n3. 加入`push` `pop` \n\n   `navigator`给我们提供了`push` `pop` 操作，我们来继续修改`index.ios.js`\n\n   ```javascript\n   // 导入需要用到的组件\n   import React, { Component } from 'react';\n   import { AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity } from 'react-native';\n\n   // 导入需要引用的文件\n   import MyScene from './MyScene';\n\n   // 声明入口类\n   class YoDawgApp extends Component {\n     // 绘制界面，通过加载 MyScene\n     render() {\n       return (\n         // 创建一个Navigator 并嵌套 MyScene\n         <Navigator\n            initialRoute={{ title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) => {\n              return <MyScene title={route.title} \n                 // push操作调用函数\n                  onForward={ () => {\n                    const nextIndex = route.index + 1;\n                    navigator.push({\n                       title: 'Scene ' + nextIndex,\n                       index: nextIndex,\n                    });\n                  }}\n     \n                 // pop操作调用函数\n                  onBack={ () => {\n                    if (route.index > 0) {\n                      navigator.pop();\n                    }\n                  }}\n              />\n            }}\n         />\n       )\n     }\n   }\n   // 注册入口类\n   AppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n   ```\n\n   现在我们在`MyScene.js` 里添加上点击事件，并调用`onForward`和`onBack`方法看看会有怎样的效果\n\n   ```javascript\n   // 导入需要使用的组件\n   import React, { Component } from 'react';\n   import { View, Text, Navigator, TouchableHighlight } from 'react-native';\n\n   // 声明MyScene类，并设置为外部可以引用\n   export default class MyScene extends Component {\n     static get defaultProps() {\n       return {\n         title: 'MyScene'\n       };\n     }\n\n     // 绘制界面\n     render() {\n       return (\n         <View style={{height: 200, top: 64}}>\n           <Text>Hi! My name is {this.props.title}.</Text>\n         // 添加两个可点击区域，分别用于push和pop\n           <TouchableHighlight onPress={this.props.onForward}>\n              <Text>Tap me to load the next scene</Text>\n           </TouchableHighlight>\n           <TouchableHighlight onPress={this.props.onBack}>\n              <Text>Tap me to go back</Text>\n           </TouchableHighlight>\n         </View>\n       )\n     }\n   }\n\n   MyScene.propTypes = {\n     title: PropTypes.string.isRequired,\n     onForward: PropTypes.func.isRequired,\n     onBack: PropTypes.func.isRequired,\n   };\n   ```\n\n   再次运行项目看一下效果：\n\n   ![React-Native之Navigator_3.png](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_3.png)\n\n   点击`Tap me to load the next scene`能够push下一个页面\n\n   点击`Tap me to go back`能够pop到上一个页面\n\n   看来我们已经顺利集成了`Navigator` ,不过，似乎还缺少什么？\n\n4. 显示Navigator Bar\n\n   通过上述操作我们能够正常实现`Navigator` 的`push` 和`pop` 操作啦，但是，我们一直没有看到导航栏，这是因为在`React Native`中我们需要额外设置才能够展现`Navigator Bar` ，下面就让我们来继续修改`index.ios.js`\n\n   ```javascript\n   // 导入需要用到的组件\n   import React, { Component } from 'react';\n   import { AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity } from 'react-native';\n\n   // 导入需要引用的文件\n   import MyScene from './MyScene';\n\n   // 声明入口类\n   class YoDawgApp extends Component {\n     // 绘制界面，通过加载 MyScene\n     render() {\n       return (\n         // 创建一个Navigator 并嵌套 MyScene\n         <Navigator\n            initialRoute={{ title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) => {\n              return <MyScene title={route.title} \n                 // push操作调用函数\n                  onForward={ () => {\n                    const nextIndex = route.index + 1;\n                    navigator.push({\n                       title: 'Scene ' + nextIndex,\n                       index: nextIndex,\n                    });\n                  }}\n     \n                 // pop操作调用函数\n                  onBack={ () => {\n                    if (route.index > 0) {\n                      navigator.pop();\n                    }\n                  }}\n              />\n            }}\n            // 增加navigationBar\n             navigationBar={\n                     \t<Navigator.NavigationBar\n                          routeMapper={NavigationBarRouteMapper}\n                          style={{backgroundColor:'#fff',\n                                  borderColor:'#dddddd',\n                                  borderWidth:1,\n                                  height: 64}}\n                     \t/>\n            }\n         />\n       )\n     }\n   }\n\n   // 导航栏的Mapper\n   var NavigationBarRouteMapper = {\n     // 左键\n     LeftButton(route, navigator, index, navState) {\n       if (index > 0) {\n         return (\n           <View style={styles.navContainer}>\n             <TouchableOpacity\n               underlayColor='transparent'\n               onPress={() => {if (index > 0) {navigator.pop()}}}>\n               <Text style={styles.leftNavButtonText}>\n                 后退\n               </Text>\n             </TouchableOpacity>\n           </View>\n         );\n       } else {\n         return null;\n       }\n     },\n     // 右键\n     RightButton(route, navigator, index, navState) {\n       if (route.onPress)\n         return (\n           <View style={styles.navContainer}>\n             <TouchableOpacity\n               onPress={() => route.onPress()}>\n               <Text style={styles.rightNavButtonText}>\n                 {route.rightText || '右键'}\n               </Text>\n             </TouchableOpacity>\n           </View>\n         );\n     },\n     // 标题\n     Title(route, navigator, index, navState) {\n       return (\n         <View style={styles.navContainer}>\n           <Text style={styles.title}>\n             应用标题\n           </Text>\n         </View>\n       );\n     }\n   };\n\n   var styles = StyleSheet.create({\n     navBar: {\n         backgroundColor:'#fff',\n         borderColor:'#dddddd',\n         borderWidth:1,\n         height: 64\n     },\n     navBarTitleText: {\n       fontWeight: '500',\n     },\n     navBarLeftButton: {\n       paddingLeft: 5,\n     },\n     navBarRightButton: {\n         marginRight:5,\n     },\n     icon: {\n         width:30,\n         height:30,\n         marginTop:6,\n         textAlign:'center'\n     }\n   });\n\n   // 注册入口类\n   AppRegistry.registerComponent('YoDawgApp', () => YoDawgApp);\n   ```\n\n   我们来最后看一下效果：\n\n   ![React-Native之Navigator_4](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_4.png)\n\n   ![React-Native之Navigator_5](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_5.png)\n\n   ​\n\n","slug":"React-Native之Navigator","published":1,"updated":"2018-08-31T09:54:28.549Z","_id":"cjlhoqwi10015kj79xvnvl0bs","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"结合官方文档，简单使用Navigator\"><a href=\"#结合官方文档，简单使用Navigator\" class=\"headerlink\" title=\"结合官方文档，简单使用Navigator\"></a>结合官方文档，简单使用Navigator</h4><p>React Native内置了navigation组件，在<a href=\"http://facebook.github.io/react-native/docs/using-navigators.html\" target=\"_blank\" rel=\"external\">官方文档</a>中对于如何使用Navigator有了一个简要的说明，下面就让我们跟随文档进行学习。 </p>\n<ol>\n<li><p>页面搭建</p>\n<p>根据文档的描述，我们需要先创建一个文件命名为<code>MyScene.js</code>，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要使用的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; View, Text, Navigator &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明MyScene类，并设置为外部可以引用</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyScene</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> get defaultProps() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">'MyScene'</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 绘制界面</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style=&#123;&#123;height: 200, top: 64&#125;&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Hi! My name is &#123;this.props.title&#125;.&lt;/Text&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>​      创建完<code>MyScene.js</code>后我们就需要进入到<code>index.ios.js</code>中进行更改。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;MyScene /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>​      进行上述操作后运行项目来看一下效果：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_1.png\" alt=\"React-Native之Navigator_1\"></p>\n<p>显然，跟我们想要的效果差很远。       </p>\n<ol>\n<li><p>使用Navigator</p>\n<p>接下来我们就需要利用<code>Navigator</code>组件，修改<code>index.ios.js</code>文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"comment\">// 创建一个Navigator 并嵌套 MyScene</span></div><div class=\"line\">      &lt;Navigator</div><div class=\"line\">         initialRoute=&#123;&#123; <span class=\"attr\">title</span>: <span class=\"string\">'My Initial Scene'</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>&#125;&#125;</div><div class=\"line\">         renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class=\"line\">         &#125;&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>进行上述操作后我们再次运行项目：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_2.png\" alt=\"React-Native之Navigator_2.png\"></p>\n<p>比较两次的运行结果，似乎只是文案内容发生了改变，让我们继续下去看到更多的变化</p>\n</li>\n<li><p>加入<code>push</code> <code>pop</code> </p>\n<p><code>navigator</code>给我们提供了<code>push</code> <code>pop</code> 操作，我们来继续修改<code>index.ios.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"comment\">// 创建一个Navigator 并嵌套 MyScene</span></div><div class=\"line\">      &lt;Navigator</div><div class=\"line\">         initialRoute=&#123;&#123; <span class=\"attr\">title</span>: <span class=\"string\">'My Initial Scene'</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>&#125;&#125;</div><div class=\"line\">         renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> &lt;MyScene title=&#123;route.title&#125; </div><div class=\"line\">              // push操作调用函数</div><div class=\"line\">               onForward=&#123; () =&gt; &#123;</div><div class=\"line\">                 const nextIndex = route.index + 1;</div><div class=\"line\">                 navigator.push(&#123;</div><div class=\"line\">                    title: 'Scene ' + nextIndex,</div><div class=\"line\">                    index: nextIndex,</div><div class=\"line\">                 &#125;);</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">  </div><div class=\"line\">              // pop操作调用函数</div><div class=\"line\">               onBack=&#123; () =&gt; &#123;</div><div class=\"line\">                 if (route.index &gt; 0) &#123;</div><div class=\"line\">                   navigator.pop();</div><div class=\"line\">                 &#125;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div><div class=\"line\">         &#125;&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>现在我们在<code>MyScene.js</code> 里添加上点击事件，并调用<code>onForward</code>和<code>onBack</code>方法看看会有怎样的效果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要使用的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; View, Text, Navigator, TouchableHighlight &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明MyScene类，并设置为外部可以引用</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyScene</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> get defaultProps() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">'MyScene'</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 绘制界面</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style=&#123;&#123;height: 200, top: 64&#125;&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Hi! My name is &#123;this.props.title&#125;.&lt;/Text&gt;</div><div class=\"line\">      // 添加两个可点击区域，分别用于push和pop</div><div class=\"line\">        &lt;TouchableHighlight onPress=&#123;this.props.onForward&#125;&gt;</div><div class=\"line\">           &lt;Text&gt;Tap me to load the next scene&lt;/Text&gt;</div><div class=\"line\">        &lt;/TouchableHighlight&gt;</div><div class=\"line\">        &lt;TouchableHighlight onPress=&#123;this.props.onBack&#125;&gt;</div><div class=\"line\">           &lt;Text&gt;Tap me to go back&lt;/Text&gt;</div><div class=\"line\">        &lt;/TouchableHighlight&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyScene.propTypes = &#123;</div><div class=\"line\">  <span class=\"attr\">title</span>: PropTypes.string.isRequired,</div><div class=\"line\">  <span class=\"attr\">onForward</span>: PropTypes.func.isRequired,</div><div class=\"line\">  <span class=\"attr\">onBack</span>: PropTypes.func.isRequired,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>再次运行项目看一下效果：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_3.png\" alt=\"React-Native之Navigator_3.png\"></p>\n<p>点击<code>Tap me to load the next scene</code>能够push下一个页面</p>\n<p>点击<code>Tap me to go back</code>能够pop到上一个页面</p>\n<p>看来我们已经顺利集成了<code>Navigator</code> ,不过，似乎还缺少什么？</p>\n</li>\n<li><p>显示Navigator Bar</p>\n<p>通过上述操作我们能够正常实现<code>Navigator</code> 的<code>push</code> 和<code>pop</code> 操作啦，但是，我们一直没有看到导航栏，这是因为在<code>React Native</code>中我们需要额外设置才能够展现<code>Navigator Bar</code> ，下面就让我们来继续修改<code>index.ios.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"comment\">// 创建一个Navigator 并嵌套 MyScene</span></div><div class=\"line\">      &lt;Navigator</div><div class=\"line\">         initialRoute=&#123;&#123; <span class=\"attr\">title</span>: <span class=\"string\">'My Initial Scene'</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>&#125;&#125;</div><div class=\"line\">         renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> &lt;MyScene title=&#123;route.title&#125; </div><div class=\"line\">              // push操作调用函数</div><div class=\"line\">               onForward=&#123; () =&gt; &#123;</div><div class=\"line\">                 const nextIndex = route.index + 1;</div><div class=\"line\">                 navigator.push(&#123;</div><div class=\"line\">                    title: 'Scene ' + nextIndex,</div><div class=\"line\">                    index: nextIndex,</div><div class=\"line\">                 &#125;);</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">  </div><div class=\"line\">              // pop操作调用函数</div><div class=\"line\">               onBack=&#123; () =&gt; &#123;</div><div class=\"line\">                 if (route.index &gt; 0) &#123;</div><div class=\"line\">                   navigator.pop();</div><div class=\"line\">                 &#125;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div><div class=\"line\">         &#125;&#125;</div><div class=\"line\">         // 增加navigationBar</div><div class=\"line\">          navigationBar=&#123;</div><div class=\"line\">                  \t&lt;Navigator.NavigationBar</div><div class=\"line\">                       routeMapper=&#123;NavigationBarRouteMapper&#125;</div><div class=\"line\">                       style=&#123;&#123;backgroundColor:'#fff',</div><div class=\"line\">                               borderColor:'#dddddd',</div><div class=\"line\">                               borderWidth:1,</div><div class=\"line\">                               height: 64&#125;&#125;</div><div class=\"line\">                  \t/&gt;</div><div class=\"line\">         &#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 导航栏的Mapper</div><div class=\"line\">var NavigationBarRouteMapper = &#123;</div><div class=\"line\">  // 左键</div><div class=\"line\">  LeftButton(route, navigator, index, navState) &#123;</div><div class=\"line\">    if (index &gt; 0) &#123;</div><div class=\"line\">      return (</div><div class=\"line\">        &lt;View style=&#123;styles.navContainer&#125;&gt;</div><div class=\"line\">          &lt;TouchableOpacity</div><div class=\"line\">            underlayColor='transparent'</div><div class=\"line\">            onPress=&#123;() =&gt; &#123;if (index &gt; 0) &#123;navigator.pop()&#125;&#125;&#125;&gt;</div><div class=\"line\">            &lt;Text style=&#123;styles.leftNavButtonText&#125;&gt;</div><div class=\"line\">              后退</div><div class=\"line\">            &lt;/Text&gt;</div><div class=\"line\">          &lt;/TouchableOpacity&gt;</div><div class=\"line\">        &lt;/View&gt;</div><div class=\"line\">      );</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 右键</div><div class=\"line\">  RightButton(route, navigator, index, navState) &#123;</div><div class=\"line\">    if (route.onPress)</div><div class=\"line\">      return (</div><div class=\"line\">        &lt;View style=&#123;styles.navContainer&#125;&gt;</div><div class=\"line\">          &lt;TouchableOpacity</div><div class=\"line\">            onPress=&#123;() =&gt; route.onPress()&#125;&gt;</div><div class=\"line\">            &lt;Text style=&#123;styles.rightNavButtonText&#125;&gt;</div><div class=\"line\">              &#123;route.rightText || '右键'&#125;</div><div class=\"line\">            &lt;/Text&gt;</div><div class=\"line\">          &lt;/TouchableOpacity&gt;</div><div class=\"line\">        &lt;/View&gt;</div><div class=\"line\">      );</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 标题</div><div class=\"line\">  Title(route, navigator, index, navState) &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;styles.navContainer&#125;&gt;</div><div class=\"line\">        &lt;Text style=&#123;styles.title&#125;&gt;</div><div class=\"line\">          应用标题</div><div class=\"line\">        &lt;/Text&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var styles = StyleSheet.create(&#123;</div><div class=\"line\">  navBar: &#123;</div><div class=\"line\">      backgroundColor:'#fff',</div><div class=\"line\">      borderColor:'#dddddd',</div><div class=\"line\">      borderWidth:1,</div><div class=\"line\">      height: 64</div><div class=\"line\">  &#125;,</div><div class=\"line\">  navBarTitleText: &#123;</div><div class=\"line\">    fontWeight: '500',</div><div class=\"line\">  &#125;,</div><div class=\"line\">  navBarLeftButton: &#123;</div><div class=\"line\">    paddingLeft: 5,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  navBarRightButton: &#123;</div><div class=\"line\">      marginRight:5,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  icon: &#123;</div><div class=\"line\">      width:30,</div><div class=\"line\">      height:30,</div><div class=\"line\">      marginTop:6,</div><div class=\"line\">      textAlign:'center'</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>我们来最后看一下效果：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_4.png\" alt=\"React-Native之Navigator_4\"></p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_5.png\" alt=\"React-Native之Navigator_5\"></p>\n<p>​</p>\n</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"结合官方文档，简单使用Navigator\"><a href=\"#结合官方文档，简单使用Navigator\" class=\"headerlink\" title=\"结合官方文档，简单使用Navigator\"></a>结合官方文档，简单使用Navigator</h4><p>React Native内置了navigation组件，在<a href=\"http://facebook.github.io/react-native/docs/using-navigators.html\">官方文档</a>中对于如何使用Navigator有了一个简要的说明，下面就让我们跟随文档进行学习。 </p>\n<ol>\n<li><p>页面搭建</p>\n<p>根据文档的描述，我们需要先创建一个文件命名为<code>MyScene.js</code>，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要使用的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; View, Text, Navigator &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明MyScene类，并设置为外部可以引用</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyScene</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> get defaultProps() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">'MyScene'</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 绘制界面</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style=&#123;&#123;height: 200, top: 64&#125;&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Hi! My name is &#123;this.props.title&#125;.&lt;/Text&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>​      创建完<code>MyScene.js</code>后我们就需要进入到<code>index.ios.js</code>中进行更改。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;MyScene /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>​      进行上述操作后运行项目来看一下效果：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_1.png\" alt=\"React-Native之Navigator_1\"></p>\n<p>显然，跟我们想要的效果差很远。       </p>\n<ol>\n<li><p>使用Navigator</p>\n<p>接下来我们就需要利用<code>Navigator</code>组件，修改<code>index.ios.js</code>文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"comment\">// 创建一个Navigator 并嵌套 MyScene</span></div><div class=\"line\">      &lt;Navigator</div><div class=\"line\">         initialRoute=&#123;&#123; <span class=\"attr\">title</span>: <span class=\"string\">'My Initial Scene'</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>&#125;&#125;</div><div class=\"line\">         renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class=\"line\">         &#125;&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>进行上述操作后我们再次运行项目：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_2.png\" alt=\"React-Native之Navigator_2.png\"></p>\n<p>比较两次的运行结果，似乎只是文案内容发生了改变，让我们继续下去看到更多的变化</p>\n</li>\n<li><p>加入<code>push</code> <code>pop</code> </p>\n<p><code>navigator</code>给我们提供了<code>push</code> <code>pop</code> 操作，我们来继续修改<code>index.ios.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"comment\">// 创建一个Navigator 并嵌套 MyScene</span></div><div class=\"line\">      &lt;Navigator</div><div class=\"line\">         initialRoute=&#123;&#123; <span class=\"attr\">title</span>: <span class=\"string\">'My Initial Scene'</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>&#125;&#125;</div><div class=\"line\">         renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> &lt;MyScene title=&#123;route.title&#125; </div><div class=\"line\">              // push操作调用函数</div><div class=\"line\">               onForward=&#123; () =&gt; &#123;</div><div class=\"line\">                 const nextIndex = route.index + 1;</div><div class=\"line\">                 navigator.push(&#123;</div><div class=\"line\">                    title: 'Scene ' + nextIndex,</div><div class=\"line\">                    index: nextIndex,</div><div class=\"line\">                 &#125;);</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">  </div><div class=\"line\">              // pop操作调用函数</div><div class=\"line\">               onBack=&#123; () =&gt; &#123;</div><div class=\"line\">                 if (route.index &gt; 0) &#123;</div><div class=\"line\">                   navigator.pop();</div><div class=\"line\">                 &#125;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div><div class=\"line\">         &#125;&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>现在我们在<code>MyScene.js</code> 里添加上点击事件，并调用<code>onForward</code>和<code>onBack</code>方法看看会有怎样的效果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要使用的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; View, Text, Navigator, TouchableHighlight &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明MyScene类，并设置为外部可以引用</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyScene</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> get defaultProps() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">'MyScene'</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 绘制界面</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style=&#123;&#123;height: 200, top: 64&#125;&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Hi! My name is &#123;this.props.title&#125;.&lt;/Text&gt;</div><div class=\"line\">      // 添加两个可点击区域，分别用于push和pop</div><div class=\"line\">        &lt;TouchableHighlight onPress=&#123;this.props.onForward&#125;&gt;</div><div class=\"line\">           &lt;Text&gt;Tap me to load the next scene&lt;/Text&gt;</div><div class=\"line\">        &lt;/TouchableHighlight&gt;</div><div class=\"line\">        &lt;TouchableHighlight onPress=&#123;this.props.onBack&#125;&gt;</div><div class=\"line\">           &lt;Text&gt;Tap me to go back&lt;/Text&gt;</div><div class=\"line\">        &lt;/TouchableHighlight&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyScene.propTypes = &#123;</div><div class=\"line\">  <span class=\"attr\">title</span>: PropTypes.string.isRequired,</div><div class=\"line\">  <span class=\"attr\">onForward</span>: PropTypes.func.isRequired,</div><div class=\"line\">  <span class=\"attr\">onBack</span>: PropTypes.func.isRequired,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>再次运行项目看一下效果：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_3.png\" alt=\"React-Native之Navigator_3.png\"></p>\n<p>点击<code>Tap me to load the next scene</code>能够push下一个页面</p>\n<p>点击<code>Tap me to go back</code>能够pop到上一个页面</p>\n<p>看来我们已经顺利集成了<code>Navigator</code> ,不过，似乎还缺少什么？</p>\n</li>\n<li><p>显示Navigator Bar</p>\n<p>通过上述操作我们能够正常实现<code>Navigator</code> 的<code>push</code> 和<code>pop</code> 操作啦，但是，我们一直没有看到导航栏，这是因为在<code>React Native</code>中我们需要额外设置才能够展现<code>Navigator Bar</code> ，下面就让我们来继续修改<code>index.ios.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入需要用到的组件</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry, Navigator, Text, StyleSheet, View, TouchableOpacity &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入需要引用的文件</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyScene <span class=\"keyword\">from</span> <span class=\"string\">'./MyScene'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明入口类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YoDawgApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 绘制界面，通过加载 MyScene</span></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"comment\">// 创建一个Navigator 并嵌套 MyScene</span></div><div class=\"line\">      &lt;Navigator</div><div class=\"line\">         initialRoute=&#123;&#123; <span class=\"attr\">title</span>: <span class=\"string\">'My Initial Scene'</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>&#125;&#125;</div><div class=\"line\">         renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span> &lt;MyScene title=&#123;route.title&#125; </div><div class=\"line\">              // push操作调用函数</div><div class=\"line\">               onForward=&#123; () =&gt; &#123;</div><div class=\"line\">                 const nextIndex = route.index + 1;</div><div class=\"line\">                 navigator.push(&#123;</div><div class=\"line\">                    title: 'Scene ' + nextIndex,</div><div class=\"line\">                    index: nextIndex,</div><div class=\"line\">                 &#125;);</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">  </div><div class=\"line\">              // pop操作调用函数</div><div class=\"line\">               onBack=&#123; () =&gt; &#123;</div><div class=\"line\">                 if (route.index &gt; 0) &#123;</div><div class=\"line\">                   navigator.pop();</div><div class=\"line\">                 &#125;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div><div class=\"line\">         &#125;&#125;</div><div class=\"line\">         // 增加navigationBar</div><div class=\"line\">          navigationBar=&#123;</div><div class=\"line\">                  \t&lt;Navigator.NavigationBar</div><div class=\"line\">                       routeMapper=&#123;NavigationBarRouteMapper&#125;</div><div class=\"line\">                       style=&#123;&#123;backgroundColor:'#fff',</div><div class=\"line\">                               borderColor:'#dddddd',</div><div class=\"line\">                               borderWidth:1,</div><div class=\"line\">                               height: 64&#125;&#125;</div><div class=\"line\">                  \t/&gt;</div><div class=\"line\">         &#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 导航栏的Mapper</div><div class=\"line\">var NavigationBarRouteMapper = &#123;</div><div class=\"line\">  // 左键</div><div class=\"line\">  LeftButton(route, navigator, index, navState) &#123;</div><div class=\"line\">    if (index &gt; 0) &#123;</div><div class=\"line\">      return (</div><div class=\"line\">        &lt;View style=&#123;styles.navContainer&#125;&gt;</div><div class=\"line\">          &lt;TouchableOpacity</div><div class=\"line\">            underlayColor='transparent'</div><div class=\"line\">            onPress=&#123;() =&gt; &#123;if (index &gt; 0) &#123;navigator.pop()&#125;&#125;&#125;&gt;</div><div class=\"line\">            &lt;Text style=&#123;styles.leftNavButtonText&#125;&gt;</div><div class=\"line\">              后退</div><div class=\"line\">            &lt;/Text&gt;</div><div class=\"line\">          &lt;/TouchableOpacity&gt;</div><div class=\"line\">        &lt;/View&gt;</div><div class=\"line\">      );</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 右键</div><div class=\"line\">  RightButton(route, navigator, index, navState) &#123;</div><div class=\"line\">    if (route.onPress)</div><div class=\"line\">      return (</div><div class=\"line\">        &lt;View style=&#123;styles.navContainer&#125;&gt;</div><div class=\"line\">          &lt;TouchableOpacity</div><div class=\"line\">            onPress=&#123;() =&gt; route.onPress()&#125;&gt;</div><div class=\"line\">            &lt;Text style=&#123;styles.rightNavButtonText&#125;&gt;</div><div class=\"line\">              &#123;route.rightText || '右键'&#125;</div><div class=\"line\">            &lt;/Text&gt;</div><div class=\"line\">          &lt;/TouchableOpacity&gt;</div><div class=\"line\">        &lt;/View&gt;</div><div class=\"line\">      );</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 标题</div><div class=\"line\">  Title(route, navigator, index, navState) &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;styles.navContainer&#125;&gt;</div><div class=\"line\">        &lt;Text style=&#123;styles.title&#125;&gt;</div><div class=\"line\">          应用标题</div><div class=\"line\">        &lt;/Text&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var styles = StyleSheet.create(&#123;</div><div class=\"line\">  navBar: &#123;</div><div class=\"line\">      backgroundColor:'#fff',</div><div class=\"line\">      borderColor:'#dddddd',</div><div class=\"line\">      borderWidth:1,</div><div class=\"line\">      height: 64</div><div class=\"line\">  &#125;,</div><div class=\"line\">  navBarTitleText: &#123;</div><div class=\"line\">    fontWeight: '500',</div><div class=\"line\">  &#125;,</div><div class=\"line\">  navBarLeftButton: &#123;</div><div class=\"line\">    paddingLeft: 5,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  navBarRightButton: &#123;</div><div class=\"line\">      marginRight:5,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  icon: &#123;</div><div class=\"line\">      width:30,</div><div class=\"line\">      height:30,</div><div class=\"line\">      marginTop:6,</div><div class=\"line\">      textAlign:'center'</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 注册入口类</div><div class=\"line\">AppRegistry.registerComponent('YoDawgApp', () =&gt; YoDawgApp);</div></pre></td></tr></table></figure>\n<p>我们来最后看一下效果：</p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_4.png\" alt=\"React-Native之Navigator_4\"></p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/ReactNative/React-Native之Navigator_5.png\" alt=\"React-Native之Navigator_5\"></p>\n<p>​</p>\n</li>\n</ol>\n"},{"title":"Swift开源项目ObjectMapper实践","date":"2017-07-20T09:42:00.000Z","_content":"近期项目打算全面向swift迁移，虽然两三年前有写过swift项目但是很长时间没有开发很多知识点已经模糊，最近打算就热门的几个第三方库的使用方法进行一个调研\n\n今天就先从[ObjectMapper](https://github.com/Hearst-DD/ObjectMapper)入手，ObjectMapper是一个由swift写的json和模型转换的开源库，目前已经有5950个star\n\n### 先从官方文档入手，进行一个简单的介绍\n\n##### 支持的功能\n- JSON向模型的转换\n- 模型向JSON的转换\n- 嵌套结构的解析\n- mapping时的自定义转换\n- 结构体的支持\n\n##### 基础用法\nObjectMapper中定义了一个协议[Mappable](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mappable.swift)\n\nMappable协议中声明了两个方法\n\n```\nmutation func mapping(map: Map)\n\ninit?(map: Map)\n```\n\n我们需要在模型中遵循这个协议，官方给出了一个参考：\n```\nclass User: Mappable {\n    var username: String?\n    var age: Int?\n    var weight: Double!\n    var array: [Any]?\n    var dictionary: [String : Any] = [:]\n    var bestFriend: User?                       // Nested User object\n    var friends: [User]?                        // Array of Users\n    var birthday: Date?\n\n    required init?(map: Map) {\n\n    }\n\n    // Mappable\n    func mapping(map: Map) {\n        username    <- map[\"username\"]\n        age         <- map[\"age\"]\n        weight      <- map[\"weight\"]\n        array       <- map[\"arr\"]\n        dictionary  <- map[\"dict\"]\n        bestFriend  <- map[\"best_friend\"]\n        friends     <- map[\"friends\"]\n        birthday    <- (map[\"birthday\"], DateTransform())\n    }\n}\n\nstruct Temperature: Mappable {\n    var celsius: Double?\n    var fahrenheit: Double?\n\n    init?(map: Map) {\n\n    }\n\n    mutating func mapping(map: Map) {\n        celsius     <- map[\"celsius\"]\n        fahrenheit  <- map[\"fahrenheit\"]\n    }\n}\n```\n\n一旦我们的类或结构体如上面的示例一样实现了协议，我们就可以方便的进行JSON和模型之间的转换\n\n```\nlet user = User(JSONString: JSONString)\n\nlet JSONString = user.toJSONString(prettyPrint: true)\n```\n当然也可以通过[Mapper](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift)类来进行转换\n\n```\nlet user = Mapper<User>().map(JSONString: JSONString)\n\nlet JSONString = Mapper().toJSONString(user, prettyPrint: true)\n```\n\n##### 嵌套对象的映射\n\n正如前面所列，ObjectMapper支持嵌套对象的映射\n\n列如：\n```\n{\n    \"distance\" : {\n        \"text\" : \"102\",\n        \"value\" : 31\n    }\n}\n```\n我们想要直接取出distance对象中的value值，可以设置如下mapping\n```\nfunc mapping(map: Map) {\n    distance <- map[\"distance.value\"]\n}\n```\n\n##### 自定义转换规则\n\nObjectMapper允许开发者在数据映射过程中指定转换规则\n\n```\nclass People: Mappable {\n   var birthday: NSDate?\n   \n   required init?(_ map: Map) {\n       \n   }\n   \n   func mapping(map: Map) {\n       birthday <- (map[\"birthday\"], DateTransform())\n   }\n   \n   let JSON = \"\\\"birthday\\\":1458117795332\"\n   let result = Mapper<People>().map(JSON)\n}\n\n```\n由于我们指定了`birthday`的转换规则，所以上述代码在解析JSON数据的时候会将long类型转换成Date类型\n\n除了使用ObjectMapper给我们提供的转换规则外，我们还可以通过实现[TransformType](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformType.swift)协议来自定义我们的转换规则\n\n```\npublic protocol TransformType {\n    typealias Object\n    typealias JSON\n    \n    func transformFromJSON(value: AnyObject?) -> Object?\n    func transformToJSON(value: Object?) -> JSON?\n}\n```\nObjectMapper为我们提供了一个[TransformOf](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformOf.swift)类来实现转换结果，TransformOf实际就是实现了TransformType协议的，TransformOf有两个类型的参数和两个闭包参数，类型表示参与转换的数据的类型，闭包表示转换的规则\n\n```\nlet transform = TransformOf<Int, String>(fromJSON: { (value: String?) -> Int? in \n}, toJSON: { (value: Int?) -> String? in \n  // transform value from Int? to String?\n  if let value = value {\n      return String(value)\n  }\n  return nil\n})\n\nid <- (map[\"id\"], transform)\n```\n\n##### 泛型对象\n\nObjectMapper同样可以处理泛型类型的参数，不过这个泛型类型需要在实现了Mappable协议的基础上才可以正常使用\n\n```\nclass User: Mappable {\n    var name: String?\n    \n    required init?(_ map: Map) {\n        \n    }\n    \n    func mapping(_ map: Map) {\n        name <- map[\"name\"]\n    }\n}\n\nclass Result<T: Mappable>: Mappable {\n    var result: T?\n    \n    required init?(_ map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        result <- map[\"result\"]\n    }\n}\n\nlet JSON = \"{\\\"result\\\": {\\\"name\\\": \\\"anenn\\\"}}\"\nlet result = Mapper<Result<User>>().map(JSON)\n```\n\n### 原理解析\n\nObjectMapper声明了一个Mappable协议，这个协议里声明了两个方法\n```\ninit?(map: Map)\n\nmutating func mapping(map: Map)\n```\n并且通过对Mappable协议的扩展，增加了JSON和模型之间的四个转换方法\n```\npublic extension BaseMappable {\n    \n    /// Initializes object from a JSON String\n    public init?(JSONString: String, context: MapContext? = nil) {\n        if let obj: Self = Mapper(context: context).map(JSONString: JSONString) {\n            self = obj\n        } else {\n            return nil\n        }\n    }\n    \n    /// Initializes object from a JSON Dictionary\n    public init?(JSON: [String: Any], context: MapContext? = nil) {\n        if let obj: Self = Mapper(context: context).map(JSON: JSON) {\n            self = obj\n        } else {\n            return nil\n        }\n    }\n    \n    /// Returns the JSON Dictionary for the object\n    public func toJSON() -> [String: Any] {\n        return Mapper().toJSON(self)\n    }\n    \n    /// Returns the JSON String for the object\n    public func toJSONString(prettyPrint: Bool = false) -> String? {\n        return Mapper().toJSONString(self, prettyPrint: prettyPrint)\n    }\n}\n\n```\n我们在使用ObjectMapper进行转换时，首先需要让模型遵循Mappable协议，并且实现Mappable声明的两个方法\n\n```\nclass User: Mappable {\n    var username: String?\n    var age: Int?\n\n    required init?(map: Map) {\n\n    }\n\n    // Mappable\n    func mapping(map: Map) {\n        username    <- map[\"username\"]\n        age         <- map[\"age\"]\n    }\n}\n```\n因为ObjectMapper为Mappable增加了四个转换方法，所以User也继承了这四个转换方法\n\n```\nlet user = User(JSONString: JSONString)\n```\n这个方法的调用其实就是帮助我们执行了\n```\nMapper().map(JSONString: JSONString)\n```\n因此，我们也可以直接通过如下方法进行转换\n```\nlet user = Mapper<User>().map(JSONString: JSONString)\n```\n接下来就是ObjectMapper的核心啦~\n为什么通过Mapper类能完成转换呢？\n\n我们来逐步了解[Mapper](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift)的实现原理\n\n```\npublic final class Mapper<N: BaseMappable> {\n    \n}\n```\n正如上面的代码块所示，首先Mapper类定义了一个泛型N，N必须要遵循Mappable协议，也就是我们的模型User\n继续往下看，我们选择一个常用的方法\n```\npublic func map(JSONString: String) -> N? {\n        if let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) {\n            return map(JSON: JSON)\n        }\n        \n        return nil\n    }\n```\n没错，我们前面写的Mapper的转换方法正是使用的这个方法\n```\nMapper().map(JSONString: JSONString)\n```\n那我们就来一层一层详细分析一下这个方法的内部实现吧\n\n```\n// 1. 调用Mapper的静态方法parseJSONStringIntoDictionary来将JSON转换成字典\n// 2. 调用map方法将转换后的字典转换成模型并返回\nif let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) {\n            return map(JSON: JSON)\n        }\n        \n        return nil\n```\n先分解`parseJSONStringIntoDictionary`的实现\n\n```\n/// Convert a JSON String into a Dictionary<String, Any> using NSJSONSerialization\n    public static func parseJSONStringIntoDictionary(JSONString: String) -> [String: Any]? {\n        let parsedJSON: Any? = Mapper.parseJSONString(JSONString: JSONString)\n        return parsedJSON as? [String: Any]\n    }\n\n    /// Convert a JSON String into an Object using NSJSONSerialization\n    public static func parseJSONString(JSONString: String) -> Any? {\n        let data = JSONString.data(using: String.Encoding.utf8, allowLossyConversion: true)\n        if let data = data {\n            let parsedJSON: Any?\n            do {\n                parsedJSON = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.allowFragments)\n            } catch let error {\n                print(error)\n                parsedJSON = nil\n            }\n            return parsedJSON\n        }\n\n        return nil\n    }\n\n```\n通过上述代码的逻辑不难发现，`parseJSONStringIntoDictionary`就是利用了系统的`JSONSerialization`将JSON字符串转换成字典\n\n理解了第一步，接下来我们就来看看第二步的实现原理\n\n我们先整体看一下map方法的实现代码\n\n```\n/// Maps a JSON dictionary to an object that conforms to Mappable\n    public func map(JSON: [String: Any]) -> N? {\n        let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)\n        \n        if let klass = N.self as? StaticMappable.Type { // Check if object is StaticMappable\n            if var object = klass.objectForMapping(map: map) as? N {\n                object.mapping(map: map)\n                return object\n            }\n        } else if let klass = N.self as? Mappable.Type { // Check if object is Mappable\n            if var object = klass.init(map: map) as? N {\n                object.mapping(map: map)\n                return object\n            }\n        } else if let klass = N.self as? ImmutableMappable.Type { // Check if object is ImmutableMappable\n            do {\n                return try klass.init(map: map) as? N\n            } catch let error {\n                #if DEBUG\n                let exception: NSException\n                if let mapError = error as? MapError {\n                    exception = NSException(name: .init(rawValue: \"MapError\"), reason: mapError.description, userInfo: nil)\n                } else {\n                    exception = NSException(name: .init(rawValue: \"ImmutableMappableError\"), reason: error.localizedDescription, userInfo: nil)\n                }\n                exception.raise()\n                #else\n                NSLog(\"\\(error)\")\n                #endif\n            }\n        } else {\n            // Ensure BaseMappable is not implemented directly\n            assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\")\n        }\n        \n        return nil\n    }\n\n```\n我们先忽略掉`StaticMappable`和`ImmutableMappable`这两种协议的处理逻辑，直接关注最重要的`Mappable`协议的实现\n\n```\n// 根据传入的JSON字典等数据创建一个map对象\n\nlet map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)\n\n// 判断要转换成的模型是不是 遵循的Mappable协议\nif let klass = N.self as? Mappable.Type \n\n// 创建一个N类型的对象\nvar object = klass.init(map: map) as? N\n\n// 获取模型中定义的解析规则，完成解析\nobject.mapping(map: map)\n\n// 返回生成好的模型\nreturn object\n```\n这里还留了一个疑问，为何执行完`object.mapping(map: map)`后，模型就能完成解析呢\n\n继续分析[Map]((https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift)类\n\n原来在Map类中使用了`subscript`来自定义下标\n同样我们直接来分析最重要的那个自定义下标的方法\n```\npublic subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -> Map {\n        // save key and value associated to it\n        currentKey = key\n        keyIsNested = nested\n        nestedKeyDelimiter = delimiter\n        \n        if mappingType == .fromJSON {\n            // check if a value exists for the current key\n            // do this pre-check for performance reasons\n            if nested == false {\n                let object = JSON[key]\n                let isNSNull = object is NSNull\n                isKeyPresent = isNSNull ? true : object != nil\n                currentValue = isNSNull ? nil : object\n            } else {\n                // break down the components of the key that are separated by .\n                (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON)\n            }\n            \n            // update isKeyPresent if ignoreNil is true\n            if ignoreNil && currentValue == nil {\n                isKeyPresent = false\n            }\n        }\n        \n        return self\n    }\n\n```\n\n不难发现，在这方法中，我们从JSON字典中根据key获取了value，原来当我们调用`object.mapping(map: map)`时，就会依次根据我们配置的mapping值获取对应的value\n\n#### ObjectMapper实践\n\n分析完原理，我们还需要能够熟练的运用ObjectMapper来帮助我们完成解析功能，ObjectMapper能够帮助我们处理数据的方法有很多，这里我就先简单跟大家分享几种在项目中常用的方法，我已经将相关的[Demo](https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master)上传到github上，欢迎大家star\n\n###### 解析单一结构的模型\n单一结构的模型解析比较简单，大家了解一下即可\n```\n{\n  \"name\": \"objectmapper\",\n  \"age\": 18,\n  \"nickname\": \"mapper\",\n  \"job\": \"swifter\"\n}\n```\n当我们拿到如上所示的json数据时，只需要创建一个遵循`Mappable`的模型，并配置好解析路径即可\n```\nclass User: Mappable {\n\n    var name: String?\n    var age: Int?\n    var nickname: String?\n    var job: String?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        name <- map[\"name\"]\n        age <- map[\"age\"]\n        nickname <- map[\"nickname\"]\n        job <- map[\"job\"]\n    }\n    \n}\n\n// 使用方法\nlet user = Mapper<User>().map(JSONString: json.rawString()!)\n\n```\n###### 解析模型中嵌套模型的情况\n有时候我们拿到的json数据嵌套了好几层的结构，而我们刚好也需要逐层解析拿到每个模型的数据，下面我就通过一个两层结构给大家演示一下处理的方法\n\n```\n{\n  \"weather\": \"sun\",\n    \"temperature\": {\n        \"celsius\": 70,\n        \"fahrenheit\": 34\n    },\n}\n```\n正如上面的json数据所示，我们需要创建一个weather模型，同时包含一个temperature模型来解析json数据，这时我们就需要运用泛型来帮助我们达到嵌套的目的\n```\nclass Weather<T: Mappable>: Mappable {\n\n    var weather: String?\n    var temperature: T?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        weather <- map[\"weather\"]\n        temperature <- map[\"temperature\"]\n    }\n}\n\nclass Temperature: Mappable {\n    \n    var celsius: Double?\n    var fahrenheit: Double?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        celsius <- map[\"celsius\"]\n        fahrenheit <- map[\"fahrenheit\"]\n    }\n}\n\n// 使用方法如下\nlet weather = Mapper<Weather<Temperature>>().map(JSONString: json.rawString()!)\n\n```\n###### 解析模型中嵌套模型但是我们只需要拿到子模型的属性值\n\n有些json数据嵌套的内容我们不需要分模型来获取，只需要将属性统一到一个模型中使用\n```\n{\n    \"distance\": {\n        \"text\": \"102 ft\",\n        \"value\": 31\n    }\n}\n```\n```\nclass Distance: Mappable {\n    var text: String?\n    var value: Int?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        text <- map[\"distance.text\"]\n        value <- map[\"distance.value\"]\n    }\n\n}\n```\n####### 解析指定的一个数组\n```\n{\n    \"status\": \"200\",\n    \"msg\": \"success\",\n    \"features\": [\n       {\n         \"name\": \"json解析\"\n       },\n       {\n         \"name\": \"模型转换\"\n       },\n       {\n         \"name\": \"数据处理\"\n       },\n       {\n         \"name\": \"mapper进阶\"\n       }\n    ]\n}\n```\n通过我们拿到的返回结果如上面的代码段所示，features是我们真正关心的数据，它是一个数组结构，我们期望能够得到的是一个数组，里面包含若干个feature模型\n\n首先我们必不可少的就是要创建一个Feature模型\n```\nclass Feature: Mappable {\n\n    var name: String?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        name <- map[\"name\"]\n    }\n    \n}\n```\n在解析这个JSON数据时，我们可以忽略掉其他信息，先获取features对应的json数据\n```\nlet featureJson = json[\"features\"];\n```\n然后只需要使用Mapper的高级用法`mapArray`方法即可直接得到数组对象\n```\nlet features = Mapper<Feature>().mapArray(JSONString: featureJson.rawString()!)\n```\n\nObjectMapper的高级用法还有很多，掌握上面的这些用法基本已经可以在项目中使用ObjectMapper达到我们的需求了，后面有时间我会在此博客和[Demo](https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master)基础上更新更多的用法供大家参考\n\n\n\n","source":"_posts/Swift开源项目ObjectMapper实践.md","raw":"title: Swift开源项目ObjectMapper实践\ntags:\n  - Swift\n  - iOS进阶\n  - ''\ncategories:\n  - iOS\ndate: 2017-07-20 17:42:00\n---\n近期项目打算全面向swift迁移，虽然两三年前有写过swift项目但是很长时间没有开发很多知识点已经模糊，最近打算就热门的几个第三方库的使用方法进行一个调研\n\n今天就先从[ObjectMapper](https://github.com/Hearst-DD/ObjectMapper)入手，ObjectMapper是一个由swift写的json和模型转换的开源库，目前已经有5950个star\n\n### 先从官方文档入手，进行一个简单的介绍\n\n##### 支持的功能\n- JSON向模型的转换\n- 模型向JSON的转换\n- 嵌套结构的解析\n- mapping时的自定义转换\n- 结构体的支持\n\n##### 基础用法\nObjectMapper中定义了一个协议[Mappable](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mappable.swift)\n\nMappable协议中声明了两个方法\n\n```\nmutation func mapping(map: Map)\n\ninit?(map: Map)\n```\n\n我们需要在模型中遵循这个协议，官方给出了一个参考：\n```\nclass User: Mappable {\n    var username: String?\n    var age: Int?\n    var weight: Double!\n    var array: [Any]?\n    var dictionary: [String : Any] = [:]\n    var bestFriend: User?                       // Nested User object\n    var friends: [User]?                        // Array of Users\n    var birthday: Date?\n\n    required init?(map: Map) {\n\n    }\n\n    // Mappable\n    func mapping(map: Map) {\n        username    <- map[\"username\"]\n        age         <- map[\"age\"]\n        weight      <- map[\"weight\"]\n        array       <- map[\"arr\"]\n        dictionary  <- map[\"dict\"]\n        bestFriend  <- map[\"best_friend\"]\n        friends     <- map[\"friends\"]\n        birthday    <- (map[\"birthday\"], DateTransform())\n    }\n}\n\nstruct Temperature: Mappable {\n    var celsius: Double?\n    var fahrenheit: Double?\n\n    init?(map: Map) {\n\n    }\n\n    mutating func mapping(map: Map) {\n        celsius     <- map[\"celsius\"]\n        fahrenheit  <- map[\"fahrenheit\"]\n    }\n}\n```\n\n一旦我们的类或结构体如上面的示例一样实现了协议，我们就可以方便的进行JSON和模型之间的转换\n\n```\nlet user = User(JSONString: JSONString)\n\nlet JSONString = user.toJSONString(prettyPrint: true)\n```\n当然也可以通过[Mapper](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift)类来进行转换\n\n```\nlet user = Mapper<User>().map(JSONString: JSONString)\n\nlet JSONString = Mapper().toJSONString(user, prettyPrint: true)\n```\n\n##### 嵌套对象的映射\n\n正如前面所列，ObjectMapper支持嵌套对象的映射\n\n列如：\n```\n{\n    \"distance\" : {\n        \"text\" : \"102\",\n        \"value\" : 31\n    }\n}\n```\n我们想要直接取出distance对象中的value值，可以设置如下mapping\n```\nfunc mapping(map: Map) {\n    distance <- map[\"distance.value\"]\n}\n```\n\n##### 自定义转换规则\n\nObjectMapper允许开发者在数据映射过程中指定转换规则\n\n```\nclass People: Mappable {\n   var birthday: NSDate?\n   \n   required init?(_ map: Map) {\n       \n   }\n   \n   func mapping(map: Map) {\n       birthday <- (map[\"birthday\"], DateTransform())\n   }\n   \n   let JSON = \"\\\"birthday\\\":1458117795332\"\n   let result = Mapper<People>().map(JSON)\n}\n\n```\n由于我们指定了`birthday`的转换规则，所以上述代码在解析JSON数据的时候会将long类型转换成Date类型\n\n除了使用ObjectMapper给我们提供的转换规则外，我们还可以通过实现[TransformType](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformType.swift)协议来自定义我们的转换规则\n\n```\npublic protocol TransformType {\n    typealias Object\n    typealias JSON\n    \n    func transformFromJSON(value: AnyObject?) -> Object?\n    func transformToJSON(value: Object?) -> JSON?\n}\n```\nObjectMapper为我们提供了一个[TransformOf](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformOf.swift)类来实现转换结果，TransformOf实际就是实现了TransformType协议的，TransformOf有两个类型的参数和两个闭包参数，类型表示参与转换的数据的类型，闭包表示转换的规则\n\n```\nlet transform = TransformOf<Int, String>(fromJSON: { (value: String?) -> Int? in \n}, toJSON: { (value: Int?) -> String? in \n  // transform value from Int? to String?\n  if let value = value {\n      return String(value)\n  }\n  return nil\n})\n\nid <- (map[\"id\"], transform)\n```\n\n##### 泛型对象\n\nObjectMapper同样可以处理泛型类型的参数，不过这个泛型类型需要在实现了Mappable协议的基础上才可以正常使用\n\n```\nclass User: Mappable {\n    var name: String?\n    \n    required init?(_ map: Map) {\n        \n    }\n    \n    func mapping(_ map: Map) {\n        name <- map[\"name\"]\n    }\n}\n\nclass Result<T: Mappable>: Mappable {\n    var result: T?\n    \n    required init?(_ map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        result <- map[\"result\"]\n    }\n}\n\nlet JSON = \"{\\\"result\\\": {\\\"name\\\": \\\"anenn\\\"}}\"\nlet result = Mapper<Result<User>>().map(JSON)\n```\n\n### 原理解析\n\nObjectMapper声明了一个Mappable协议，这个协议里声明了两个方法\n```\ninit?(map: Map)\n\nmutating func mapping(map: Map)\n```\n并且通过对Mappable协议的扩展，增加了JSON和模型之间的四个转换方法\n```\npublic extension BaseMappable {\n    \n    /// Initializes object from a JSON String\n    public init?(JSONString: String, context: MapContext? = nil) {\n        if let obj: Self = Mapper(context: context).map(JSONString: JSONString) {\n            self = obj\n        } else {\n            return nil\n        }\n    }\n    \n    /// Initializes object from a JSON Dictionary\n    public init?(JSON: [String: Any], context: MapContext? = nil) {\n        if let obj: Self = Mapper(context: context).map(JSON: JSON) {\n            self = obj\n        } else {\n            return nil\n        }\n    }\n    \n    /// Returns the JSON Dictionary for the object\n    public func toJSON() -> [String: Any] {\n        return Mapper().toJSON(self)\n    }\n    \n    /// Returns the JSON String for the object\n    public func toJSONString(prettyPrint: Bool = false) -> String? {\n        return Mapper().toJSONString(self, prettyPrint: prettyPrint)\n    }\n}\n\n```\n我们在使用ObjectMapper进行转换时，首先需要让模型遵循Mappable协议，并且实现Mappable声明的两个方法\n\n```\nclass User: Mappable {\n    var username: String?\n    var age: Int?\n\n    required init?(map: Map) {\n\n    }\n\n    // Mappable\n    func mapping(map: Map) {\n        username    <- map[\"username\"]\n        age         <- map[\"age\"]\n    }\n}\n```\n因为ObjectMapper为Mappable增加了四个转换方法，所以User也继承了这四个转换方法\n\n```\nlet user = User(JSONString: JSONString)\n```\n这个方法的调用其实就是帮助我们执行了\n```\nMapper().map(JSONString: JSONString)\n```\n因此，我们也可以直接通过如下方法进行转换\n```\nlet user = Mapper<User>().map(JSONString: JSONString)\n```\n接下来就是ObjectMapper的核心啦~\n为什么通过Mapper类能完成转换呢？\n\n我们来逐步了解[Mapper](https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift)的实现原理\n\n```\npublic final class Mapper<N: BaseMappable> {\n    \n}\n```\n正如上面的代码块所示，首先Mapper类定义了一个泛型N，N必须要遵循Mappable协议，也就是我们的模型User\n继续往下看，我们选择一个常用的方法\n```\npublic func map(JSONString: String) -> N? {\n        if let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) {\n            return map(JSON: JSON)\n        }\n        \n        return nil\n    }\n```\n没错，我们前面写的Mapper的转换方法正是使用的这个方法\n```\nMapper().map(JSONString: JSONString)\n```\n那我们就来一层一层详细分析一下这个方法的内部实现吧\n\n```\n// 1. 调用Mapper的静态方法parseJSONStringIntoDictionary来将JSON转换成字典\n// 2. 调用map方法将转换后的字典转换成模型并返回\nif let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) {\n            return map(JSON: JSON)\n        }\n        \n        return nil\n```\n先分解`parseJSONStringIntoDictionary`的实现\n\n```\n/// Convert a JSON String into a Dictionary<String, Any> using NSJSONSerialization\n    public static func parseJSONStringIntoDictionary(JSONString: String) -> [String: Any]? {\n        let parsedJSON: Any? = Mapper.parseJSONString(JSONString: JSONString)\n        return parsedJSON as? [String: Any]\n    }\n\n    /// Convert a JSON String into an Object using NSJSONSerialization\n    public static func parseJSONString(JSONString: String) -> Any? {\n        let data = JSONString.data(using: String.Encoding.utf8, allowLossyConversion: true)\n        if let data = data {\n            let parsedJSON: Any?\n            do {\n                parsedJSON = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.allowFragments)\n            } catch let error {\n                print(error)\n                parsedJSON = nil\n            }\n            return parsedJSON\n        }\n\n        return nil\n    }\n\n```\n通过上述代码的逻辑不难发现，`parseJSONStringIntoDictionary`就是利用了系统的`JSONSerialization`将JSON字符串转换成字典\n\n理解了第一步，接下来我们就来看看第二步的实现原理\n\n我们先整体看一下map方法的实现代码\n\n```\n/// Maps a JSON dictionary to an object that conforms to Mappable\n    public func map(JSON: [String: Any]) -> N? {\n        let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)\n        \n        if let klass = N.self as? StaticMappable.Type { // Check if object is StaticMappable\n            if var object = klass.objectForMapping(map: map) as? N {\n                object.mapping(map: map)\n                return object\n            }\n        } else if let klass = N.self as? Mappable.Type { // Check if object is Mappable\n            if var object = klass.init(map: map) as? N {\n                object.mapping(map: map)\n                return object\n            }\n        } else if let klass = N.self as? ImmutableMappable.Type { // Check if object is ImmutableMappable\n            do {\n                return try klass.init(map: map) as? N\n            } catch let error {\n                #if DEBUG\n                let exception: NSException\n                if let mapError = error as? MapError {\n                    exception = NSException(name: .init(rawValue: \"MapError\"), reason: mapError.description, userInfo: nil)\n                } else {\n                    exception = NSException(name: .init(rawValue: \"ImmutableMappableError\"), reason: error.localizedDescription, userInfo: nil)\n                }\n                exception.raise()\n                #else\n                NSLog(\"\\(error)\")\n                #endif\n            }\n        } else {\n            // Ensure BaseMappable is not implemented directly\n            assert(false, \"BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable\")\n        }\n        \n        return nil\n    }\n\n```\n我们先忽略掉`StaticMappable`和`ImmutableMappable`这两种协议的处理逻辑，直接关注最重要的`Mappable`协议的实现\n\n```\n// 根据传入的JSON字典等数据创建一个map对象\n\nlet map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)\n\n// 判断要转换成的模型是不是 遵循的Mappable协议\nif let klass = N.self as? Mappable.Type \n\n// 创建一个N类型的对象\nvar object = klass.init(map: map) as? N\n\n// 获取模型中定义的解析规则，完成解析\nobject.mapping(map: map)\n\n// 返回生成好的模型\nreturn object\n```\n这里还留了一个疑问，为何执行完`object.mapping(map: map)`后，模型就能完成解析呢\n\n继续分析[Map]((https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift)类\n\n原来在Map类中使用了`subscript`来自定义下标\n同样我们直接来分析最重要的那个自定义下标的方法\n```\npublic subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -> Map {\n        // save key and value associated to it\n        currentKey = key\n        keyIsNested = nested\n        nestedKeyDelimiter = delimiter\n        \n        if mappingType == .fromJSON {\n            // check if a value exists for the current key\n            // do this pre-check for performance reasons\n            if nested == false {\n                let object = JSON[key]\n                let isNSNull = object is NSNull\n                isKeyPresent = isNSNull ? true : object != nil\n                currentValue = isNSNull ? nil : object\n            } else {\n                // break down the components of the key that are separated by .\n                (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON)\n            }\n            \n            // update isKeyPresent if ignoreNil is true\n            if ignoreNil && currentValue == nil {\n                isKeyPresent = false\n            }\n        }\n        \n        return self\n    }\n\n```\n\n不难发现，在这方法中，我们从JSON字典中根据key获取了value，原来当我们调用`object.mapping(map: map)`时，就会依次根据我们配置的mapping值获取对应的value\n\n#### ObjectMapper实践\n\n分析完原理，我们还需要能够熟练的运用ObjectMapper来帮助我们完成解析功能，ObjectMapper能够帮助我们处理数据的方法有很多，这里我就先简单跟大家分享几种在项目中常用的方法，我已经将相关的[Demo](https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master)上传到github上，欢迎大家star\n\n###### 解析单一结构的模型\n单一结构的模型解析比较简单，大家了解一下即可\n```\n{\n  \"name\": \"objectmapper\",\n  \"age\": 18,\n  \"nickname\": \"mapper\",\n  \"job\": \"swifter\"\n}\n```\n当我们拿到如上所示的json数据时，只需要创建一个遵循`Mappable`的模型，并配置好解析路径即可\n```\nclass User: Mappable {\n\n    var name: String?\n    var age: Int?\n    var nickname: String?\n    var job: String?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        name <- map[\"name\"]\n        age <- map[\"age\"]\n        nickname <- map[\"nickname\"]\n        job <- map[\"job\"]\n    }\n    \n}\n\n// 使用方法\nlet user = Mapper<User>().map(JSONString: json.rawString()!)\n\n```\n###### 解析模型中嵌套模型的情况\n有时候我们拿到的json数据嵌套了好几层的结构，而我们刚好也需要逐层解析拿到每个模型的数据，下面我就通过一个两层结构给大家演示一下处理的方法\n\n```\n{\n  \"weather\": \"sun\",\n    \"temperature\": {\n        \"celsius\": 70,\n        \"fahrenheit\": 34\n    },\n}\n```\n正如上面的json数据所示，我们需要创建一个weather模型，同时包含一个temperature模型来解析json数据，这时我们就需要运用泛型来帮助我们达到嵌套的目的\n```\nclass Weather<T: Mappable>: Mappable {\n\n    var weather: String?\n    var temperature: T?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        weather <- map[\"weather\"]\n        temperature <- map[\"temperature\"]\n    }\n}\n\nclass Temperature: Mappable {\n    \n    var celsius: Double?\n    var fahrenheit: Double?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        celsius <- map[\"celsius\"]\n        fahrenheit <- map[\"fahrenheit\"]\n    }\n}\n\n// 使用方法如下\nlet weather = Mapper<Weather<Temperature>>().map(JSONString: json.rawString()!)\n\n```\n###### 解析模型中嵌套模型但是我们只需要拿到子模型的属性值\n\n有些json数据嵌套的内容我们不需要分模型来获取，只需要将属性统一到一个模型中使用\n```\n{\n    \"distance\": {\n        \"text\": \"102 ft\",\n        \"value\": 31\n    }\n}\n```\n```\nclass Distance: Mappable {\n    var text: String?\n    var value: Int?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        text <- map[\"distance.text\"]\n        value <- map[\"distance.value\"]\n    }\n\n}\n```\n####### 解析指定的一个数组\n```\n{\n    \"status\": \"200\",\n    \"msg\": \"success\",\n    \"features\": [\n       {\n         \"name\": \"json解析\"\n       },\n       {\n         \"name\": \"模型转换\"\n       },\n       {\n         \"name\": \"数据处理\"\n       },\n       {\n         \"name\": \"mapper进阶\"\n       }\n    ]\n}\n```\n通过我们拿到的返回结果如上面的代码段所示，features是我们真正关心的数据，它是一个数组结构，我们期望能够得到的是一个数组，里面包含若干个feature模型\n\n首先我们必不可少的就是要创建一个Feature模型\n```\nclass Feature: Mappable {\n\n    var name: String?\n    \n    required init?(map: Map) {\n        \n    }\n    \n    func mapping(map: Map) {\n        name <- map[\"name\"]\n    }\n    \n}\n```\n在解析这个JSON数据时，我们可以忽略掉其他信息，先获取features对应的json数据\n```\nlet featureJson = json[\"features\"];\n```\n然后只需要使用Mapper的高级用法`mapArray`方法即可直接得到数组对象\n```\nlet features = Mapper<Feature>().mapArray(JSONString: featureJson.rawString()!)\n```\n\nObjectMapper的高级用法还有很多，掌握上面的这些用法基本已经可以在项目中使用ObjectMapper达到我们的需求了，后面有时间我会在此博客和[Demo](https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master)基础上更新更多的用法供大家参考\n\n\n\n","slug":"Swift开源项目ObjectMapper实践","published":1,"updated":"2018-08-31T09:43:55.470Z","_id":"cjlhoqwi20019kj795v72adjt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近期项目打算全面向swift迁移，虽然两三年前有写过swift项目但是很长时间没有开发很多知识点已经模糊，最近打算就热门的几个第三方库的使用方法进行一个调研</p>\n<p>今天就先从<a href=\"https://github.com/Hearst-DD/ObjectMapper\" target=\"_blank\" rel=\"external\">ObjectMapper</a>入手，ObjectMapper是一个由swift写的json和模型转换的开源库，目前已经有5950个star</p>\n<h3 id=\"先从官方文档入手，进行一个简单的介绍\"><a href=\"#先从官方文档入手，进行一个简单的介绍\" class=\"headerlink\" title=\"先从官方文档入手，进行一个简单的介绍\"></a>先从官方文档入手，进行一个简单的介绍</h3><h5 id=\"支持的功能\"><a href=\"#支持的功能\" class=\"headerlink\" title=\"支持的功能\"></a>支持的功能</h5><ul>\n<li>JSON向模型的转换</li>\n<li>模型向JSON的转换</li>\n<li>嵌套结构的解析</li>\n<li>mapping时的自定义转换</li>\n<li>结构体的支持</li>\n</ul>\n<h5 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h5><p>ObjectMapper中定义了一个协议<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mappable.swift\" target=\"_blank\" rel=\"external\">Mappable</a></p>\n<p>Mappable协议中声明了两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mutation func mapping(map: Map)</div><div class=\"line\"></div><div class=\"line\">init?(map: Map)</div></pre></td></tr></table></figure>\n<p>我们需要在模型中遵循这个协议，官方给出了一个参考：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\">    var username: String?</div><div class=\"line\">    var age: Int?</div><div class=\"line\">    var weight: Double!</div><div class=\"line\">    var array: [Any]?</div><div class=\"line\">    var dictionary: [String : Any] = [:]</div><div class=\"line\">    var bestFriend: User?                       // Nested User object</div><div class=\"line\">    var friends: [User]?                        // Array of Users</div><div class=\"line\">    var birthday: Date?</div><div class=\"line\"></div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mappable</div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        username    &lt;- map[&quot;username&quot;]</div><div class=\"line\">        age         &lt;- map[&quot;age&quot;]</div><div class=\"line\">        weight      &lt;- map[&quot;weight&quot;]</div><div class=\"line\">        array       &lt;- map[&quot;arr&quot;]</div><div class=\"line\">        dictionary  &lt;- map[&quot;dict&quot;]</div><div class=\"line\">        bestFriend  &lt;- map[&quot;best_friend&quot;]</div><div class=\"line\">        friends     &lt;- map[&quot;friends&quot;]</div><div class=\"line\">        birthday    &lt;- (map[&quot;birthday&quot;], DateTransform())</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct Temperature: Mappable &#123;</div><div class=\"line\">    var celsius: Double?</div><div class=\"line\">    var fahrenheit: Double?</div><div class=\"line\"></div><div class=\"line\">    init?(map: Map) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mutating func mapping(map: Map) &#123;</div><div class=\"line\">        celsius     &lt;- map[&quot;celsius&quot;]</div><div class=\"line\">        fahrenheit  &lt;- map[&quot;fahrenheit&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一旦我们的类或结构体如上面的示例一样实现了协议，我们就可以方便的进行JSON和模型之间的转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = User(JSONString: JSONString)</div><div class=\"line\"></div><div class=\"line\">let JSONString = user.toJSONString(prettyPrint: true)</div></pre></td></tr></table></figure>\n<p>当然也可以通过<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift\" target=\"_blank\" rel=\"external\">Mapper</a>类来进行转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = Mapper&lt;User&gt;().map(JSONString: JSONString)</div><div class=\"line\"></div><div class=\"line\">let JSONString = Mapper().toJSONString(user, prettyPrint: true)</div></pre></td></tr></table></figure>\n<h5 id=\"嵌套对象的映射\"><a href=\"#嵌套对象的映射\" class=\"headerlink\" title=\"嵌套对象的映射\"></a>嵌套对象的映射</h5><p>正如前面所列，ObjectMapper支持嵌套对象的映射</p>\n<p>列如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;distance&quot; : &#123;</div><div class=\"line\">        &quot;text&quot; : &quot;102&quot;,</div><div class=\"line\">        &quot;value&quot; : 31</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们想要直接取出distance对象中的value值，可以设置如下mapping<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func mapping(map: Map) &#123;</div><div class=\"line\">    distance &lt;- map[&quot;distance.value&quot;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"自定义转换规则\"><a href=\"#自定义转换规则\" class=\"headerlink\" title=\"自定义转换规则\"></a>自定义转换规则</h5><p>ObjectMapper允许开发者在数据映射过程中指定转换规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class People: Mappable &#123;</div><div class=\"line\">   var birthday: NSDate?</div><div class=\"line\">   </div><div class=\"line\">   required init?(_ map: Map) &#123;</div><div class=\"line\">       </div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   func mapping(map: Map) &#123;</div><div class=\"line\">       birthday &lt;- (map[&quot;birthday&quot;], DateTransform())</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   let JSON = &quot;\\&quot;birthday\\&quot;:1458117795332&quot;</div><div class=\"line\">   let result = Mapper&lt;People&gt;().map(JSON)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于我们指定了<code>birthday</code>的转换规则，所以上述代码在解析JSON数据的时候会将long类型转换成Date类型</p>\n<p>除了使用ObjectMapper给我们提供的转换规则外，我们还可以通过实现<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformType.swift\" target=\"_blank\" rel=\"external\">TransformType</a>协议来自定义我们的转换规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public protocol TransformType &#123;</div><div class=\"line\">    typealias Object</div><div class=\"line\">    typealias JSON</div><div class=\"line\">    </div><div class=\"line\">    func transformFromJSON(value: AnyObject?) -&gt; Object?</div><div class=\"line\">    func transformToJSON(value: Object?) -&gt; JSON?</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ObjectMapper为我们提供了一个<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformOf.swift\" target=\"_blank\" rel=\"external\">TransformOf</a>类来实现转换结果，TransformOf实际就是实现了TransformType协议的，TransformOf有两个类型的参数和两个闭包参数，类型表示参与转换的数据的类型，闭包表示转换的规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let transform = TransformOf&lt;Int, String&gt;(fromJSON: &#123; (value: String?) -&gt; Int? in </div><div class=\"line\">&#125;, toJSON: &#123; (value: Int?) -&gt; String? in </div><div class=\"line\">  // transform value from Int? to String?</div><div class=\"line\">  if let value = value &#123;</div><div class=\"line\">      return String(value)</div><div class=\"line\">  &#125;</div><div class=\"line\">  return nil</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">id &lt;- (map[&quot;id&quot;], transform)</div></pre></td></tr></table></figure>\n<h5 id=\"泛型对象\"><a href=\"#泛型对象\" class=\"headerlink\" title=\"泛型对象\"></a>泛型对象</h5><p>ObjectMapper同样可以处理泛型类型的参数，不过这个泛型类型需要在实现了Mappable协议的基础上才可以正常使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\">    var name: String?</div><div class=\"line\">    </div><div class=\"line\">    required init?(_ map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(_ map: Map) &#123;</div><div class=\"line\">        name &lt;- map[&quot;name&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Result&lt;T: Mappable&gt;: Mappable &#123;</div><div class=\"line\">    var result: T?</div><div class=\"line\">    </div><div class=\"line\">    required init?(_ map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        result &lt;- map[&quot;result&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let JSON = &quot;&#123;\\&quot;result\\&quot;: &#123;\\&quot;name\\&quot;: \\&quot;anenn\\&quot;&#125;&#125;&quot;</div><div class=\"line\">let result = Mapper&lt;Result&lt;User&gt;&gt;().map(JSON)</div></pre></td></tr></table></figure>\n<h3 id=\"原理解析\"><a href=\"#原理解析\" class=\"headerlink\" title=\"原理解析\"></a>原理解析</h3><p>ObjectMapper声明了一个Mappable协议，这个协议里声明了两个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">init?(map: Map)</div><div class=\"line\"></div><div class=\"line\">mutating func mapping(map: Map)</div></pre></td></tr></table></figure></p>\n<p>并且通过对Mappable协议的扩展，增加了JSON和模型之间的四个转换方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public extension BaseMappable &#123;</div><div class=\"line\">    </div><div class=\"line\">    /// Initializes object from a JSON String</div><div class=\"line\">    public init?(JSONString: String, context: MapContext? = nil) &#123;</div><div class=\"line\">        if let obj: Self = Mapper(context: context).map(JSONString: JSONString) &#123;</div><div class=\"line\">            self = obj</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return nil</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// Initializes object from a JSON Dictionary</div><div class=\"line\">    public init?(JSON: [String: Any], context: MapContext? = nil) &#123;</div><div class=\"line\">        if let obj: Self = Mapper(context: context).map(JSON: JSON) &#123;</div><div class=\"line\">            self = obj</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return nil</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// Returns the JSON Dictionary for the object</div><div class=\"line\">    public func toJSON() -&gt; [String: Any] &#123;</div><div class=\"line\">        return Mapper().toJSON(self)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// Returns the JSON String for the object</div><div class=\"line\">    public func toJSONString(prettyPrint: Bool = false) -&gt; String? &#123;</div><div class=\"line\">        return Mapper().toJSONString(self, prettyPrint: prettyPrint)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们在使用ObjectMapper进行转换时，首先需要让模型遵循Mappable协议，并且实现Mappable声明的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\">    var username: String?</div><div class=\"line\">    var age: Int?</div><div class=\"line\"></div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mappable</div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        username    &lt;- map[&quot;username&quot;]</div><div class=\"line\">        age         &lt;- map[&quot;age&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为ObjectMapper为Mappable增加了四个转换方法，所以User也继承了这四个转换方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = User(JSONString: JSONString)</div></pre></td></tr></table></figure>\n<p>这个方法的调用其实就是帮助我们执行了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mapper().map(JSONString: JSONString)</div></pre></td></tr></table></figure></p>\n<p>因此，我们也可以直接通过如下方法进行转换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = Mapper&lt;User&gt;().map(JSONString: JSONString)</div></pre></td></tr></table></figure></p>\n<p>接下来就是ObjectMapper的核心啦~<br>为什么通过Mapper类能完成转换呢？</p>\n<p>我们来逐步了解<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift\" target=\"_blank\" rel=\"external\">Mapper</a>的实现原理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final class Mapper&lt;N: BaseMappable&gt; &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正如上面的代码块所示，首先Mapper类定义了一个泛型N，N必须要遵循Mappable协议，也就是我们的模型User<br>继续往下看，我们选择一个常用的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public func map(JSONString: String) -&gt; N? &#123;</div><div class=\"line\">        if let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) &#123;</div><div class=\"line\">            return map(JSON: JSON)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>没错，我们前面写的Mapper的转换方法正是使用的这个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mapper().map(JSONString: JSONString)</div></pre></td></tr></table></figure></p>\n<p>那我们就来一层一层详细分析一下这个方法的内部实现吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1. 调用Mapper的静态方法parseJSONStringIntoDictionary来将JSON转换成字典</div><div class=\"line\">// 2. 调用map方法将转换后的字典转换成模型并返回</div><div class=\"line\">if let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) &#123;</div><div class=\"line\">            return map(JSON: JSON)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return nil</div></pre></td></tr></table></figure>\n<p>先分解<code>parseJSONStringIntoDictionary</code>的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">/// Convert a JSON String into a Dictionary&lt;String, Any&gt; using NSJSONSerialization</div><div class=\"line\">    public static func parseJSONStringIntoDictionary(JSONString: String) -&gt; [String: Any]? &#123;</div><div class=\"line\">        let parsedJSON: Any? = Mapper.parseJSONString(JSONString: JSONString)</div><div class=\"line\">        return parsedJSON as? [String: Any]</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /// Convert a JSON String into an Object using NSJSONSerialization</div><div class=\"line\">    public static func parseJSONString(JSONString: String) -&gt; Any? &#123;</div><div class=\"line\">        let data = JSONString.data(using: String.Encoding.utf8, allowLossyConversion: true)</div><div class=\"line\">        if let data = data &#123;</div><div class=\"line\">            let parsedJSON: Any?</div><div class=\"line\">            do &#123;</div><div class=\"line\">                parsedJSON = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.allowFragments)</div><div class=\"line\">            &#125; catch let error &#123;</div><div class=\"line\">                print(error)</div><div class=\"line\">                parsedJSON = nil</div><div class=\"line\">            &#125;</div><div class=\"line\">            return parsedJSON</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>通过上述代码的逻辑不难发现，<code>parseJSONStringIntoDictionary</code>就是利用了系统的<code>JSONSerialization</code>将JSON字符串转换成字典</p>\n<p>理解了第一步，接下来我们就来看看第二步的实现原理</p>\n<p>我们先整体看一下map方法的实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">/// Maps a JSON dictionary to an object that conforms to Mappable</div><div class=\"line\">    public func map(JSON: [String: Any]) -&gt; N? &#123;</div><div class=\"line\">        let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)</div><div class=\"line\">        </div><div class=\"line\">        if let klass = N.self as? StaticMappable.Type &#123; // Check if object is StaticMappable</div><div class=\"line\">            if var object = klass.objectForMapping(map: map) as? N &#123;</div><div class=\"line\">                object.mapping(map: map)</div><div class=\"line\">                return object</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable</div><div class=\"line\">            if var object = klass.init(map: map) as? N &#123;</div><div class=\"line\">                object.mapping(map: map)</div><div class=\"line\">                return object</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if let klass = N.self as? ImmutableMappable.Type &#123; // Check if object is ImmutableMappable</div><div class=\"line\">            do &#123;</div><div class=\"line\">                return try klass.init(map: map) as? N</div><div class=\"line\">            &#125; catch let error &#123;</div><div class=\"line\">                #if DEBUG</div><div class=\"line\">                let exception: NSException</div><div class=\"line\">                if let mapError = error as? MapError &#123;</div><div class=\"line\">                    exception = NSException(name: .init(rawValue: &quot;MapError&quot;), reason: mapError.description, userInfo: nil)</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    exception = NSException(name: .init(rawValue: &quot;ImmutableMappableError&quot;), reason: error.localizedDescription, userInfo: nil)</div><div class=\"line\">                &#125;</div><div class=\"line\">                exception.raise()</div><div class=\"line\">                #else</div><div class=\"line\">                NSLog(&quot;\\(error)&quot;)</div><div class=\"line\">                #endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Ensure BaseMappable is not implemented directly</div><div class=\"line\">            assert(false, &quot;BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable&quot;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们先忽略掉<code>StaticMappable</code>和<code>ImmutableMappable</code>这两种协议的处理逻辑，直接关注最重要的<code>Mappable</code>协议的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 根据传入的JSON字典等数据创建一个map对象</div><div class=\"line\"></div><div class=\"line\">let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)</div><div class=\"line\"></div><div class=\"line\">// 判断要转换成的模型是不是 遵循的Mappable协议</div><div class=\"line\">if let klass = N.self as? Mappable.Type </div><div class=\"line\"></div><div class=\"line\">// 创建一个N类型的对象</div><div class=\"line\">var object = klass.init(map: map) as? N</div><div class=\"line\"></div><div class=\"line\">// 获取模型中定义的解析规则，完成解析</div><div class=\"line\">object.mapping(map: map)</div><div class=\"line\"></div><div class=\"line\">// 返回生成好的模型</div><div class=\"line\">return object</div></pre></td></tr></table></figure>\n<p>这里还留了一个疑问，为何执行完<code>object.mapping(map: map)</code>后，模型就能完成解析呢</p>\n<p>继续分析<a href=\"(https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift\">Map</a>类</p>\n<p>原来在Map类中使用了<code>subscript</code>来自定义下标<br>同样我们直接来分析最重要的那个自定义下标的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123;</div><div class=\"line\">        // save key and value associated to it</div><div class=\"line\">        currentKey = key</div><div class=\"line\">        keyIsNested = nested</div><div class=\"line\">        nestedKeyDelimiter = delimiter</div><div class=\"line\">        </div><div class=\"line\">        if mappingType == .fromJSON &#123;</div><div class=\"line\">            // check if a value exists for the current key</div><div class=\"line\">            // do this pre-check for performance reasons</div><div class=\"line\">            if nested == false &#123;</div><div class=\"line\">                let object = JSON[key]</div><div class=\"line\">                let isNSNull = object is NSNull</div><div class=\"line\">                isKeyPresent = isNSNull ? true : object != nil</div><div class=\"line\">                currentValue = isNSNull ? nil : object</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // break down the components of the key that are separated by .</div><div class=\"line\">                (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON)</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // update isKeyPresent if ignoreNil is true</div><div class=\"line\">            if ignoreNil &amp;&amp; currentValue == nil &#123;</div><div class=\"line\">                isKeyPresent = false</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return self</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>不难发现，在这方法中，我们从JSON字典中根据key获取了value，原来当我们调用<code>object.mapping(map: map)</code>时，就会依次根据我们配置的mapping值获取对应的value</p>\n<h4 id=\"ObjectMapper实践\"><a href=\"#ObjectMapper实践\" class=\"headerlink\" title=\"ObjectMapper实践\"></a>ObjectMapper实践</h4><p>分析完原理，我们还需要能够熟练的运用ObjectMapper来帮助我们完成解析功能，ObjectMapper能够帮助我们处理数据的方法有很多，这里我就先简单跟大家分享几种在项目中常用的方法，我已经将相关的<a href=\"https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master\" target=\"_blank\" rel=\"external\">Demo</a>上传到github上，欢迎大家star</p>\n<h6 id=\"解析单一结构的模型\"><a href=\"#解析单一结构的模型\" class=\"headerlink\" title=\"解析单一结构的模型\"></a>解析单一结构的模型</h6><p>单一结构的模型解析比较简单，大家了解一下即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;objectmapper&quot;,</div><div class=\"line\">  &quot;age&quot;: 18,</div><div class=\"line\">  &quot;nickname&quot;: &quot;mapper&quot;,</div><div class=\"line\">  &quot;job&quot;: &quot;swifter&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们拿到如上所示的json数据时，只需要创建一个遵循<code>Mappable</code>的模型，并配置好解析路径即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\"></div><div class=\"line\">    var name: String?</div><div class=\"line\">    var age: Int?</div><div class=\"line\">    var nickname: String?</div><div class=\"line\">    var job: String?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        name &lt;- map[&quot;name&quot;]</div><div class=\"line\">        age &lt;- map[&quot;age&quot;]</div><div class=\"line\">        nickname &lt;- map[&quot;nickname&quot;]</div><div class=\"line\">        job &lt;- map[&quot;job&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 使用方法</div><div class=\"line\">let user = Mapper&lt;User&gt;().map(JSONString: json.rawString()!)</div></pre></td></tr></table></figure></p>\n<h6 id=\"解析模型中嵌套模型的情况\"><a href=\"#解析模型中嵌套模型的情况\" class=\"headerlink\" title=\"解析模型中嵌套模型的情况\"></a>解析模型中嵌套模型的情况</h6><p>有时候我们拿到的json数据嵌套了好几层的结构，而我们刚好也需要逐层解析拿到每个模型的数据，下面我就通过一个两层结构给大家演示一下处理的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;weather&quot;: &quot;sun&quot;,</div><div class=\"line\">    &quot;temperature&quot;: &#123;</div><div class=\"line\">        &quot;celsius&quot;: 70,</div><div class=\"line\">        &quot;fahrenheit&quot;: 34</div><div class=\"line\">    &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正如上面的json数据所示，我们需要创建一个weather模型，同时包含一个temperature模型来解析json数据，这时我们就需要运用泛型来帮助我们达到嵌套的目的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Weather&lt;T: Mappable&gt;: Mappable &#123;</div><div class=\"line\"></div><div class=\"line\">    var weather: String?</div><div class=\"line\">    var temperature: T?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        weather &lt;- map[&quot;weather&quot;]</div><div class=\"line\">        temperature &lt;- map[&quot;temperature&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Temperature: Mappable &#123;</div><div class=\"line\">    </div><div class=\"line\">    var celsius: Double?</div><div class=\"line\">    var fahrenheit: Double?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        celsius &lt;- map[&quot;celsius&quot;]</div><div class=\"line\">        fahrenheit &lt;- map[&quot;fahrenheit&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 使用方法如下</div><div class=\"line\">let weather = Mapper&lt;Weather&lt;Temperature&gt;&gt;().map(JSONString: json.rawString()!)</div></pre></td></tr></table></figure></p>\n<h6 id=\"解析模型中嵌套模型但是我们只需要拿到子模型的属性值\"><a href=\"#解析模型中嵌套模型但是我们只需要拿到子模型的属性值\" class=\"headerlink\" title=\"解析模型中嵌套模型但是我们只需要拿到子模型的属性值\"></a>解析模型中嵌套模型但是我们只需要拿到子模型的属性值</h6><p>有些json数据嵌套的内容我们不需要分模型来获取，只需要将属性统一到一个模型中使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;distance&quot;: &#123;</div><div class=\"line\">        &quot;text&quot;: &quot;102 ft&quot;,</div><div class=\"line\">        &quot;value&quot;: 31</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Distance: Mappable &#123;</div><div class=\"line\">    var text: String?</div><div class=\"line\">    var value: Int?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        text &lt;- map[&quot;distance.text&quot;]</div><div class=\"line\">        value &lt;- map[&quot;distance.value&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>####### 解析指定的一个数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;status&quot;: &quot;200&quot;,</div><div class=\"line\">    &quot;msg&quot;: &quot;success&quot;,</div><div class=\"line\">    &quot;features&quot;: [</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;json解析&quot;</div><div class=\"line\">       &#125;,</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;模型转换&quot;</div><div class=\"line\">       &#125;,</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;数据处理&quot;</div><div class=\"line\">       &#125;,</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;mapper进阶&quot;</div><div class=\"line\">       &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过我们拿到的返回结果如上面的代码段所示，features是我们真正关心的数据，它是一个数组结构，我们期望能够得到的是一个数组，里面包含若干个feature模型</p>\n<p>首先我们必不可少的就是要创建一个Feature模型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Feature: Mappable &#123;</div><div class=\"line\"></div><div class=\"line\">    var name: String?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        name &lt;- map[&quot;name&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在解析这个JSON数据时，我们可以忽略掉其他信息，先获取features对应的json数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let featureJson = json[&quot;features&quot;];</div></pre></td></tr></table></figure></p>\n<p>然后只需要使用Mapper的高级用法<code>mapArray</code>方法即可直接得到数组对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let features = Mapper&lt;Feature&gt;().mapArray(JSONString: featureJson.rawString()!)</div></pre></td></tr></table></figure></p>\n<p>ObjectMapper的高级用法还有很多，掌握上面的这些用法基本已经可以在项目中使用ObjectMapper达到我们的需求了，后面有时间我会在此博客和<a href=\"https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master\" target=\"_blank\" rel=\"external\">Demo</a>基础上更新更多的用法供大家参考</p>\n","excerpt":"","more":"<p>近期项目打算全面向swift迁移，虽然两三年前有写过swift项目但是很长时间没有开发很多知识点已经模糊，最近打算就热门的几个第三方库的使用方法进行一个调研</p>\n<p>今天就先从<a href=\"https://github.com/Hearst-DD/ObjectMapper\">ObjectMapper</a>入手，ObjectMapper是一个由swift写的json和模型转换的开源库，目前已经有5950个star</p>\n<h3 id=\"先从官方文档入手，进行一个简单的介绍\"><a href=\"#先从官方文档入手，进行一个简单的介绍\" class=\"headerlink\" title=\"先从官方文档入手，进行一个简单的介绍\"></a>先从官方文档入手，进行一个简单的介绍</h3><h5 id=\"支持的功能\"><a href=\"#支持的功能\" class=\"headerlink\" title=\"支持的功能\"></a>支持的功能</h5><ul>\n<li>JSON向模型的转换</li>\n<li>模型向JSON的转换</li>\n<li>嵌套结构的解析</li>\n<li>mapping时的自定义转换</li>\n<li>结构体的支持</li>\n</ul>\n<h5 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h5><p>ObjectMapper中定义了一个协议<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mappable.swift\">Mappable</a></p>\n<p>Mappable协议中声明了两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mutation func mapping(map: Map)</div><div class=\"line\"></div><div class=\"line\">init?(map: Map)</div></pre></td></tr></table></figure>\n<p>我们需要在模型中遵循这个协议，官方给出了一个参考：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\">    var username: String?</div><div class=\"line\">    var age: Int?</div><div class=\"line\">    var weight: Double!</div><div class=\"line\">    var array: [Any]?</div><div class=\"line\">    var dictionary: [String : Any] = [:]</div><div class=\"line\">    var bestFriend: User?                       // Nested User object</div><div class=\"line\">    var friends: [User]?                        // Array of Users</div><div class=\"line\">    var birthday: Date?</div><div class=\"line\"></div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mappable</div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        username    &lt;- map[&quot;username&quot;]</div><div class=\"line\">        age         &lt;- map[&quot;age&quot;]</div><div class=\"line\">        weight      &lt;- map[&quot;weight&quot;]</div><div class=\"line\">        array       &lt;- map[&quot;arr&quot;]</div><div class=\"line\">        dictionary  &lt;- map[&quot;dict&quot;]</div><div class=\"line\">        bestFriend  &lt;- map[&quot;best_friend&quot;]</div><div class=\"line\">        friends     &lt;- map[&quot;friends&quot;]</div><div class=\"line\">        birthday    &lt;- (map[&quot;birthday&quot;], DateTransform())</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct Temperature: Mappable &#123;</div><div class=\"line\">    var celsius: Double?</div><div class=\"line\">    var fahrenheit: Double?</div><div class=\"line\"></div><div class=\"line\">    init?(map: Map) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mutating func mapping(map: Map) &#123;</div><div class=\"line\">        celsius     &lt;- map[&quot;celsius&quot;]</div><div class=\"line\">        fahrenheit  &lt;- map[&quot;fahrenheit&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一旦我们的类或结构体如上面的示例一样实现了协议，我们就可以方便的进行JSON和模型之间的转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = User(JSONString: JSONString)</div><div class=\"line\"></div><div class=\"line\">let JSONString = user.toJSONString(prettyPrint: true)</div></pre></td></tr></table></figure>\n<p>当然也可以通过<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift\">Mapper</a>类来进行转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = Mapper&lt;User&gt;().map(JSONString: JSONString)</div><div class=\"line\"></div><div class=\"line\">let JSONString = Mapper().toJSONString(user, prettyPrint: true)</div></pre></td></tr></table></figure>\n<h5 id=\"嵌套对象的映射\"><a href=\"#嵌套对象的映射\" class=\"headerlink\" title=\"嵌套对象的映射\"></a>嵌套对象的映射</h5><p>正如前面所列，ObjectMapper支持嵌套对象的映射</p>\n<p>列如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;distance&quot; : &#123;</div><div class=\"line\">        &quot;text&quot; : &quot;102&quot;,</div><div class=\"line\">        &quot;value&quot; : 31</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们想要直接取出distance对象中的value值，可以设置如下mapping<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func mapping(map: Map) &#123;</div><div class=\"line\">    distance &lt;- map[&quot;distance.value&quot;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"自定义转换规则\"><a href=\"#自定义转换规则\" class=\"headerlink\" title=\"自定义转换规则\"></a>自定义转换规则</h5><p>ObjectMapper允许开发者在数据映射过程中指定转换规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class People: Mappable &#123;</div><div class=\"line\">   var birthday: NSDate?</div><div class=\"line\">   </div><div class=\"line\">   required init?(_ map: Map) &#123;</div><div class=\"line\">       </div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   func mapping(map: Map) &#123;</div><div class=\"line\">       birthday &lt;- (map[&quot;birthday&quot;], DateTransform())</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   let JSON = &quot;\\&quot;birthday\\&quot;:1458117795332&quot;</div><div class=\"line\">   let result = Mapper&lt;People&gt;().map(JSON)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于我们指定了<code>birthday</code>的转换规则，所以上述代码在解析JSON数据的时候会将long类型转换成Date类型</p>\n<p>除了使用ObjectMapper给我们提供的转换规则外，我们还可以通过实现<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformType.swift\">TransformType</a>协议来自定义我们的转换规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public protocol TransformType &#123;</div><div class=\"line\">    typealias Object</div><div class=\"line\">    typealias JSON</div><div class=\"line\">    </div><div class=\"line\">    func transformFromJSON(value: AnyObject?) -&gt; Object?</div><div class=\"line\">    func transformToJSON(value: Object?) -&gt; JSON?</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ObjectMapper为我们提供了一个<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/TransformOf.swift\">TransformOf</a>类来实现转换结果，TransformOf实际就是实现了TransformType协议的，TransformOf有两个类型的参数和两个闭包参数，类型表示参与转换的数据的类型，闭包表示转换的规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let transform = TransformOf&lt;Int, String&gt;(fromJSON: &#123; (value: String?) -&gt; Int? in </div><div class=\"line\">&#125;, toJSON: &#123; (value: Int?) -&gt; String? in </div><div class=\"line\">  // transform value from Int? to String?</div><div class=\"line\">  if let value = value &#123;</div><div class=\"line\">      return String(value)</div><div class=\"line\">  &#125;</div><div class=\"line\">  return nil</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">id &lt;- (map[&quot;id&quot;], transform)</div></pre></td></tr></table></figure>\n<h5 id=\"泛型对象\"><a href=\"#泛型对象\" class=\"headerlink\" title=\"泛型对象\"></a>泛型对象</h5><p>ObjectMapper同样可以处理泛型类型的参数，不过这个泛型类型需要在实现了Mappable协议的基础上才可以正常使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\">    var name: String?</div><div class=\"line\">    </div><div class=\"line\">    required init?(_ map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(_ map: Map) &#123;</div><div class=\"line\">        name &lt;- map[&quot;name&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Result&lt;T: Mappable&gt;: Mappable &#123;</div><div class=\"line\">    var result: T?</div><div class=\"line\">    </div><div class=\"line\">    required init?(_ map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        result &lt;- map[&quot;result&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let JSON = &quot;&#123;\\&quot;result\\&quot;: &#123;\\&quot;name\\&quot;: \\&quot;anenn\\&quot;&#125;&#125;&quot;</div><div class=\"line\">let result = Mapper&lt;Result&lt;User&gt;&gt;().map(JSON)</div></pre></td></tr></table></figure>\n<h3 id=\"原理解析\"><a href=\"#原理解析\" class=\"headerlink\" title=\"原理解析\"></a>原理解析</h3><p>ObjectMapper声明了一个Mappable协议，这个协议里声明了两个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">init?(map: Map)</div><div class=\"line\"></div><div class=\"line\">mutating func mapping(map: Map)</div></pre></td></tr></table></figure></p>\n<p>并且通过对Mappable协议的扩展，增加了JSON和模型之间的四个转换方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public extension BaseMappable &#123;</div><div class=\"line\">    </div><div class=\"line\">    /// Initializes object from a JSON String</div><div class=\"line\">    public init?(JSONString: String, context: MapContext? = nil) &#123;</div><div class=\"line\">        if let obj: Self = Mapper(context: context).map(JSONString: JSONString) &#123;</div><div class=\"line\">            self = obj</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return nil</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// Initializes object from a JSON Dictionary</div><div class=\"line\">    public init?(JSON: [String: Any], context: MapContext? = nil) &#123;</div><div class=\"line\">        if let obj: Self = Mapper(context: context).map(JSON: JSON) &#123;</div><div class=\"line\">            self = obj</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return nil</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// Returns the JSON Dictionary for the object</div><div class=\"line\">    public func toJSON() -&gt; [String: Any] &#123;</div><div class=\"line\">        return Mapper().toJSON(self)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// Returns the JSON String for the object</div><div class=\"line\">    public func toJSONString(prettyPrint: Bool = false) -&gt; String? &#123;</div><div class=\"line\">        return Mapper().toJSONString(self, prettyPrint: prettyPrint)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们在使用ObjectMapper进行转换时，首先需要让模型遵循Mappable协议，并且实现Mappable声明的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\">    var username: String?</div><div class=\"line\">    var age: Int?</div><div class=\"line\"></div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mappable</div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        username    &lt;- map[&quot;username&quot;]</div><div class=\"line\">        age         &lt;- map[&quot;age&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为ObjectMapper为Mappable增加了四个转换方法，所以User也继承了这四个转换方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = User(JSONString: JSONString)</div></pre></td></tr></table></figure>\n<p>这个方法的调用其实就是帮助我们执行了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mapper().map(JSONString: JSONString)</div></pre></td></tr></table></figure></p>\n<p>因此，我们也可以直接通过如下方法进行转换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let user = Mapper&lt;User&gt;().map(JSONString: JSONString)</div></pre></td></tr></table></figure></p>\n<p>接下来就是ObjectMapper的核心啦~<br>为什么通过Mapper类能完成转换呢？</p>\n<p>我们来逐步了解<a href=\"https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift\">Mapper</a>的实现原理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final class Mapper&lt;N: BaseMappable&gt; &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正如上面的代码块所示，首先Mapper类定义了一个泛型N，N必须要遵循Mappable协议，也就是我们的模型User<br>继续往下看，我们选择一个常用的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public func map(JSONString: String) -&gt; N? &#123;</div><div class=\"line\">        if let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) &#123;</div><div class=\"line\">            return map(JSON: JSON)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>没错，我们前面写的Mapper的转换方法正是使用的这个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mapper().map(JSONString: JSONString)</div></pre></td></tr></table></figure></p>\n<p>那我们就来一层一层详细分析一下这个方法的内部实现吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1. 调用Mapper的静态方法parseJSONStringIntoDictionary来将JSON转换成字典</div><div class=\"line\">// 2. 调用map方法将转换后的字典转换成模型并返回</div><div class=\"line\">if let JSON = Mapper.parseJSONStringIntoDictionary(JSONString: JSONString) &#123;</div><div class=\"line\">            return map(JSON: JSON)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return nil</div></pre></td></tr></table></figure>\n<p>先分解<code>parseJSONStringIntoDictionary</code>的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">/// Convert a JSON String into a Dictionary&lt;String, Any&gt; using NSJSONSerialization</div><div class=\"line\">    public static func parseJSONStringIntoDictionary(JSONString: String) -&gt; [String: Any]? &#123;</div><div class=\"line\">        let parsedJSON: Any? = Mapper.parseJSONString(JSONString: JSONString)</div><div class=\"line\">        return parsedJSON as? [String: Any]</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /// Convert a JSON String into an Object using NSJSONSerialization</div><div class=\"line\">    public static func parseJSONString(JSONString: String) -&gt; Any? &#123;</div><div class=\"line\">        let data = JSONString.data(using: String.Encoding.utf8, allowLossyConversion: true)</div><div class=\"line\">        if let data = data &#123;</div><div class=\"line\">            let parsedJSON: Any?</div><div class=\"line\">            do &#123;</div><div class=\"line\">                parsedJSON = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.allowFragments)</div><div class=\"line\">            &#125; catch let error &#123;</div><div class=\"line\">                print(error)</div><div class=\"line\">                parsedJSON = nil</div><div class=\"line\">            &#125;</div><div class=\"line\">            return parsedJSON</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>通过上述代码的逻辑不难发现，<code>parseJSONStringIntoDictionary</code>就是利用了系统的<code>JSONSerialization</code>将JSON字符串转换成字典</p>\n<p>理解了第一步，接下来我们就来看看第二步的实现原理</p>\n<p>我们先整体看一下map方法的实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">/// Maps a JSON dictionary to an object that conforms to Mappable</div><div class=\"line\">    public func map(JSON: [String: Any]) -&gt; N? &#123;</div><div class=\"line\">        let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)</div><div class=\"line\">        </div><div class=\"line\">        if let klass = N.self as? StaticMappable.Type &#123; // Check if object is StaticMappable</div><div class=\"line\">            if var object = klass.objectForMapping(map: map) as? N &#123;</div><div class=\"line\">                object.mapping(map: map)</div><div class=\"line\">                return object</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if let klass = N.self as? Mappable.Type &#123; // Check if object is Mappable</div><div class=\"line\">            if var object = klass.init(map: map) as? N &#123;</div><div class=\"line\">                object.mapping(map: map)</div><div class=\"line\">                return object</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if let klass = N.self as? ImmutableMappable.Type &#123; // Check if object is ImmutableMappable</div><div class=\"line\">            do &#123;</div><div class=\"line\">                return try klass.init(map: map) as? N</div><div class=\"line\">            &#125; catch let error &#123;</div><div class=\"line\">                #if DEBUG</div><div class=\"line\">                let exception: NSException</div><div class=\"line\">                if let mapError = error as? MapError &#123;</div><div class=\"line\">                    exception = NSException(name: .init(rawValue: &quot;MapError&quot;), reason: mapError.description, userInfo: nil)</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    exception = NSException(name: .init(rawValue: &quot;ImmutableMappableError&quot;), reason: error.localizedDescription, userInfo: nil)</div><div class=\"line\">                &#125;</div><div class=\"line\">                exception.raise()</div><div class=\"line\">                #else</div><div class=\"line\">                NSLog(&quot;\\(error)&quot;)</div><div class=\"line\">                #endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Ensure BaseMappable is not implemented directly</div><div class=\"line\">            assert(false, &quot;BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable&quot;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>我们先忽略掉<code>StaticMappable</code>和<code>ImmutableMappable</code>这两种协议的处理逻辑，直接关注最重要的<code>Mappable</code>协议的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 根据传入的JSON字典等数据创建一个map对象</div><div class=\"line\"></div><div class=\"line\">let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues)</div><div class=\"line\"></div><div class=\"line\">// 判断要转换成的模型是不是 遵循的Mappable协议</div><div class=\"line\">if let klass = N.self as? Mappable.Type </div><div class=\"line\"></div><div class=\"line\">// 创建一个N类型的对象</div><div class=\"line\">var object = klass.init(map: map) as? N</div><div class=\"line\"></div><div class=\"line\">// 获取模型中定义的解析规则，完成解析</div><div class=\"line\">object.mapping(map: map)</div><div class=\"line\"></div><div class=\"line\">// 返回生成好的模型</div><div class=\"line\">return object</div></pre></td></tr></table></figure>\n<p>这里还留了一个疑问，为何执行完<code>object.mapping(map: map)</code>后，模型就能完成解析呢</p>\n<p>继续分析<a href=\"(https://github.com/Hearst-DD/ObjectMapper/blob/master/Sources/Mapper.swift\">Map</a>类</p>\n<p>原来在Map类中使用了<code>subscript</code>来自定义下标<br>同样我们直接来分析最重要的那个自定义下标的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public subscript(key: String, nested nested: Bool, delimiter delimiter: String, ignoreNil ignoreNil: Bool) -&gt; Map &#123;</div><div class=\"line\">        // save key and value associated to it</div><div class=\"line\">        currentKey = key</div><div class=\"line\">        keyIsNested = nested</div><div class=\"line\">        nestedKeyDelimiter = delimiter</div><div class=\"line\">        </div><div class=\"line\">        if mappingType == .fromJSON &#123;</div><div class=\"line\">            // check if a value exists for the current key</div><div class=\"line\">            // do this pre-check for performance reasons</div><div class=\"line\">            if nested == false &#123;</div><div class=\"line\">                let object = JSON[key]</div><div class=\"line\">                let isNSNull = object is NSNull</div><div class=\"line\">                isKeyPresent = isNSNull ? true : object != nil</div><div class=\"line\">                currentValue = isNSNull ? nil : object</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // break down the components of the key that are separated by .</div><div class=\"line\">                (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON)</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // update isKeyPresent if ignoreNil is true</div><div class=\"line\">            if ignoreNil &amp;&amp; currentValue == nil &#123;</div><div class=\"line\">                isKeyPresent = false</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        return self</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>不难发现，在这方法中，我们从JSON字典中根据key获取了value，原来当我们调用<code>object.mapping(map: map)</code>时，就会依次根据我们配置的mapping值获取对应的value</p>\n<h4 id=\"ObjectMapper实践\"><a href=\"#ObjectMapper实践\" class=\"headerlink\" title=\"ObjectMapper实践\"></a>ObjectMapper实践</h4><p>分析完原理，我们还需要能够熟练的运用ObjectMapper来帮助我们完成解析功能，ObjectMapper能够帮助我们处理数据的方法有很多，这里我就先简单跟大家分享几种在项目中常用的方法，我已经将相关的<a href=\"https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master\">Demo</a>上传到github上，欢迎大家star</p>\n<h6 id=\"解析单一结构的模型\"><a href=\"#解析单一结构的模型\" class=\"headerlink\" title=\"解析单一结构的模型\"></a>解析单一结构的模型</h6><p>单一结构的模型解析比较简单，大家了解一下即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;objectmapper&quot;,</div><div class=\"line\">  &quot;age&quot;: 18,</div><div class=\"line\">  &quot;nickname&quot;: &quot;mapper&quot;,</div><div class=\"line\">  &quot;job&quot;: &quot;swifter&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们拿到如上所示的json数据时，只需要创建一个遵循<code>Mappable</code>的模型，并配置好解析路径即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class User: Mappable &#123;</div><div class=\"line\"></div><div class=\"line\">    var name: String?</div><div class=\"line\">    var age: Int?</div><div class=\"line\">    var nickname: String?</div><div class=\"line\">    var job: String?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        name &lt;- map[&quot;name&quot;]</div><div class=\"line\">        age &lt;- map[&quot;age&quot;]</div><div class=\"line\">        nickname &lt;- map[&quot;nickname&quot;]</div><div class=\"line\">        job &lt;- map[&quot;job&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 使用方法</div><div class=\"line\">let user = Mapper&lt;User&gt;().map(JSONString: json.rawString()!)</div></pre></td></tr></table></figure></p>\n<h6 id=\"解析模型中嵌套模型的情况\"><a href=\"#解析模型中嵌套模型的情况\" class=\"headerlink\" title=\"解析模型中嵌套模型的情况\"></a>解析模型中嵌套模型的情况</h6><p>有时候我们拿到的json数据嵌套了好几层的结构，而我们刚好也需要逐层解析拿到每个模型的数据，下面我就通过一个两层结构给大家演示一下处理的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;weather&quot;: &quot;sun&quot;,</div><div class=\"line\">    &quot;temperature&quot;: &#123;</div><div class=\"line\">        &quot;celsius&quot;: 70,</div><div class=\"line\">        &quot;fahrenheit&quot;: 34</div><div class=\"line\">    &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正如上面的json数据所示，我们需要创建一个weather模型，同时包含一个temperature模型来解析json数据，这时我们就需要运用泛型来帮助我们达到嵌套的目的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Weather&lt;T: Mappable&gt;: Mappable &#123;</div><div class=\"line\"></div><div class=\"line\">    var weather: String?</div><div class=\"line\">    var temperature: T?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        weather &lt;- map[&quot;weather&quot;]</div><div class=\"line\">        temperature &lt;- map[&quot;temperature&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Temperature: Mappable &#123;</div><div class=\"line\">    </div><div class=\"line\">    var celsius: Double?</div><div class=\"line\">    var fahrenheit: Double?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        celsius &lt;- map[&quot;celsius&quot;]</div><div class=\"line\">        fahrenheit &lt;- map[&quot;fahrenheit&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 使用方法如下</div><div class=\"line\">let weather = Mapper&lt;Weather&lt;Temperature&gt;&gt;().map(JSONString: json.rawString()!)</div></pre></td></tr></table></figure></p>\n<h6 id=\"解析模型中嵌套模型但是我们只需要拿到子模型的属性值\"><a href=\"#解析模型中嵌套模型但是我们只需要拿到子模型的属性值\" class=\"headerlink\" title=\"解析模型中嵌套模型但是我们只需要拿到子模型的属性值\"></a>解析模型中嵌套模型但是我们只需要拿到子模型的属性值</h6><p>有些json数据嵌套的内容我们不需要分模型来获取，只需要将属性统一到一个模型中使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;distance&quot;: &#123;</div><div class=\"line\">        &quot;text&quot;: &quot;102 ft&quot;,</div><div class=\"line\">        &quot;value&quot;: 31</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Distance: Mappable &#123;</div><div class=\"line\">    var text: String?</div><div class=\"line\">    var value: Int?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        text &lt;- map[&quot;distance.text&quot;]</div><div class=\"line\">        value &lt;- map[&quot;distance.value&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>####### 解析指定的一个数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;status&quot;: &quot;200&quot;,</div><div class=\"line\">    &quot;msg&quot;: &quot;success&quot;,</div><div class=\"line\">    &quot;features&quot;: [</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;json解析&quot;</div><div class=\"line\">       &#125;,</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;模型转换&quot;</div><div class=\"line\">       &#125;,</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;数据处理&quot;</div><div class=\"line\">       &#125;,</div><div class=\"line\">       &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;mapper进阶&quot;</div><div class=\"line\">       &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过我们拿到的返回结果如上面的代码段所示，features是我们真正关心的数据，它是一个数组结构，我们期望能够得到的是一个数组，里面包含若干个feature模型</p>\n<p>首先我们必不可少的就是要创建一个Feature模型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Feature: Mappable &#123;</div><div class=\"line\"></div><div class=\"line\">    var name: String?</div><div class=\"line\">    </div><div class=\"line\">    required init?(map: Map) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func mapping(map: Map) &#123;</div><div class=\"line\">        name &lt;- map[&quot;name&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在解析这个JSON数据时，我们可以忽略掉其他信息，先获取features对应的json数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let featureJson = json[&quot;features&quot;];</div></pre></td></tr></table></figure></p>\n<p>然后只需要使用Mapper的高级用法<code>mapArray</code>方法即可直接得到数组对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let features = Mapper&lt;Feature&gt;().mapArray(JSONString: featureJson.rawString()!)</div></pre></td></tr></table></figure></p>\n<p>ObjectMapper的高级用法还有很多，掌握上面的这些用法基本已经可以在项目中使用ObjectMapper达到我们的需求了，后面有时间我会在此博客和<a href=\"https://github.com/luzhiyongGit/ObjectMapperDemo/tree/master\">Demo</a>基础上更新更多的用法供大家参考</p>\n"},{"title":"Xcode9新特性汇总","date":"2017-12-14T11:19:00.000Z","_content":"新版的Xcode 9正式发布了，今天我也将Xcode进行了升级。这次的Xcode更新给我们带来了不少的新特性，这里我进行一个简单的汇总。\n\n## Main Thread Checker\n\nXcode 9现在会自动检测UI操作是否在主线程了，一旦代码运行到在非主线程操作UI时就会警告提示，相关代码会高亮，特别方便定位\n\n![Xcode9非主线程操作UI2.png](http://upload-images.jianshu.io/upload_images/1479547-ae5b514cae24218c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Xcode9非主线程操作UI.png](http://upload-images.jianshu.io/upload_images/1479547-667852563144f730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以前遇到这种在非主线程操作UI的情况，问题定位相对比较难，需要排查才能找到，现在Xcode 9 给我们提供了非常方便的支持\n\n## Swift Language Version 支持 4.0和3.2\n\nXcode 9使用Swift 4编译器，同时支持切换到Swift 3.2，开发者可以根据项目需要选择Swift语言版本\n\n![Xcode9swift语言选择.png](http://upload-images.jianshu.io/upload_images/1479547-22e7d4510d174243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 项目文件路径与本地文件路径自动保持统一\n\n在以前，为了保证项目文件路径和文件系统中的路径保持一致，我们通常是先在本地路径创建文件夹，然后添加到项目中，现在Xcode 9 将项目文件和文件系统进行了统一，我们可以直接在项目中创建文件或者直接拖拽改变文件位置时，也会相应的改变此文件在文件系统中的位置\n\n## Refactor功能改进\n\n`Refactor`是Xcode一直都提供的一个功能，不过在Xcode 9中进行了优化，Xcode 9将相关代码直接铺在代码编辑器里面，只要滚动编辑框，就可以轻松的看到即将影响到的所有地方，非常的清晰\n\n![xcode9refactor.png](http://upload-images.jianshu.io/upload_images/1479547-32674d7c60b80bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Named Color\n\nXcode 9支持在xcassets里添加颜色，这样就可以直接在代码或Storyboard里引用这个颜色了，这就非常有利于项目主题颜色的更换\n\n![named-colors.png](http://upload-images.jianshu.io/upload_images/1479547-4fcc16fe299d6ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 模拟器升级\n\nXcode 9模拟器又改回了之前的拟物化，而且现在支持多个模拟器同时运行，这就对多屏调试方便了很多\n\n![xcode9simulator.png](http://upload-images.jianshu.io/upload_images/1479547-b9e5bf3b94af0fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 全新的构建系统\n\nXcode 9提供了一个全新的构建系统，这次的构建系统完全使用Swift语言写成，基于Apple的[llbuild]( https://github.com/apple/swift-llbuild )引擎，新的构建系统默认是不开启的，我们可以通过File -> Project Settings 或 File -> Workspace Settings 来切换构建系统\n\n![xcode9build.png](http://upload-images.jianshu.io/upload_images/1479547-58d40d4c79ce3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 深度集成Github\n\nXcode 9针对Github做了定制化的集成，在Xcode的Preference -> Account 可以添加github账号，这样就能看到完整的项目记录和分支情况\n\n![xcode9github.png](http://upload-images.jianshu.io/upload_images/1479547-7cab79d2f8ebe53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","source":"_posts/Xcode9新特性汇总.md","raw":"title: Xcode9新特性汇总\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2017-12-14 19:19:00\n---\n新版的Xcode 9正式发布了，今天我也将Xcode进行了升级。这次的Xcode更新给我们带来了不少的新特性，这里我进行一个简单的汇总。\n\n## Main Thread Checker\n\nXcode 9现在会自动检测UI操作是否在主线程了，一旦代码运行到在非主线程操作UI时就会警告提示，相关代码会高亮，特别方便定位\n\n![Xcode9非主线程操作UI2.png](http://upload-images.jianshu.io/upload_images/1479547-ae5b514cae24218c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Xcode9非主线程操作UI.png](http://upload-images.jianshu.io/upload_images/1479547-667852563144f730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以前遇到这种在非主线程操作UI的情况，问题定位相对比较难，需要排查才能找到，现在Xcode 9 给我们提供了非常方便的支持\n\n## Swift Language Version 支持 4.0和3.2\n\nXcode 9使用Swift 4编译器，同时支持切换到Swift 3.2，开发者可以根据项目需要选择Swift语言版本\n\n![Xcode9swift语言选择.png](http://upload-images.jianshu.io/upload_images/1479547-22e7d4510d174243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 项目文件路径与本地文件路径自动保持统一\n\n在以前，为了保证项目文件路径和文件系统中的路径保持一致，我们通常是先在本地路径创建文件夹，然后添加到项目中，现在Xcode 9 将项目文件和文件系统进行了统一，我们可以直接在项目中创建文件或者直接拖拽改变文件位置时，也会相应的改变此文件在文件系统中的位置\n\n## Refactor功能改进\n\n`Refactor`是Xcode一直都提供的一个功能，不过在Xcode 9中进行了优化，Xcode 9将相关代码直接铺在代码编辑器里面，只要滚动编辑框，就可以轻松的看到即将影响到的所有地方，非常的清晰\n\n![xcode9refactor.png](http://upload-images.jianshu.io/upload_images/1479547-32674d7c60b80bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Named Color\n\nXcode 9支持在xcassets里添加颜色，这样就可以直接在代码或Storyboard里引用这个颜色了，这就非常有利于项目主题颜色的更换\n\n![named-colors.png](http://upload-images.jianshu.io/upload_images/1479547-4fcc16fe299d6ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 模拟器升级\n\nXcode 9模拟器又改回了之前的拟物化，而且现在支持多个模拟器同时运行，这就对多屏调试方便了很多\n\n![xcode9simulator.png](http://upload-images.jianshu.io/upload_images/1479547-b9e5bf3b94af0fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 全新的构建系统\n\nXcode 9提供了一个全新的构建系统，这次的构建系统完全使用Swift语言写成，基于Apple的[llbuild]( https://github.com/apple/swift-llbuild )引擎，新的构建系统默认是不开启的，我们可以通过File -> Project Settings 或 File -> Workspace Settings 来切换构建系统\n\n![xcode9build.png](http://upload-images.jianshu.io/upload_images/1479547-58d40d4c79ce3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 深度集成Github\n\nXcode 9针对Github做了定制化的集成，在Xcode的Preference -> Account 可以添加github账号，这样就能看到完整的项目记录和分支情况\n\n![xcode9github.png](http://upload-images.jianshu.io/upload_images/1479547-7cab79d2f8ebe53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","slug":"Xcode9新特性汇总","published":1,"updated":"2018-08-31T09:41:55.071Z","_id":"cjlhoqwi3001bkj79qhx9n4hi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>新版的Xcode 9正式发布了，今天我也将Xcode进行了升级。这次的Xcode更新给我们带来了不少的新特性，这里我进行一个简单的汇总。</p>\n<h2 id=\"Main-Thread-Checker\"><a href=\"#Main-Thread-Checker\" class=\"headerlink\" title=\"Main Thread Checker\"></a>Main Thread Checker</h2><p>Xcode 9现在会自动检测UI操作是否在主线程了，一旦代码运行到在非主线程操作UI时就会警告提示，相关代码会高亮，特别方便定位</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-ae5b514cae24218c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode9非主线程操作UI2.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-667852563144f730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode9非主线程操作UI.png\"></p>\n<p>以前遇到这种在非主线程操作UI的情况，问题定位相对比较难，需要排查才能找到，现在Xcode 9 给我们提供了非常方便的支持</p>\n<h2 id=\"Swift-Language-Version-支持-4-0和3-2\"><a href=\"#Swift-Language-Version-支持-4-0和3-2\" class=\"headerlink\" title=\"Swift Language Version 支持 4.0和3.2\"></a>Swift Language Version 支持 4.0和3.2</h2><p>Xcode 9使用Swift 4编译器，同时支持切换到Swift 3.2，开发者可以根据项目需要选择Swift语言版本</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-22e7d4510d174243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode9swift语言选择.png\"></p>\n<h2 id=\"项目文件路径与本地文件路径自动保持统一\"><a href=\"#项目文件路径与本地文件路径自动保持统一\" class=\"headerlink\" title=\"项目文件路径与本地文件路径自动保持统一\"></a>项目文件路径与本地文件路径自动保持统一</h2><p>在以前，为了保证项目文件路径和文件系统中的路径保持一致，我们通常是先在本地路径创建文件夹，然后添加到项目中，现在Xcode 9 将项目文件和文件系统进行了统一，我们可以直接在项目中创建文件或者直接拖拽改变文件位置时，也会相应的改变此文件在文件系统中的位置</p>\n<h2 id=\"Refactor功能改进\"><a href=\"#Refactor功能改进\" class=\"headerlink\" title=\"Refactor功能改进\"></a>Refactor功能改进</h2><p><code>Refactor</code>是Xcode一直都提供的一个功能，不过在Xcode 9中进行了优化，Xcode 9将相关代码直接铺在代码编辑器里面，只要滚动编辑框，就可以轻松的看到即将影响到的所有地方，非常的清晰</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-32674d7c60b80bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9refactor.png\"></p>\n<h2 id=\"Named-Color\"><a href=\"#Named-Color\" class=\"headerlink\" title=\"Named Color\"></a>Named Color</h2><p>Xcode 9支持在xcassets里添加颜色，这样就可以直接在代码或Storyboard里引用这个颜色了，这就非常有利于项目主题颜色的更换</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-4fcc16fe299d6ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"named-colors.png\"></p>\n<h2 id=\"模拟器升级\"><a href=\"#模拟器升级\" class=\"headerlink\" title=\"模拟器升级\"></a>模拟器升级</h2><p>Xcode 9模拟器又改回了之前的拟物化，而且现在支持多个模拟器同时运行，这就对多屏调试方便了很多</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-b9e5bf3b94af0fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9simulator.png\"></p>\n<h2 id=\"全新的构建系统\"><a href=\"#全新的构建系统\" class=\"headerlink\" title=\"全新的构建系统\"></a>全新的构建系统</h2><p>Xcode 9提供了一个全新的构建系统，这次的构建系统完全使用Swift语言写成，基于Apple的<a href=\"https://github.com/apple/swift-llbuild\" target=\"_blank\" rel=\"external\">llbuild</a>引擎，新的构建系统默认是不开启的，我们可以通过File -&gt; Project Settings 或 File -&gt; Workspace Settings 来切换构建系统</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-58d40d4c79ce3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9build.png\"></p>\n<h2 id=\"深度集成Github\"><a href=\"#深度集成Github\" class=\"headerlink\" title=\"深度集成Github\"></a>深度集成Github</h2><p>Xcode 9针对Github做了定制化的集成，在Xcode的Preference -&gt; Account 可以添加github账号，这样就能看到完整的项目记录和分支情况</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-7cab79d2f8ebe53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9github.png\"></p>\n","excerpt":"","more":"<p>新版的Xcode 9正式发布了，今天我也将Xcode进行了升级。这次的Xcode更新给我们带来了不少的新特性，这里我进行一个简单的汇总。</p>\n<h2 id=\"Main-Thread-Checker\"><a href=\"#Main-Thread-Checker\" class=\"headerlink\" title=\"Main Thread Checker\"></a>Main Thread Checker</h2><p>Xcode 9现在会自动检测UI操作是否在主线程了，一旦代码运行到在非主线程操作UI时就会警告提示，相关代码会高亮，特别方便定位</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-ae5b514cae24218c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode9非主线程操作UI2.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-667852563144f730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode9非主线程操作UI.png\"></p>\n<p>以前遇到这种在非主线程操作UI的情况，问题定位相对比较难，需要排查才能找到，现在Xcode 9 给我们提供了非常方便的支持</p>\n<h2 id=\"Swift-Language-Version-支持-4-0和3-2\"><a href=\"#Swift-Language-Version-支持-4-0和3-2\" class=\"headerlink\" title=\"Swift Language Version 支持 4.0和3.2\"></a>Swift Language Version 支持 4.0和3.2</h2><p>Xcode 9使用Swift 4编译器，同时支持切换到Swift 3.2，开发者可以根据项目需要选择Swift语言版本</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-22e7d4510d174243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Xcode9swift语言选择.png\"></p>\n<h2 id=\"项目文件路径与本地文件路径自动保持统一\"><a href=\"#项目文件路径与本地文件路径自动保持统一\" class=\"headerlink\" title=\"项目文件路径与本地文件路径自动保持统一\"></a>项目文件路径与本地文件路径自动保持统一</h2><p>在以前，为了保证项目文件路径和文件系统中的路径保持一致，我们通常是先在本地路径创建文件夹，然后添加到项目中，现在Xcode 9 将项目文件和文件系统进行了统一，我们可以直接在项目中创建文件或者直接拖拽改变文件位置时，也会相应的改变此文件在文件系统中的位置</p>\n<h2 id=\"Refactor功能改进\"><a href=\"#Refactor功能改进\" class=\"headerlink\" title=\"Refactor功能改进\"></a>Refactor功能改进</h2><p><code>Refactor</code>是Xcode一直都提供的一个功能，不过在Xcode 9中进行了优化，Xcode 9将相关代码直接铺在代码编辑器里面，只要滚动编辑框，就可以轻松的看到即将影响到的所有地方，非常的清晰</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-32674d7c60b80bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9refactor.png\"></p>\n<h2 id=\"Named-Color\"><a href=\"#Named-Color\" class=\"headerlink\" title=\"Named Color\"></a>Named Color</h2><p>Xcode 9支持在xcassets里添加颜色，这样就可以直接在代码或Storyboard里引用这个颜色了，这就非常有利于项目主题颜色的更换</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-4fcc16fe299d6ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"named-colors.png\"></p>\n<h2 id=\"模拟器升级\"><a href=\"#模拟器升级\" class=\"headerlink\" title=\"模拟器升级\"></a>模拟器升级</h2><p>Xcode 9模拟器又改回了之前的拟物化，而且现在支持多个模拟器同时运行，这就对多屏调试方便了很多</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-b9e5bf3b94af0fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9simulator.png\"></p>\n<h2 id=\"全新的构建系统\"><a href=\"#全新的构建系统\" class=\"headerlink\" title=\"全新的构建系统\"></a>全新的构建系统</h2><p>Xcode 9提供了一个全新的构建系统，这次的构建系统完全使用Swift语言写成，基于Apple的<a href=\"https://github.com/apple/swift-llbuild\">llbuild</a>引擎，新的构建系统默认是不开启的，我们可以通过File -&gt; Project Settings 或 File -&gt; Workspace Settings 来切换构建系统</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-58d40d4c79ce3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9build.png\"></p>\n<h2 id=\"深度集成Github\"><a href=\"#深度集成Github\" class=\"headerlink\" title=\"深度集成Github\"></a>深度集成Github</h2><p>Xcode 9针对Github做了定制化的集成，在Xcode的Preference -&gt; Account 可以添加github账号，这样就能看到完整的项目记录和分支情况</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-7cab79d2f8ebe53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"xcode9github.png\"></p>\n"},{"title":"iOS--让子View不响应父View的手势","date":"2016-10-24T05:57:00.000Z","_content":"\n在项目中遇到一个问题，父View上添加的手势事件在子View中也会响应，通过搜索后找到了解决方案，接下来作一个小总结，方便以后遇到相同问题时查找。\n解决思路：手势事件有一个代理方法，`- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch`，我们就是要通过这个代理方法屏蔽掉子View上的事件响应。\n\n```\n - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {\n    if ([touch.view isDescendantOfView:你想屏蔽掉手势的子视图]) {\n     return NO;\n     }\n     return YES;\n    } \n```\n\n","source":"_posts/iOS-让子View不响应父View的手势.md","raw":"title: iOS--让子View不响应父View的手势\ntags:\n  - iOS进阶\n  - ''\ncategories:\n  - iOS\ndate: 2016-10-24 13:57:00\n---\n\n在项目中遇到一个问题，父View上添加的手势事件在子View中也会响应，通过搜索后找到了解决方案，接下来作一个小总结，方便以后遇到相同问题时查找。\n解决思路：手势事件有一个代理方法，`- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch`，我们就是要通过这个代理方法屏蔽掉子View上的事件响应。\n\n```\n - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {\n    if ([touch.view isDescendantOfView:你想屏蔽掉手势的子视图]) {\n     return NO;\n     }\n     return YES;\n    } \n```\n\n","slug":"iOS-让子View不响应父View的手势","published":1,"updated":"2018-08-31T09:51:17.560Z","_id":"cjlhoqwi5001dkj79jn5rr9wg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在项目中遇到一个问题，父View上添加的手势事件在子View中也会响应，通过搜索后找到了解决方案，接下来作一个小总结，方便以后遇到相同问题时查找。<br>解决思路：手势事件有一个代理方法，<code>- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch</code>，我们就是要通过这个代理方法屏蔽掉子View上的事件响应。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch &#123;</div><div class=\"line\">   if ([touch.view isDescendantOfView:你想屏蔽掉手势的子视图]) &#123;</div><div class=\"line\">    return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>在项目中遇到一个问题，父View上添加的手势事件在子View中也会响应，通过搜索后找到了解决方案，接下来作一个小总结，方便以后遇到相同问题时查找。<br>解决思路：手势事件有一个代理方法，<code>- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch</code>，我们就是要通过这个代理方法屏蔽掉子View上的事件响应。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch &#123;</div><div class=\"line\">   if ([touch.view isDescendantOfView:你想屏蔽掉手势的子视图]) &#123;</div><div class=\"line\">    return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n"},{"title":"Xcode统计整个项目代码行数","date":"2017-02-20T03:55:00.000Z","_content":"\n一行命令，统计出项目中每个源代码文件的行数以及总行数\n```\nfind . \"(\" -name \"*.m\" -or -name \"*.mm\" -or -name \"*.cpp\" -or -name \"*.h\" -or -name \"*.rss\" \")\" -print | xargs wc -l\n```\n","source":"_posts/Xcode统计整个项目代码行数.md","raw":"title: Xcode统计整个项目代码行数\ntags:\n  - iOS技巧\n  - ''\ncategories:\n  - iOS\ndate: 2017-02-20 11:55:00\n---\n\n一行命令，统计出项目中每个源代码文件的行数以及总行数\n```\nfind . \"(\" -name \"*.m\" -or -name \"*.mm\" -or -name \"*.cpp\" -or -name \"*.h\" -or -name \"*.rss\" \")\" -print | xargs wc -l\n```\n","slug":"Xcode统计整个项目代码行数","published":1,"updated":"2018-08-31T09:47:23.599Z","_id":"cjlhoqwi7001ikj793z75znx6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一行命令，统计出项目中每个源代码文件的行数以及总行数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; &quot;)&quot; -print | xargs wc -l</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>一行命令，统计出项目中每个源代码文件的行数以及总行数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; &quot;)&quot; -print | xargs wc -l</div></pre></td></tr></table></figure></p>\n"},{"title":"iOS10系统下的推送开发","date":"2016-11-01T03:39:00.000Z","_content":"\niOS10系统发布后，推送功能发生了很多变化，作为iOS开发者就需要适配这些变化，这里对于如果结合极光推送适配iOS10系统进行一个简单的总结，方便在对其他项目进行适配时使用。\n\n### 相关配置\n\n1. 开启`Push Notifications`功能\n   \n   ![功能开关](/images/iOS之iOS10系统下的推送开发_1.png)\n\n2. 添加`UserNotifications.framework`\n\n   ![新增系统库](/images/iOS之iOS10系统下的推送开发_2.png)\n\n### 代码适配\n\n```\n// 注册推送通知\n// iOS8系统以前用来注册一个远程推送通知，当我们调用这个方法时，我们就在Apple Push Notification service上进行了设备注册\n    [[UIApplication sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound];\n// iOS8 ~ iOS10 \n    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];\n    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];\n    [[UIApplication sharedApplication] registerForRemoteNotifications];\n    \n// iOS10\n    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];\n    \n    [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!error) {\n            NSLog(@\"request authorization success!\");\n            [[UIApplication sharedApplication] registerForRemoteNotifications];\n        }\n    }];\n\n```\n\n```\n// 利用极光推送注册推送通知\n// iOS10 Before\n    \n    [JPUSHService registerForRemoteNotificationTypes:(UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert) categories:nil];\n    \n// iOS10\n    \n    JPUSHRegisterEntity *entity = [[JPUSHRegisterEntity alloc] init];\n    entity.types = UNAuthorizationOptionAlert | UNAuthorizationOptionSound | UNAuthorizationOptionBadge;\n    [JPUSHService registerForRemoteNotificationConfig:entity delegate:self];\n    \n// 注册极光推送\n    [JPUSHService setupWithOption:launchOptions appKey:@\"\" channel:@\"\" apsForProduction:YES];\n```","source":"_posts/iOS10系统下的推送开发.md","raw":"title: iOS10系统下的推送开发\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2016-11-01 11:39:00\n---\n\niOS10系统发布后，推送功能发生了很多变化，作为iOS开发者就需要适配这些变化，这里对于如果结合极光推送适配iOS10系统进行一个简单的总结，方便在对其他项目进行适配时使用。\n\n### 相关配置\n\n1. 开启`Push Notifications`功能\n   \n   ![功能开关](/images/iOS之iOS10系统下的推送开发_1.png)\n\n2. 添加`UserNotifications.framework`\n\n   ![新增系统库](/images/iOS之iOS10系统下的推送开发_2.png)\n\n### 代码适配\n\n```\n// 注册推送通知\n// iOS8系统以前用来注册一个远程推送通知，当我们调用这个方法时，我们就在Apple Push Notification service上进行了设备注册\n    [[UIApplication sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound];\n// iOS8 ~ iOS10 \n    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];\n    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];\n    [[UIApplication sharedApplication] registerForRemoteNotifications];\n    \n// iOS10\n    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];\n    \n    [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!error) {\n            NSLog(@\"request authorization success!\");\n            [[UIApplication sharedApplication] registerForRemoteNotifications];\n        }\n    }];\n\n```\n\n```\n// 利用极光推送注册推送通知\n// iOS10 Before\n    \n    [JPUSHService registerForRemoteNotificationTypes:(UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert) categories:nil];\n    \n// iOS10\n    \n    JPUSHRegisterEntity *entity = [[JPUSHRegisterEntity alloc] init];\n    entity.types = UNAuthorizationOptionAlert | UNAuthorizationOptionSound | UNAuthorizationOptionBadge;\n    [JPUSHService registerForRemoteNotificationConfig:entity delegate:self];\n    \n// 注册极光推送\n    [JPUSHService setupWithOption:launchOptions appKey:@\"\" channel:@\"\" apsForProduction:YES];\n```","slug":"iOS10系统下的推送开发","published":1,"updated":"2018-08-31T09:53:24.387Z","_id":"cjlhoqwi8001lkj79a0036q8i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>iOS10系统发布后，推送功能发生了很多变化，作为iOS开发者就需要适配这些变化，这里对于如果结合极光推送适配iOS10系统进行一个简单的总结，方便在对其他项目进行适配时使用。</p>\n<h3 id=\"相关配置\"><a href=\"#相关配置\" class=\"headerlink\" title=\"相关配置\"></a>相关配置</h3><ol>\n<li><p>开启<code>Push Notifications</code>功能</p>\n<p><img src=\"/images/iOS之iOS10系统下的推送开发_1.png\" alt=\"功能开关\"></p>\n</li>\n<li><p>添加<code>UserNotifications.framework</code></p>\n<p><img src=\"/images/iOS之iOS10系统下的推送开发_2.png\" alt=\"新增系统库\"></p>\n</li>\n</ol>\n<h3 id=\"代码适配\"><a href=\"#代码适配\" class=\"headerlink\" title=\"代码适配\"></a>代码适配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 注册推送通知</div><div class=\"line\">// iOS8系统以前用来注册一个远程推送通知，当我们调用这个方法时，我们就在Apple Push Notification service上进行了设备注册</div><div class=\"line\">    [[UIApplication sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound];</div><div class=\"line\">// iOS8 ~ iOS10 </div><div class=\"line\">    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];</div><div class=\"line\">    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];</div><div class=\"line\">    [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class=\"line\">    </div><div class=\"line\">// iOS10</div><div class=\"line\">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</div><div class=\"line\">    </div><div class=\"line\">    [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</div><div class=\"line\">        if (!error) &#123;</div><div class=\"line\">            NSLog(@&quot;request authorization success!&quot;);</div><div class=\"line\">            [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 利用极光推送注册推送通知</div><div class=\"line\">// iOS10 Before</div><div class=\"line\">    </div><div class=\"line\">    [JPUSHService registerForRemoteNotificationTypes:(UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert) categories:nil];</div><div class=\"line\">    </div><div class=\"line\">// iOS10</div><div class=\"line\">    </div><div class=\"line\">    JPUSHRegisterEntity *entity = [[JPUSHRegisterEntity alloc] init];</div><div class=\"line\">    entity.types = UNAuthorizationOptionAlert | UNAuthorizationOptionSound | UNAuthorizationOptionBadge;</div><div class=\"line\">    [JPUSHService registerForRemoteNotificationConfig:entity delegate:self];</div><div class=\"line\">    </div><div class=\"line\">// 注册极光推送</div><div class=\"line\">    [JPUSHService setupWithOption:launchOptions appKey:@&quot;&quot; channel:@&quot;&quot; apsForProduction:YES];</div></pre></td></tr></table></figure>","excerpt":"","more":"<p>iOS10系统发布后，推送功能发生了很多变化，作为iOS开发者就需要适配这些变化，这里对于如果结合极光推送适配iOS10系统进行一个简单的总结，方便在对其他项目进行适配时使用。</p>\n<h3 id=\"相关配置\"><a href=\"#相关配置\" class=\"headerlink\" title=\"相关配置\"></a>相关配置</h3><ol>\n<li><p>开启<code>Push Notifications</code>功能</p>\n<p><img src=\"/images/iOS之iOS10系统下的推送开发_1.png\" alt=\"功能开关\"></p>\n</li>\n<li><p>添加<code>UserNotifications.framework</code></p>\n<p><img src=\"/images/iOS之iOS10系统下的推送开发_2.png\" alt=\"新增系统库\"></p>\n</li>\n</ol>\n<h3 id=\"代码适配\"><a href=\"#代码适配\" class=\"headerlink\" title=\"代码适配\"></a>代码适配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 注册推送通知</div><div class=\"line\">// iOS8系统以前用来注册一个远程推送通知，当我们调用这个方法时，我们就在Apple Push Notification service上进行了设备注册</div><div class=\"line\">    [[UIApplication sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound];</div><div class=\"line\">// iOS8 ~ iOS10 </div><div class=\"line\">    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];</div><div class=\"line\">    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];</div><div class=\"line\">    [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class=\"line\">    </div><div class=\"line\">// iOS10</div><div class=\"line\">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</div><div class=\"line\">    </div><div class=\"line\">    [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</div><div class=\"line\">        if (!error) &#123;</div><div class=\"line\">            NSLog(@&quot;request authorization success!&quot;);</div><div class=\"line\">            [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 利用极光推送注册推送通知</div><div class=\"line\">// iOS10 Before</div><div class=\"line\">    </div><div class=\"line\">    [JPUSHService registerForRemoteNotificationTypes:(UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert) categories:nil];</div><div class=\"line\">    </div><div class=\"line\">// iOS10</div><div class=\"line\">    </div><div class=\"line\">    JPUSHRegisterEntity *entity = [[JPUSHRegisterEntity alloc] init];</div><div class=\"line\">    entity.types = UNAuthorizationOptionAlert | UNAuthorizationOptionSound | UNAuthorizationOptionBadge;</div><div class=\"line\">    [JPUSHService registerForRemoteNotificationConfig:entity delegate:self];</div><div class=\"line\">    </div><div class=\"line\">// 注册极光推送</div><div class=\"line\">    [JPUSHService setupWithOption:launchOptions appKey:@&quot;&quot; channel:@&quot;&quot; apsForProduction:YES];</div></pre></td></tr></table></figure>"},{"title":"iOS复制字符串到剪贴板","date":"2017-12-14T11:22:00.000Z","_content":"最近有一个小功能，需要自动帮用户将一些字符串复制到剪贴板中，其实实现比较简单，因为这个功能相对比较生僻，做一个简单记录\n\n```\nUIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\npasteboard.string = @\"你需要复制的字符串内容\";\n```","source":"_posts/iOS复制字符串到剪贴板.md","raw":"title: iOS复制字符串到剪贴板\ntags:\n  - iOS技术方案\ncategories:\n  - iOS\ndate: 2017-12-14 19:22:00\n---\n最近有一个小功能，需要自动帮用户将一些字符串复制到剪贴板中，其实实现比较简单，因为这个功能相对比较生僻，做一个简单记录\n\n```\nUIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\npasteboard.string = @\"你需要复制的字符串内容\";\n```","slug":"iOS复制字符串到剪贴板","published":1,"updated":"2018-08-31T09:36:48.963Z","_id":"cjlhoqwi9001qkj790v6p1vo9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近有一个小功能，需要自动帮用户将一些字符串复制到剪贴板中，其实实现比较简单，因为这个功能相对比较生僻，做一个简单记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];</div><div class=\"line\">pasteboard.string = @&quot;你需要复制的字符串内容&quot;;</div></pre></td></tr></table></figure>","excerpt":"","more":"<p>最近有一个小功能，需要自动帮用户将一些字符串复制到剪贴板中，其实实现比较简单，因为这个功能相对比较生僻，做一个简单记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];</div><div class=\"line\">pasteboard.string = @&quot;你需要复制的字符串内容&quot;;</div></pre></td></tr></table></figure>"},{"title":"iOS导航栏显示与隐藏控制","date":"2018-08-22T05:20:00.000Z","_content":"\n最近打算整理优化一下项目中对导航栏的显示与隐藏控制\n\n## 早期做法\n\n由于前期项目中需要隐藏导航栏的页面不多，早期采用的方案也比较简单，遵循谁要隐藏自己处理的原则，在需要隐藏的页面的`viewWillAppear`执行`[self.navigationController setNavigationBarHidden:YES animated:YES]`，`viewWillDisappear`执行`[self.navigationController setNavigationBarHidden:NO animated:YES]`，前期满足了需求，但是随着需要隐藏的页面越来越多，问题也逐渐暴露\n\n- 需要在`viewWillAppear`和`viewWillDisappear`控制导航栏的地方越来越多，不便于管理和维护\n- 容易出现人为疏忽，导致导航栏未按预期展现\n- 切换tabBar的情况下，导航栏有一个向上消失的动画\n\n## 升级做法\n\n鉴于早期方案存在的问题，我打算整理一下导航栏的实现方案\n\n我考虑了两个方案\n\n- 放弃使用原生navigationBar，改用自定义view，灵活控制导航栏的展现\n- 优化现有导航栏显示隐藏方案\n\n由于项目已经比较大，现在改自定义view成本太高，所以我打算先从现有方案的优化开始\n\n### 优化方案\n\n基于早期的`NavigationController`基类进行扩展\n\n```\nviewDidLoad() {\n    super.viewDidLoad()\n    \n    self.delegate = self\n}\n\nextension ZYNavigationController: UINavigationControllerDelegate {\n\n    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {\n        // 判断要显示的控制器是否是自己\n        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)\n        \n        self.setNavigationBarHidden(isHidden, animated: true)\n    }\n}\n```\n遵循`UINavigationControllerDelegate`，在`willShow viewController`方法内判断当前viewController是否需要隐藏导航栏，并根据判断结果设置。\n这样就能达到，controller在被加载到navigationController内，将要展现前，判断并控制导航栏的显示或隐藏。\n这里还有一个问题需要解决，那就是导航栏被隐藏后，手势返回功能就会失效，这里就需要我们支持，可以通过`interactivePopGestureRecognizer`来启动手势返回\n\n```\nviewDidLoad() {\n    super.viewDidLoad()\n    \n    self.delegate = self\n}\n\nextension ZYNavigationController: UINavigationControllerDelegate {\n\n    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {\n        // 判断要显示的控制器是否是自己\n        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)\n        \n        self.setNavigationBarHidden(isHidden, animated: true)\n        \n        if isHidden {\n            self.interactivePopGestureRecognizer?.delegate = self\n            self.interactivePopGestureRecognizer?.isEnabled = true\n        }\n    }\n}\n```","source":"_posts/iOS导航栏显示与隐藏控制.md","raw":"title: iOS导航栏显示与隐藏控制\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2018-08-22 13:20:00\n---\n\n最近打算整理优化一下项目中对导航栏的显示与隐藏控制\n\n## 早期做法\n\n由于前期项目中需要隐藏导航栏的页面不多，早期采用的方案也比较简单，遵循谁要隐藏自己处理的原则，在需要隐藏的页面的`viewWillAppear`执行`[self.navigationController setNavigationBarHidden:YES animated:YES]`，`viewWillDisappear`执行`[self.navigationController setNavigationBarHidden:NO animated:YES]`，前期满足了需求，但是随着需要隐藏的页面越来越多，问题也逐渐暴露\n\n- 需要在`viewWillAppear`和`viewWillDisappear`控制导航栏的地方越来越多，不便于管理和维护\n- 容易出现人为疏忽，导致导航栏未按预期展现\n- 切换tabBar的情况下，导航栏有一个向上消失的动画\n\n## 升级做法\n\n鉴于早期方案存在的问题，我打算整理一下导航栏的实现方案\n\n我考虑了两个方案\n\n- 放弃使用原生navigationBar，改用自定义view，灵活控制导航栏的展现\n- 优化现有导航栏显示隐藏方案\n\n由于项目已经比较大，现在改自定义view成本太高，所以我打算先从现有方案的优化开始\n\n### 优化方案\n\n基于早期的`NavigationController`基类进行扩展\n\n```\nviewDidLoad() {\n    super.viewDidLoad()\n    \n    self.delegate = self\n}\n\nextension ZYNavigationController: UINavigationControllerDelegate {\n\n    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {\n        // 判断要显示的控制器是否是自己\n        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)\n        \n        self.setNavigationBarHidden(isHidden, animated: true)\n    }\n}\n```\n遵循`UINavigationControllerDelegate`，在`willShow viewController`方法内判断当前viewController是否需要隐藏导航栏，并根据判断结果设置。\n这样就能达到，controller在被加载到navigationController内，将要展现前，判断并控制导航栏的显示或隐藏。\n这里还有一个问题需要解决，那就是导航栏被隐藏后，手势返回功能就会失效，这里就需要我们支持，可以通过`interactivePopGestureRecognizer`来启动手势返回\n\n```\nviewDidLoad() {\n    super.viewDidLoad()\n    \n    self.delegate = self\n}\n\nextension ZYNavigationController: UINavigationControllerDelegate {\n\n    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {\n        // 判断要显示的控制器是否是自己\n        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)\n        \n        self.setNavigationBarHidden(isHidden, animated: true)\n        \n        if isHidden {\n            self.interactivePopGestureRecognizer?.delegate = self\n            self.interactivePopGestureRecognizer?.isEnabled = true\n        }\n    }\n}\n```","slug":"iOS导航栏显示与隐藏控制","published":1,"updated":"2018-08-31T09:41:09.690Z","_id":"cjlhoqwil001tkj79qhf0uhew","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近打算整理优化一下项目中对导航栏的显示与隐藏控制</p>\n<h2 id=\"早期做法\"><a href=\"#早期做法\" class=\"headerlink\" title=\"早期做法\"></a>早期做法</h2><p>由于前期项目中需要隐藏导航栏的页面不多，早期采用的方案也比较简单，遵循谁要隐藏自己处理的原则，在需要隐藏的页面的<code>viewWillAppear</code>执行<code>[self.navigationController setNavigationBarHidden:YES animated:YES]</code>，<code>viewWillDisappear</code>执行<code>[self.navigationController setNavigationBarHidden:NO animated:YES]</code>，前期满足了需求，但是随着需要隐藏的页面越来越多，问题也逐渐暴露</p>\n<ul>\n<li>需要在<code>viewWillAppear</code>和<code>viewWillDisappear</code>控制导航栏的地方越来越多，不便于管理和维护</li>\n<li>容易出现人为疏忽，导致导航栏未按预期展现</li>\n<li>切换tabBar的情况下，导航栏有一个向上消失的动画</li>\n</ul>\n<h2 id=\"升级做法\"><a href=\"#升级做法\" class=\"headerlink\" title=\"升级做法\"></a>升级做法</h2><p>鉴于早期方案存在的问题，我打算整理一下导航栏的实现方案</p>\n<p>我考虑了两个方案</p>\n<ul>\n<li>放弃使用原生navigationBar，改用自定义view，灵活控制导航栏的展现</li>\n<li>优化现有导航栏显示隐藏方案</li>\n</ul>\n<p>由于项目已经比较大，现在改自定义view成本太高，所以我打算先从现有方案的优化开始</p>\n<h3 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h3><p>基于早期的<code>NavigationController</code>基类进行扩展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">viewDidLoad() &#123;</div><div class=\"line\">    super.viewDidLoad()</div><div class=\"line\">    </div><div class=\"line\">    self.delegate = self</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">extension ZYNavigationController: UINavigationControllerDelegate &#123;</div><div class=\"line\"></div><div class=\"line\">    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) &#123;</div><div class=\"line\">        // 判断要显示的控制器是否是自己</div><div class=\"line\">        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)</div><div class=\"line\">        </div><div class=\"line\">        self.setNavigationBarHidden(isHidden, animated: true)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遵循<code>UINavigationControllerDelegate</code>，在<code>willShow viewController</code>方法内判断当前viewController是否需要隐藏导航栏，并根据判断结果设置。<br>这样就能达到，controller在被加载到navigationController内，将要展现前，判断并控制导航栏的显示或隐藏。<br>这里还有一个问题需要解决，那就是导航栏被隐藏后，手势返回功能就会失效，这里就需要我们支持，可以通过<code>interactivePopGestureRecognizer</code>来启动手势返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">viewDidLoad() &#123;</div><div class=\"line\">    super.viewDidLoad()</div><div class=\"line\">    </div><div class=\"line\">    self.delegate = self</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">extension ZYNavigationController: UINavigationControllerDelegate &#123;</div><div class=\"line\"></div><div class=\"line\">    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) &#123;</div><div class=\"line\">        // 判断要显示的控制器是否是自己</div><div class=\"line\">        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)</div><div class=\"line\">        </div><div class=\"line\">        self.setNavigationBarHidden(isHidden, animated: true)</div><div class=\"line\">        </div><div class=\"line\">        if isHidden &#123;</div><div class=\"line\">            self.interactivePopGestureRecognizer?.delegate = self</div><div class=\"line\">            self.interactivePopGestureRecognizer?.isEnabled = true</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<p>最近打算整理优化一下项目中对导航栏的显示与隐藏控制</p>\n<h2 id=\"早期做法\"><a href=\"#早期做法\" class=\"headerlink\" title=\"早期做法\"></a>早期做法</h2><p>由于前期项目中需要隐藏导航栏的页面不多，早期采用的方案也比较简单，遵循谁要隐藏自己处理的原则，在需要隐藏的页面的<code>viewWillAppear</code>执行<code>[self.navigationController setNavigationBarHidden:YES animated:YES]</code>，<code>viewWillDisappear</code>执行<code>[self.navigationController setNavigationBarHidden:NO animated:YES]</code>，前期满足了需求，但是随着需要隐藏的页面越来越多，问题也逐渐暴露</p>\n<ul>\n<li>需要在<code>viewWillAppear</code>和<code>viewWillDisappear</code>控制导航栏的地方越来越多，不便于管理和维护</li>\n<li>容易出现人为疏忽，导致导航栏未按预期展现</li>\n<li>切换tabBar的情况下，导航栏有一个向上消失的动画</li>\n</ul>\n<h2 id=\"升级做法\"><a href=\"#升级做法\" class=\"headerlink\" title=\"升级做法\"></a>升级做法</h2><p>鉴于早期方案存在的问题，我打算整理一下导航栏的实现方案</p>\n<p>我考虑了两个方案</p>\n<ul>\n<li>放弃使用原生navigationBar，改用自定义view，灵活控制导航栏的展现</li>\n<li>优化现有导航栏显示隐藏方案</li>\n</ul>\n<p>由于项目已经比较大，现在改自定义view成本太高，所以我打算先从现有方案的优化开始</p>\n<h3 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h3><p>基于早期的<code>NavigationController</code>基类进行扩展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">viewDidLoad() &#123;</div><div class=\"line\">    super.viewDidLoad()</div><div class=\"line\">    </div><div class=\"line\">    self.delegate = self</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">extension ZYNavigationController: UINavigationControllerDelegate &#123;</div><div class=\"line\"></div><div class=\"line\">    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) &#123;</div><div class=\"line\">        // 判断要显示的控制器是否是自己</div><div class=\"line\">        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)</div><div class=\"line\">        </div><div class=\"line\">        self.setNavigationBarHidden(isHidden, animated: true)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遵循<code>UINavigationControllerDelegate</code>，在<code>willShow viewController</code>方法内判断当前viewController是否需要隐藏导航栏，并根据判断结果设置。<br>这样就能达到，controller在被加载到navigationController内，将要展现前，判断并控制导航栏的显示或隐藏。<br>这里还有一个问题需要解决，那就是导航栏被隐藏后，手势返回功能就会失效，这里就需要我们支持，可以通过<code>interactivePopGestureRecognizer</code>来启动手势返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">viewDidLoad() &#123;</div><div class=\"line\">    super.viewDidLoad()</div><div class=\"line\">    </div><div class=\"line\">    self.delegate = self</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">extension ZYNavigationController: UINavigationControllerDelegate &#123;</div><div class=\"line\"></div><div class=\"line\">    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) &#123;</div><div class=\"line\">        // 判断要显示的控制器是否是自己</div><div class=\"line\">        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)</div><div class=\"line\">        </div><div class=\"line\">        self.setNavigationBarHidden(isHidden, animated: true)</div><div class=\"line\">        </div><div class=\"line\">        if isHidden &#123;</div><div class=\"line\">            self.interactivePopGestureRecognizer?.delegate = self</div><div class=\"line\">            self.interactivePopGestureRecognizer?.isEnabled = true</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"git命令行入门","date":"2016-08-31T11:43:00.000Z","_content":"\n本文结合项目开发中遇到的实际问题对git命令行的使用做一个简单的总结。\n\n### 常用命令\n\n1. 下载项目\n\n       git clone [url]\n\n2. 查看本地分支\n\n       git branch\n\n3. 查看远程分支\n\n       git branch -r\n\n4. 创建本地分支\n\n       git branch [branch]\n\n5. 切换本地分支\n\n       git checkout [branch]\n\n6. 拉取远程分支代码\n\n       git pull origin [remote-branch]\n\n7. 添加当前目录的所有文件到暂存区\n\n       git add .\n\n8. 提交暂存区到仓库区\n\n       git commit -m [message]\n\n9. 合并分支\n\n       git merge [branch]\n\n10. 提交本地分支代码\n\n      git push origin [remote-branch]\n\n### tag命令\n\n1. 列出所有tag\n\n       git tag\n\n2. 新建tag\n\n       # 在当前commit新建一个tag\n       git tag [tag]\n       \n       # 在指定commit新建一个tag\n       git tag [tag] [commit]\n\n3. 删除本地tag\n\n       git tag -d [tag]\n\n4. 删除远程tag\n\n       git push origin :refs/tags/[tag]\n\n5. 提交指定tag\n\n       git push [remote] [tag]\n\n6. 提交所有tag\n\n       git push --tags\n\n7. 基于某个tag新建一个分支\n\n       git checkout -b [branch] [tag]\n\n   ​    \n### 撤销命令\n\n1. 恢复暂存区的指定文件到工作区\n\n       git checkout [file]\n\n2. 恢复某个commit的指定文件到工作区\n\n       git checkout [commit] [file]\n\n3. 恢复暂存区的所有文件到工作区\n\n       git checkout .\n\n4. 重置暂存区的指定文件，与上一次commit保持一致，但是工作区不变\n\n       git reset [file]\n\n5. 重置暂存区和工作区，与上次commit保持一致\n\n       git reset --hard       \n   ​    \n### 删除命令\n\n1. 删除工作区的文件，并将这次删除放入暂存区\n\n       git rm [file1] [file2]  \n\n2. 停止追踪指定文件，但该文件会保留在工作区\n\n       git rm --cached [file]\n\n3. 删除本地分支\n\n       git branch -d [branch]\n\n4. 删除远程分支\n\n       git push origin --delete [remote-branch]\n\n       git branch -dr [remore-branch]\n\n5. 删除本地tag\n\n       git tag -d [tag]\n\n6. 删除远程tag\n\n       git push origin :refs/tags/[tag]\n\n#### 导出纯代码\n1. 导出纯代码\n```\ngit archive --format zip --output \"./output.zip\" master -0\n```\n\n#### 冲突解决\n\n1. 查看冲突\n\n   ```\n   git diff\n   ```\n\n2. 选择对方版本\n\n   ```\n   git checkout --theirs [conflict file]\n   ```\n\n3. 选择本地版本\n\n   ```\n   git checkout --ours [conflict flie]\n   ```\n\n### 参考链接\n\n[常用Git命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)","source":"_posts/git命令行入门.md","raw":"title: git命令行入门\ntags: []\ncategories:\n  - 工具\ndate: 2016-08-31 19:43:00\n---\n\n本文结合项目开发中遇到的实际问题对git命令行的使用做一个简单的总结。\n\n### 常用命令\n\n1. 下载项目\n\n       git clone [url]\n\n2. 查看本地分支\n\n       git branch\n\n3. 查看远程分支\n\n       git branch -r\n\n4. 创建本地分支\n\n       git branch [branch]\n\n5. 切换本地分支\n\n       git checkout [branch]\n\n6. 拉取远程分支代码\n\n       git pull origin [remote-branch]\n\n7. 添加当前目录的所有文件到暂存区\n\n       git add .\n\n8. 提交暂存区到仓库区\n\n       git commit -m [message]\n\n9. 合并分支\n\n       git merge [branch]\n\n10. 提交本地分支代码\n\n      git push origin [remote-branch]\n\n### tag命令\n\n1. 列出所有tag\n\n       git tag\n\n2. 新建tag\n\n       # 在当前commit新建一个tag\n       git tag [tag]\n       \n       # 在指定commit新建一个tag\n       git tag [tag] [commit]\n\n3. 删除本地tag\n\n       git tag -d [tag]\n\n4. 删除远程tag\n\n       git push origin :refs/tags/[tag]\n\n5. 提交指定tag\n\n       git push [remote] [tag]\n\n6. 提交所有tag\n\n       git push --tags\n\n7. 基于某个tag新建一个分支\n\n       git checkout -b [branch] [tag]\n\n   ​    \n### 撤销命令\n\n1. 恢复暂存区的指定文件到工作区\n\n       git checkout [file]\n\n2. 恢复某个commit的指定文件到工作区\n\n       git checkout [commit] [file]\n\n3. 恢复暂存区的所有文件到工作区\n\n       git checkout .\n\n4. 重置暂存区的指定文件，与上一次commit保持一致，但是工作区不变\n\n       git reset [file]\n\n5. 重置暂存区和工作区，与上次commit保持一致\n\n       git reset --hard       \n   ​    \n### 删除命令\n\n1. 删除工作区的文件，并将这次删除放入暂存区\n\n       git rm [file1] [file2]  \n\n2. 停止追踪指定文件，但该文件会保留在工作区\n\n       git rm --cached [file]\n\n3. 删除本地分支\n\n       git branch -d [branch]\n\n4. 删除远程分支\n\n       git push origin --delete [remote-branch]\n\n       git branch -dr [remore-branch]\n\n5. 删除本地tag\n\n       git tag -d [tag]\n\n6. 删除远程tag\n\n       git push origin :refs/tags/[tag]\n\n#### 导出纯代码\n1. 导出纯代码\n```\ngit archive --format zip --output \"./output.zip\" master -0\n```\n\n#### 冲突解决\n\n1. 查看冲突\n\n   ```\n   git diff\n   ```\n\n2. 选择对方版本\n\n   ```\n   git checkout --theirs [conflict file]\n   ```\n\n3. 选择本地版本\n\n   ```\n   git checkout --ours [conflict flie]\n   ```\n\n### 参考链接\n\n[常用Git命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)","slug":"git命令行入门","published":1,"updated":"2018-08-31T09:50:19.168Z","_id":"cjlhoqwin001xkj79nh7dqh5f","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文结合项目开发中遇到的实际问题对git命令行的使用做一个简单的总结。</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ol>\n<li><p>下载项目</p>\n<pre><code>git clone [url]\n</code></pre></li>\n<li><p>查看本地分支</p>\n<pre><code>git branch\n</code></pre></li>\n<li><p>查看远程分支</p>\n<pre><code>git branch -r\n</code></pre></li>\n<li><p>创建本地分支</p>\n<pre><code>git branch [branch]\n</code></pre></li>\n<li><p>切换本地分支</p>\n<pre><code>git checkout [branch]\n</code></pre></li>\n<li><p>拉取远程分支代码</p>\n<pre><code>git pull origin [remote-branch]\n</code></pre></li>\n<li><p>添加当前目录的所有文件到暂存区</p>\n<pre><code>git add .\n</code></pre></li>\n<li><p>提交暂存区到仓库区</p>\n<pre><code>git commit -m [message]\n</code></pre></li>\n<li><p>合并分支</p>\n<pre><code>git merge [branch]\n</code></pre></li>\n<li><p>提交本地分支代码</p>\n<p>  git push origin [remote-branch]</p>\n</li>\n</ol>\n<h3 id=\"tag命令\"><a href=\"#tag命令\" class=\"headerlink\" title=\"tag命令\"></a>tag命令</h3><ol>\n<li><p>列出所有tag</p>\n<pre><code>git tag\n</code></pre></li>\n<li><p>新建tag</p>\n<pre><code># 在当前commit新建一个tag\ngit tag [tag]\n\n# 在指定commit新建一个tag\ngit tag [tag] [commit]\n</code></pre></li>\n<li><p>删除本地tag</p>\n<pre><code>git tag -d [tag]\n</code></pre></li>\n<li><p>删除远程tag</p>\n<pre><code>git push origin :refs/tags/[tag]\n</code></pre></li>\n<li><p>提交指定tag</p>\n<pre><code>git push [remote] [tag]\n</code></pre></li>\n<li><p>提交所有tag</p>\n<pre><code>git push --tags\n</code></pre></li>\n<li><p>基于某个tag新建一个分支</p>\n<pre><code>git checkout -b [branch] [tag]\n</code></pre><p>​    </p>\n<h3 id=\"撤销命令\"><a href=\"#撤销命令\" class=\"headerlink\" title=\"撤销命令\"></a>撤销命令</h3></li>\n<li><p>恢复暂存区的指定文件到工作区</p>\n<pre><code>git checkout [file]\n</code></pre></li>\n<li><p>恢复某个commit的指定文件到工作区</p>\n<pre><code>git checkout [commit] [file]\n</code></pre></li>\n<li><p>恢复暂存区的所有文件到工作区</p>\n<pre><code>git checkout .\n</code></pre></li>\n<li><p>重置暂存区的指定文件，与上一次commit保持一致，但是工作区不变</p>\n<pre><code>git reset [file]\n</code></pre></li>\n<li><p>重置暂存区和工作区，与上次commit保持一致</p>\n<pre><code>git reset --hard       \n</code></pre><p>​    </p>\n<h3 id=\"删除命令\"><a href=\"#删除命令\" class=\"headerlink\" title=\"删除命令\"></a>删除命令</h3></li>\n<li><p>删除工作区的文件，并将这次删除放入暂存区</p>\n<pre><code>git rm [file1] [file2]  \n</code></pre></li>\n<li><p>停止追踪指定文件，但该文件会保留在工作区</p>\n<pre><code>git rm --cached [file]\n</code></pre></li>\n<li><p>删除本地分支</p>\n<pre><code>git branch -d [branch]\n</code></pre></li>\n<li><p>删除远程分支</p>\n<pre><code>git push origin --delete [remote-branch]\n\ngit branch -dr [remore-branch]\n</code></pre></li>\n<li><p>删除本地tag</p>\n<pre><code>git tag -d [tag]\n</code></pre></li>\n<li><p>删除远程tag</p>\n<pre><code>git push origin :refs/tags/[tag]\n</code></pre></li>\n</ol>\n<h4 id=\"导出纯代码\"><a href=\"#导出纯代码\" class=\"headerlink\" title=\"导出纯代码\"></a>导出纯代码</h4><ol>\n<li>导出纯代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git archive --format zip --output &quot;./output.zip&quot; master -0</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h4><ol>\n<li><p>查看冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git diff</div></pre></td></tr></table></figure>\n</li>\n<li><p>选择对方版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout --theirs [conflict file]</div></pre></td></tr></table></figure>\n</li>\n<li><p>选择本地版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout --ours [conflict flie]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"external\">常用Git命令清单</a></p>\n","excerpt":"","more":"<p>本文结合项目开发中遇到的实际问题对git命令行的使用做一个简单的总结。</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ol>\n<li><p>下载项目</p>\n<pre><code>git clone [url]\n</code></pre></li>\n<li><p>查看本地分支</p>\n<pre><code>git branch\n</code></pre></li>\n<li><p>查看远程分支</p>\n<pre><code>git branch -r\n</code></pre></li>\n<li><p>创建本地分支</p>\n<pre><code>git branch [branch]\n</code></pre></li>\n<li><p>切换本地分支</p>\n<pre><code>git checkout [branch]\n</code></pre></li>\n<li><p>拉取远程分支代码</p>\n<pre><code>git pull origin [remote-branch]\n</code></pre></li>\n<li><p>添加当前目录的所有文件到暂存区</p>\n<pre><code>git add .\n</code></pre></li>\n<li><p>提交暂存区到仓库区</p>\n<pre><code>git commit -m [message]\n</code></pre></li>\n<li><p>合并分支</p>\n<pre><code>git merge [branch]\n</code></pre></li>\n<li><p>提交本地分支代码</p>\n<p>  git push origin [remote-branch]</p>\n</li>\n</ol>\n<h3 id=\"tag命令\"><a href=\"#tag命令\" class=\"headerlink\" title=\"tag命令\"></a>tag命令</h3><ol>\n<li><p>列出所有tag</p>\n<pre><code>git tag\n</code></pre></li>\n<li><p>新建tag</p>\n<pre><code># 在当前commit新建一个tag\ngit tag [tag]\n\n# 在指定commit新建一个tag\ngit tag [tag] [commit]\n</code></pre></li>\n<li><p>删除本地tag</p>\n<pre><code>git tag -d [tag]\n</code></pre></li>\n<li><p>删除远程tag</p>\n<pre><code>git push origin :refs/tags/[tag]\n</code></pre></li>\n<li><p>提交指定tag</p>\n<pre><code>git push [remote] [tag]\n</code></pre></li>\n<li><p>提交所有tag</p>\n<pre><code>git push --tags\n</code></pre></li>\n<li><p>基于某个tag新建一个分支</p>\n<pre><code>git checkout -b [branch] [tag]\n</code></pre><p>​    </p>\n<h3 id=\"撤销命令\"><a href=\"#撤销命令\" class=\"headerlink\" title=\"撤销命令\"></a>撤销命令</h3></li>\n<li><p>恢复暂存区的指定文件到工作区</p>\n<pre><code>git checkout [file]\n</code></pre></li>\n<li><p>恢复某个commit的指定文件到工作区</p>\n<pre><code>git checkout [commit] [file]\n</code></pre></li>\n<li><p>恢复暂存区的所有文件到工作区</p>\n<pre><code>git checkout .\n</code></pre></li>\n<li><p>重置暂存区的指定文件，与上一次commit保持一致，但是工作区不变</p>\n<pre><code>git reset [file]\n</code></pre></li>\n<li><p>重置暂存区和工作区，与上次commit保持一致</p>\n<pre><code>git reset --hard       \n</code></pre><p>​    </p>\n<h3 id=\"删除命令\"><a href=\"#删除命令\" class=\"headerlink\" title=\"删除命令\"></a>删除命令</h3></li>\n<li><p>删除工作区的文件，并将这次删除放入暂存区</p>\n<pre><code>git rm [file1] [file2]  \n</code></pre></li>\n<li><p>停止追踪指定文件，但该文件会保留在工作区</p>\n<pre><code>git rm --cached [file]\n</code></pre></li>\n<li><p>删除本地分支</p>\n<pre><code>git branch -d [branch]\n</code></pre></li>\n<li><p>删除远程分支</p>\n<pre><code>git push origin --delete [remote-branch]\n\ngit branch -dr [remore-branch]\n</code></pre></li>\n<li><p>删除本地tag</p>\n<pre><code>git tag -d [tag]\n</code></pre></li>\n<li><p>删除远程tag</p>\n<pre><code>git push origin :refs/tags/[tag]\n</code></pre></li>\n</ol>\n<h4 id=\"导出纯代码\"><a href=\"#导出纯代码\" class=\"headerlink\" title=\"导出纯代码\"></a>导出纯代码</h4><ol>\n<li>导出纯代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git archive --format zip --output &quot;./output.zip&quot; master -0</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h4><ol>\n<li><p>查看冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git diff</div></pre></td></tr></table></figure>\n</li>\n<li><p>选择对方版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout --theirs [conflict file]</div></pre></td></tr></table></figure>\n</li>\n<li><p>选择本地版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout --ours [conflict flie]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">常用Git命令清单</a></p>\n"},{"title":"iOS 11 开发者需要知道的改变","date":"2017-06-08T09:18:00.000Z","_content":"\n苹果在`WWDC 2017`披露了许多的iOS 11的新特性，作为iOS开发者有哪些改变是我们需要知道的呢？\n\n## iOS 11的发布时间\n在正式发布iOS 11之前，苹果通常会先提供一个可供开发者安装的版本，然后再进过几个版本公开发布的beta版，最终才会发布一个正式版本的iOS 11系统\n- 开发者beta版本： 已经发布\n- 公开发布的beta版本：六月底\n- 最终正式版本：秋季\n\n## iOS 11支持哪些设备\n- iPhone 5S, 6, 6 Plus, 6S Plus, SE, 7, 7 Plus\n- iPad Air and Air 2, iPad Mini 2, 3, 4, 5代 iPad，所有的 iPad Pro\n- 6代 iPod Touch\n\n## iOS 新增了哪些框架\n\n### Core ML\n\niOS 11中苹果新增了一个机器学习框架[Core ML](https://developer.apple.com/machine-learning/)，同时Apple也提供了[一系列的工具](https://developer.apple.com/documentation/coreml/converting_trained_models_to_core_ml)用来将各类机器学习的模型转换为Core ML可以理解的形式，从而帮助开发者轻松的在APP里使用前人训练出来的模型。\n\n### ARKit\n\n[ARKit](https://developer.apple.com/documentation/arkit)帮助开发者更容易的在项目中使用AR功能，扩展了应用和游戏的应用场景，三年前我在开发带有AR功能的App时，相关的核心功能还需要像高通购买SDK才能实现。现在有了ARKit普通开发者也能够开发AR相关的功能了\n\n## 其他值得注意的变更\n\n1. 在iOS 11系统中，在视频播放界面调节音量时将不会出现音量提示框，一个比之前更小的音量滑动条将会出现在屏幕的右上角\n![](https://resource.feng.com/resource/h061/h84/img201706072211540.jpg)\n2. 由于AppStore的改版，原先在应用内设置的跳转评分的链接将不会正常加载到评分界面\n3. 用户能够在AppStore中的产品页面里直接进行应用内购买，App必须支持新的`SKPaymentTransactionObserver`方法来支持AppStore内的应用内购买功能\n4. 开发者能够在后台回复用户的评论了，再也不用愁无法跟AppStore里的用户进行沟通了\n5. 由于我们在iTunes Connect后台只能提供一套产品信息，类如应用名称、图标、截图等，这就要求我们考虑到不同版本AppStore界面间的兼容\n6. 新的Navigation title设计，iOS 11系统中大多app都采用了这个新的设计，放大了导航栏的标题字体。虽然个人感觉有点丑，但是如果想要采用这项设计的话，只需要设置`navigation bar`的`prefersLargeTitles`即可，当然前提是你的导航栏是用的原生的`navigation bar`\n7. 提供了[FileProvider](https://developer.apple.com/documentation/fileprovider)功能让App可以获取用户设备或云端上的文件\n8. iOS 11将不再支持32位的app，如果想要让程序运行在iOS 11设备上，进行64位的重新编译是必须步骤\n\n## 参考\n\n[开发者所需要知道的 iOS 11 SDK 新特性](https://onevcat.com/2017/06/ios-11-sdk/)\n\n[AppStore官方说明](https://developer.apple.com/app-store/product-page/)","source":"_posts/iOS11开发者需要知道的改变.md","raw":"title: iOS 11 开发者需要知道的改变\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2017-06-08 17:18:00\n---\n\n苹果在`WWDC 2017`披露了许多的iOS 11的新特性，作为iOS开发者有哪些改变是我们需要知道的呢？\n\n## iOS 11的发布时间\n在正式发布iOS 11之前，苹果通常会先提供一个可供开发者安装的版本，然后再进过几个版本公开发布的beta版，最终才会发布一个正式版本的iOS 11系统\n- 开发者beta版本： 已经发布\n- 公开发布的beta版本：六月底\n- 最终正式版本：秋季\n\n## iOS 11支持哪些设备\n- iPhone 5S, 6, 6 Plus, 6S Plus, SE, 7, 7 Plus\n- iPad Air and Air 2, iPad Mini 2, 3, 4, 5代 iPad，所有的 iPad Pro\n- 6代 iPod Touch\n\n## iOS 新增了哪些框架\n\n### Core ML\n\niOS 11中苹果新增了一个机器学习框架[Core ML](https://developer.apple.com/machine-learning/)，同时Apple也提供了[一系列的工具](https://developer.apple.com/documentation/coreml/converting_trained_models_to_core_ml)用来将各类机器学习的模型转换为Core ML可以理解的形式，从而帮助开发者轻松的在APP里使用前人训练出来的模型。\n\n### ARKit\n\n[ARKit](https://developer.apple.com/documentation/arkit)帮助开发者更容易的在项目中使用AR功能，扩展了应用和游戏的应用场景，三年前我在开发带有AR功能的App时，相关的核心功能还需要像高通购买SDK才能实现。现在有了ARKit普通开发者也能够开发AR相关的功能了\n\n## 其他值得注意的变更\n\n1. 在iOS 11系统中，在视频播放界面调节音量时将不会出现音量提示框，一个比之前更小的音量滑动条将会出现在屏幕的右上角\n![](https://resource.feng.com/resource/h061/h84/img201706072211540.jpg)\n2. 由于AppStore的改版，原先在应用内设置的跳转评分的链接将不会正常加载到评分界面\n3. 用户能够在AppStore中的产品页面里直接进行应用内购买，App必须支持新的`SKPaymentTransactionObserver`方法来支持AppStore内的应用内购买功能\n4. 开发者能够在后台回复用户的评论了，再也不用愁无法跟AppStore里的用户进行沟通了\n5. 由于我们在iTunes Connect后台只能提供一套产品信息，类如应用名称、图标、截图等，这就要求我们考虑到不同版本AppStore界面间的兼容\n6. 新的Navigation title设计，iOS 11系统中大多app都采用了这个新的设计，放大了导航栏的标题字体。虽然个人感觉有点丑，但是如果想要采用这项设计的话，只需要设置`navigation bar`的`prefersLargeTitles`即可，当然前提是你的导航栏是用的原生的`navigation bar`\n7. 提供了[FileProvider](https://developer.apple.com/documentation/fileprovider)功能让App可以获取用户设备或云端上的文件\n8. iOS 11将不再支持32位的app，如果想要让程序运行在iOS 11设备上，进行64位的重新编译是必须步骤\n\n## 参考\n\n[开发者所需要知道的 iOS 11 SDK 新特性](https://onevcat.com/2017/06/ios-11-sdk/)\n\n[AppStore官方说明](https://developer.apple.com/app-store/product-page/)","slug":"iOS11开发者需要知道的改变","published":1,"updated":"2018-08-31T09:43:26.065Z","_id":"cjlhoqwio0020kj79t30ce8sb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>苹果在<code>WWDC 2017</code>披露了许多的iOS 11的新特性，作为iOS开发者有哪些改变是我们需要知道的呢？</p>\n<h2 id=\"iOS-11的发布时间\"><a href=\"#iOS-11的发布时间\" class=\"headerlink\" title=\"iOS 11的发布时间\"></a>iOS 11的发布时间</h2><p>在正式发布iOS 11之前，苹果通常会先提供一个可供开发者安装的版本，然后再进过几个版本公开发布的beta版，最终才会发布一个正式版本的iOS 11系统</p>\n<ul>\n<li>开发者beta版本： 已经发布</li>\n<li>公开发布的beta版本：六月底</li>\n<li>最终正式版本：秋季</li>\n</ul>\n<h2 id=\"iOS-11支持哪些设备\"><a href=\"#iOS-11支持哪些设备\" class=\"headerlink\" title=\"iOS 11支持哪些设备\"></a>iOS 11支持哪些设备</h2><ul>\n<li>iPhone 5S, 6, 6 Plus, 6S Plus, SE, 7, 7 Plus</li>\n<li>iPad Air and Air 2, iPad Mini 2, 3, 4, 5代 iPad，所有的 iPad Pro</li>\n<li>6代 iPod Touch</li>\n</ul>\n<h2 id=\"iOS-新增了哪些框架\"><a href=\"#iOS-新增了哪些框架\" class=\"headerlink\" title=\"iOS 新增了哪些框架\"></a>iOS 新增了哪些框架</h2><h3 id=\"Core-ML\"><a href=\"#Core-ML\" class=\"headerlink\" title=\"Core ML\"></a>Core ML</h3><p>iOS 11中苹果新增了一个机器学习框架<a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"external\">Core ML</a>，同时Apple也提供了<a href=\"https://developer.apple.com/documentation/coreml/converting_trained_models_to_core_ml\" target=\"_blank\" rel=\"external\">一系列的工具</a>用来将各类机器学习的模型转换为Core ML可以理解的形式，从而帮助开发者轻松的在APP里使用前人训练出来的模型。</p>\n<h3 id=\"ARKit\"><a href=\"#ARKit\" class=\"headerlink\" title=\"ARKit\"></a>ARKit</h3><p><a href=\"https://developer.apple.com/documentation/arkit\" target=\"_blank\" rel=\"external\">ARKit</a>帮助开发者更容易的在项目中使用AR功能，扩展了应用和游戏的应用场景，三年前我在开发带有AR功能的App时，相关的核心功能还需要像高通购买SDK才能实现。现在有了ARKit普通开发者也能够开发AR相关的功能了</p>\n<h2 id=\"其他值得注意的变更\"><a href=\"#其他值得注意的变更\" class=\"headerlink\" title=\"其他值得注意的变更\"></a>其他值得注意的变更</h2><ol>\n<li>在iOS 11系统中，在视频播放界面调节音量时将不会出现音量提示框，一个比之前更小的音量滑动条将会出现在屏幕的右上角<br><img src=\"https://resource.feng.com/resource/h061/h84/img201706072211540.jpg\" alt=\"\"></li>\n<li>由于AppStore的改版，原先在应用内设置的跳转评分的链接将不会正常加载到评分界面</li>\n<li>用户能够在AppStore中的产品页面里直接进行应用内购买，App必须支持新的<code>SKPaymentTransactionObserver</code>方法来支持AppStore内的应用内购买功能</li>\n<li>开发者能够在后台回复用户的评论了，再也不用愁无法跟AppStore里的用户进行沟通了</li>\n<li>由于我们在iTunes Connect后台只能提供一套产品信息，类如应用名称、图标、截图等，这就要求我们考虑到不同版本AppStore界面间的兼容</li>\n<li>新的Navigation title设计，iOS 11系统中大多app都采用了这个新的设计，放大了导航栏的标题字体。虽然个人感觉有点丑，但是如果想要采用这项设计的话，只需要设置<code>navigation bar</code>的<code>prefersLargeTitles</code>即可，当然前提是你的导航栏是用的原生的<code>navigation bar</code></li>\n<li>提供了<a href=\"https://developer.apple.com/documentation/fileprovider\" target=\"_blank\" rel=\"external\">FileProvider</a>功能让App可以获取用户设备或云端上的文件</li>\n<li>iOS 11将不再支持32位的app，如果想要让程序运行在iOS 11设备上，进行64位的重新编译是必须步骤</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://onevcat.com/2017/06/ios-11-sdk/\" target=\"_blank\" rel=\"external\">开发者所需要知道的 iOS 11 SDK 新特性</a></p>\n<p><a href=\"https://developer.apple.com/app-store/product-page/\" target=\"_blank\" rel=\"external\">AppStore官方说明</a></p>\n","excerpt":"","more":"<p>苹果在<code>WWDC 2017</code>披露了许多的iOS 11的新特性，作为iOS开发者有哪些改变是我们需要知道的呢？</p>\n<h2 id=\"iOS-11的发布时间\"><a href=\"#iOS-11的发布时间\" class=\"headerlink\" title=\"iOS 11的发布时间\"></a>iOS 11的发布时间</h2><p>在正式发布iOS 11之前，苹果通常会先提供一个可供开发者安装的版本，然后再进过几个版本公开发布的beta版，最终才会发布一个正式版本的iOS 11系统</p>\n<ul>\n<li>开发者beta版本： 已经发布</li>\n<li>公开发布的beta版本：六月底</li>\n<li>最终正式版本：秋季</li>\n</ul>\n<h2 id=\"iOS-11支持哪些设备\"><a href=\"#iOS-11支持哪些设备\" class=\"headerlink\" title=\"iOS 11支持哪些设备\"></a>iOS 11支持哪些设备</h2><ul>\n<li>iPhone 5S, 6, 6 Plus, 6S Plus, SE, 7, 7 Plus</li>\n<li>iPad Air and Air 2, iPad Mini 2, 3, 4, 5代 iPad，所有的 iPad Pro</li>\n<li>6代 iPod Touch</li>\n</ul>\n<h2 id=\"iOS-新增了哪些框架\"><a href=\"#iOS-新增了哪些框架\" class=\"headerlink\" title=\"iOS 新增了哪些框架\"></a>iOS 新增了哪些框架</h2><h3 id=\"Core-ML\"><a href=\"#Core-ML\" class=\"headerlink\" title=\"Core ML\"></a>Core ML</h3><p>iOS 11中苹果新增了一个机器学习框架<a href=\"https://developer.apple.com/machine-learning/\">Core ML</a>，同时Apple也提供了<a href=\"https://developer.apple.com/documentation/coreml/converting_trained_models_to_core_ml\">一系列的工具</a>用来将各类机器学习的模型转换为Core ML可以理解的形式，从而帮助开发者轻松的在APP里使用前人训练出来的模型。</p>\n<h3 id=\"ARKit\"><a href=\"#ARKit\" class=\"headerlink\" title=\"ARKit\"></a>ARKit</h3><p><a href=\"https://developer.apple.com/documentation/arkit\">ARKit</a>帮助开发者更容易的在项目中使用AR功能，扩展了应用和游戏的应用场景，三年前我在开发带有AR功能的App时，相关的核心功能还需要像高通购买SDK才能实现。现在有了ARKit普通开发者也能够开发AR相关的功能了</p>\n<h2 id=\"其他值得注意的变更\"><a href=\"#其他值得注意的变更\" class=\"headerlink\" title=\"其他值得注意的变更\"></a>其他值得注意的变更</h2><ol>\n<li>在iOS 11系统中，在视频播放界面调节音量时将不会出现音量提示框，一个比之前更小的音量滑动条将会出现在屏幕的右上角<br><img src=\"https://resource.feng.com/resource/h061/h84/img201706072211540.jpg\" alt=\"\"></li>\n<li>由于AppStore的改版，原先在应用内设置的跳转评分的链接将不会正常加载到评分界面</li>\n<li>用户能够在AppStore中的产品页面里直接进行应用内购买，App必须支持新的<code>SKPaymentTransactionObserver</code>方法来支持AppStore内的应用内购买功能</li>\n<li>开发者能够在后台回复用户的评论了，再也不用愁无法跟AppStore里的用户进行沟通了</li>\n<li>由于我们在iTunes Connect后台只能提供一套产品信息，类如应用名称、图标、截图等，这就要求我们考虑到不同版本AppStore界面间的兼容</li>\n<li>新的Navigation title设计，iOS 11系统中大多app都采用了这个新的设计，放大了导航栏的标题字体。虽然个人感觉有点丑，但是如果想要采用这项设计的话，只需要设置<code>navigation bar</code>的<code>prefersLargeTitles</code>即可，当然前提是你的导航栏是用的原生的<code>navigation bar</code></li>\n<li>提供了<a href=\"https://developer.apple.com/documentation/fileprovider\">FileProvider</a>功能让App可以获取用户设备或云端上的文件</li>\n<li>iOS 11将不再支持32位的app，如果想要让程序运行在iOS 11设备上，进行64位的重新编译是必须步骤</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://onevcat.com/2017/06/ios-11-sdk/\">开发者所需要知道的 iOS 11 SDK 新特性</a></p>\n<p><a href=\"https://developer.apple.com/app-store/product-page/\">AppStore官方说明</a></p>\n"},{"title":"iOS开发小结之H5与OC交互","date":"2017-02-23T06:11:00.000Z","_content":"\n#### 技术背景\n现在混合编程越来越多，为了能给用户提供一个完整的体验，我们就需要解决H5页面与原生程序直接的交互问题，闲话少说，我们直接上代码。我也已经将这篇博客相关的[完整Demo](https://github.com/luzhiyongGit/OC_JS_BridgeDemo)上传到了github上，大家也可以直接clone下来查看。\n\n#### 网页端\n##### 核心代码\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>demo</title>\n    <script>\n        function loginAction() {\n            var url = \"calloc://login?name=leafly&password=123456\";\n            document.location = url;\n        }\n    </script>\n</head>\n<body>\n    <button onClick=\"loginAction()\">登录</button>\n</body>\n</html>\n```\n##### 原理分析\n在以上的h5代码中，我们主要做了两件事：\n1. 页面展现\n2. 点击事件的JS处理\n当用户点击了登录按钮后，就会调用`loginAction()`方法，在这个方法里，我们加载了一个url，我们将这个url分割成三部分`calloc://`、`login?`、`name=leafly&password=123456`，这三部分共同组成了一个完整的请求地址，第一部分我取了一个名字`calloc`来表达这个地址的核心作用是调起oc代码，当然也可以根据实际情况去修改，第二部分表达了这次调起主要是做login操作，第三部分是login需要的参数\n\n#### 客户端\n##### 核心代码\n```\n- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {\n    NSURL *url = [request URL];\n    if ([[url scheme] isEqualToString:@\"calloc\"]) {\n        // JavaScript与Objective-C交互\n        if ([[url host] isEqualToString:@\"login\"]) {\n            // 登录操作\n            // 得到一个参数字段\n            NSDictionary *params = [self getParams:[url query]];\n            [self login:params];\n            return NO;\n        }\n    }\n    return YES;\n}\n```\n##### 原理分析\n在UIWebView里，每次的地址请求都会触发`- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType`代理，而我们就是通过在这个代理方法里拦截请求地址来实现JS调起OC的作用。通过获取一个请求地址的`scheme`、`host`、`query`这三部分信息，来获取我们所需要的信息。\n\n\n","source":"_posts/iOS开发小结之H5与OC交互.md","raw":"title: iOS开发小结之H5与OC交互\ntags:\n  - iOS进阶\n  - ''\ncategories:\n  - iOS\ndate: 2017-02-23 14:11:00\n---\n\n#### 技术背景\n现在混合编程越来越多，为了能给用户提供一个完整的体验，我们就需要解决H5页面与原生程序直接的交互问题，闲话少说，我们直接上代码。我也已经将这篇博客相关的[完整Demo](https://github.com/luzhiyongGit/OC_JS_BridgeDemo)上传到了github上，大家也可以直接clone下来查看。\n\n#### 网页端\n##### 核心代码\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>demo</title>\n    <script>\n        function loginAction() {\n            var url = \"calloc://login?name=leafly&password=123456\";\n            document.location = url;\n        }\n    </script>\n</head>\n<body>\n    <button onClick=\"loginAction()\">登录</button>\n</body>\n</html>\n```\n##### 原理分析\n在以上的h5代码中，我们主要做了两件事：\n1. 页面展现\n2. 点击事件的JS处理\n当用户点击了登录按钮后，就会调用`loginAction()`方法，在这个方法里，我们加载了一个url，我们将这个url分割成三部分`calloc://`、`login?`、`name=leafly&password=123456`，这三部分共同组成了一个完整的请求地址，第一部分我取了一个名字`calloc`来表达这个地址的核心作用是调起oc代码，当然也可以根据实际情况去修改，第二部分表达了这次调起主要是做login操作，第三部分是login需要的参数\n\n#### 客户端\n##### 核心代码\n```\n- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {\n    NSURL *url = [request URL];\n    if ([[url scheme] isEqualToString:@\"calloc\"]) {\n        // JavaScript与Objective-C交互\n        if ([[url host] isEqualToString:@\"login\"]) {\n            // 登录操作\n            // 得到一个参数字段\n            NSDictionary *params = [self getParams:[url query]];\n            [self login:params];\n            return NO;\n        }\n    }\n    return YES;\n}\n```\n##### 原理分析\n在UIWebView里，每次的地址请求都会触发`- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType`代理，而我们就是通过在这个代理方法里拦截请求地址来实现JS调起OC的作用。通过获取一个请求地址的`scheme`、`host`、`query`这三部分信息，来获取我们所需要的信息。\n\n\n","slug":"iOS开发小结之H5与OC交互","published":1,"updated":"2018-08-31T09:46:56.982Z","_id":"cjlhoqwiq0025kj79g0syc31m","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h4><p>现在混合编程越来越多，为了能给用户提供一个完整的体验，我们就需要解决H5页面与原生程序直接的交互问题，闲话少说，我们直接上代码。我也已经将这篇博客相关的<a href=\"https://github.com/luzhiyongGit/OC_JS_BridgeDemo\" target=\"_blank\" rel=\"external\">完整Demo</a>上传到了github上，大家也可以直接clone下来查看。</p>\n<h4 id=\"网页端\"><a href=\"#网页端\" class=\"headerlink\" title=\"网页端\"></a>网页端</h4><h5 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;demo&lt;/title&gt;</div><div class=\"line\">    &lt;script&gt;</div><div class=\"line\">        function loginAction() &#123;</div><div class=\"line\">            var url = &quot;calloc://login?name=leafly&amp;password=123456&quot;;</div><div class=\"line\">            document.location = url;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/script&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;button onClick=&quot;loginAction()&quot;&gt;登录&lt;/button&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h5><p>在以上的h5代码中，我们主要做了两件事：</p>\n<ol>\n<li>页面展现</li>\n<li>点击事件的JS处理<br>当用户点击了登录按钮后，就会调用<code>loginAction()</code>方法，在这个方法里，我们加载了一个url，我们将这个url分割成三部分<code>calloc://</code>、<code>login?</code>、<code>name=leafly&amp;password=123456</code>，这三部分共同组成了一个完整的请求地址，第一部分我取了一个名字<code>calloc</code>来表达这个地址的核心作用是调起oc代码，当然也可以根据实际情况去修改，第二部分表达了这次调起主要是做login操作，第三部分是login需要的参数</li>\n</ol>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><h5 id=\"核心代码-1\"><a href=\"#核心代码-1\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</div><div class=\"line\">    NSURL *url = [request URL];</div><div class=\"line\">    if ([[url scheme] isEqualToString:@&quot;calloc&quot;]) &#123;</div><div class=\"line\">        // JavaScript与Objective-C交互</div><div class=\"line\">        if ([[url host] isEqualToString:@&quot;login&quot;]) &#123;</div><div class=\"line\">            // 登录操作</div><div class=\"line\">            // 得到一个参数字段</div><div class=\"line\">            NSDictionary *params = [self getParams:[url query]];</div><div class=\"line\">            [self login:params];</div><div class=\"line\">            return NO;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"原理分析-1\"><a href=\"#原理分析-1\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h5><p>在UIWebView里，每次的地址请求都会触发<code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</code>代理，而我们就是通过在这个代理方法里拦截请求地址来实现JS调起OC的作用。通过获取一个请求地址的<code>scheme</code>、<code>host</code>、<code>query</code>这三部分信息，来获取我们所需要的信息。</p>\n","excerpt":"","more":"<h4 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h4><p>现在混合编程越来越多，为了能给用户提供一个完整的体验，我们就需要解决H5页面与原生程序直接的交互问题，闲话少说，我们直接上代码。我也已经将这篇博客相关的<a href=\"https://github.com/luzhiyongGit/OC_JS_BridgeDemo\">完整Demo</a>上传到了github上，大家也可以直接clone下来查看。</p>\n<h4 id=\"网页端\"><a href=\"#网页端\" class=\"headerlink\" title=\"网页端\"></a>网页端</h4><h5 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;demo&lt;/title&gt;</div><div class=\"line\">    &lt;script&gt;</div><div class=\"line\">        function loginAction() &#123;</div><div class=\"line\">            var url = &quot;calloc://login?name=leafly&amp;password=123456&quot;;</div><div class=\"line\">            document.location = url;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/script&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;button onClick=&quot;loginAction()&quot;&gt;登录&lt;/button&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h5><p>在以上的h5代码中，我们主要做了两件事：</p>\n<ol>\n<li>页面展现</li>\n<li>点击事件的JS处理<br>当用户点击了登录按钮后，就会调用<code>loginAction()</code>方法，在这个方法里，我们加载了一个url，我们将这个url分割成三部分<code>calloc://</code>、<code>login?</code>、<code>name=leafly&amp;password=123456</code>，这三部分共同组成了一个完整的请求地址，第一部分我取了一个名字<code>calloc</code>来表达这个地址的核心作用是调起oc代码，当然也可以根据实际情况去修改，第二部分表达了这次调起主要是做login操作，第三部分是login需要的参数</li>\n</ol>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><h5 id=\"核心代码-1\"><a href=\"#核心代码-1\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</div><div class=\"line\">    NSURL *url = [request URL];</div><div class=\"line\">    if ([[url scheme] isEqualToString:@&quot;calloc&quot;]) &#123;</div><div class=\"line\">        // JavaScript与Objective-C交互</div><div class=\"line\">        if ([[url host] isEqualToString:@&quot;login&quot;]) &#123;</div><div class=\"line\">            // 登录操作</div><div class=\"line\">            // 得到一个参数字段</div><div class=\"line\">            NSDictionary *params = [self getParams:[url query]];</div><div class=\"line\">            [self login:params];</div><div class=\"line\">            return NO;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"原理分析-1\"><a href=\"#原理分析-1\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h5><p>在UIWebView里，每次的地址请求都会触发<code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</code>代理，而我们就是通过在这个代理方法里拦截请求地址来实现JS调起OC的作用。通过获取一个请求地址的<code>scheme</code>、<code>host</code>、<code>query</code>这三部分信息，来获取我们所需要的信息。</p>\n"},{"title":"iOS项目添加自定义字体","date":"2016-11-28T03:23:00.000Z","_content":"\n有时候系统的字体无法满足我们的要求，这时就需要我们添加自定义字体，下面就来总结一下添加自定义字体的流程和注意点。\n\n####添加字体\n首先，我们需要将需要自定义的字体文件添加到我们的项目中\n![添加字体](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_1.png)\n####配置plist\n添加完成后就需要配置plist文件告诉项目你添加了自定义字体\n![配置plist](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_2.png)\n####打印字体名称\n```\n// 打印字体\n        let familyNames: Array = UIFont.familyNames()\n        \n        for familyName in familyNames {\n            let fontNames = UIFont.fontNamesForFamilyName(familyName)\n            \n            for fontName in fontNames {\n                print(\"Font:\"+fontName)\n            }\n        }\n```\n![打印字体名称](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_3.png)\n####使用新字体\n打印完所有的字体名称后，我们需要找到新字体的名称，这个比较考验眼力，需要说明的是导入的字体名称与你的字体文件名不存在必然关联，所以找起来比较麻烦，本项目中导入的字体名称是`Woxxdrgnxpjndtijvopiqfvieua` `Rlwnvqnxbaojotrussvqutrmalm` `Gjfhtoyvcitsqewokxubciqwsnn` `Daipwzrbqhqhabefqqcwoentynp`。\n调用方法：\n```\n[UIFont fontWithName:@\"Woxxdrgnxpjndtijvopiqfvieua\" size:9];\n```\n\n\n","source":"_posts/iOS项目添加自定义字体.md","raw":"title: iOS项目添加自定义字体\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2016-11-28 11:23:00\n---\n\n有时候系统的字体无法满足我们的要求，这时就需要我们添加自定义字体，下面就来总结一下添加自定义字体的流程和注意点。\n\n####添加字体\n首先，我们需要将需要自定义的字体文件添加到我们的项目中\n![添加字体](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_1.png)\n####配置plist\n添加完成后就需要配置plist文件告诉项目你添加了自定义字体\n![配置plist](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_2.png)\n####打印字体名称\n```\n// 打印字体\n        let familyNames: Array = UIFont.familyNames()\n        \n        for familyName in familyNames {\n            let fontNames = UIFont.fontNamesForFamilyName(familyName)\n            \n            for fontName in fontNames {\n                print(\"Font:\"+fontName)\n            }\n        }\n```\n![打印字体名称](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_3.png)\n####使用新字体\n打印完所有的字体名称后，我们需要找到新字体的名称，这个比较考验眼力，需要说明的是导入的字体名称与你的字体文件名不存在必然关联，所以找起来比较麻烦，本项目中导入的字体名称是`Woxxdrgnxpjndtijvopiqfvieua` `Rlwnvqnxbaojotrussvqutrmalm` `Gjfhtoyvcitsqewokxubciqwsnn` `Daipwzrbqhqhabefqqcwoentynp`。\n调用方法：\n```\n[UIFont fontWithName:@\"Woxxdrgnxpjndtijvopiqfvieua\" size:9];\n```\n\n\n","slug":"iOS项目添加自定义字体","published":1,"updated":"2018-08-31T09:48:22.335Z","_id":"cjlhoqwir0027kj795dg18xee","comments":1,"layout":"post","photos":[],"link":"","content":"<p>有时候系统的字体无法满足我们的要求，这时就需要我们添加自定义字体，下面就来总结一下添加自定义字体的流程和注意点。</p>\n<p>####添加字体<br>首先，我们需要将需要自定义的字体文件添加到我们的项目中<br><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_1.png\" alt=\"添加字体\"></p>\n<p>####配置plist<br>添加完成后就需要配置plist文件告诉项目你添加了自定义字体<br><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_2.png\" alt=\"配置plist\"></p>\n<p>####打印字体名称<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 打印字体</div><div class=\"line\">        let familyNames: Array = UIFont.familyNames()</div><div class=\"line\">        </div><div class=\"line\">        for familyName in familyNames &#123;</div><div class=\"line\">            let fontNames = UIFont.fontNamesForFamilyName(familyName)</div><div class=\"line\">            </div><div class=\"line\">            for fontName in fontNames &#123;</div><div class=\"line\">                print(&quot;Font:&quot;+fontName)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_3.png\" alt=\"打印字体名称\"></p>\n<p>####使用新字体<br>打印完所有的字体名称后，我们需要找到新字体的名称，这个比较考验眼力，需要说明的是导入的字体名称与你的字体文件名不存在必然关联，所以找起来比较麻烦，本项目中导入的字体名称是<code>Woxxdrgnxpjndtijvopiqfvieua</code> <code>Rlwnvqnxbaojotrussvqutrmalm</code> <code>Gjfhtoyvcitsqewokxubciqwsnn</code> <code>Daipwzrbqhqhabefqqcwoentynp</code>。<br>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[UIFont fontWithName:@&quot;Woxxdrgnxpjndtijvopiqfvieua&quot; size:9];</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>有时候系统的字体无法满足我们的要求，这时就需要我们添加自定义字体，下面就来总结一下添加自定义字体的流程和注意点。</p>\n<p>####添加字体<br>首先，我们需要将需要自定义的字体文件添加到我们的项目中<br><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_1.png\" alt=\"添加字体\"></p>\n<p>####配置plist<br>添加完成后就需要配置plist文件告诉项目你添加了自定义字体<br><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_2.png\" alt=\"配置plist\"></p>\n<p>####打印字体名称<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 打印字体</div><div class=\"line\">        let familyNames: Array = UIFont.familyNames()</div><div class=\"line\">        </div><div class=\"line\">        for familyName in familyNames &#123;</div><div class=\"line\">            let fontNames = UIFont.fontNamesForFamilyName(familyName)</div><div class=\"line\">            </div><div class=\"line\">            for fontName in fontNames &#123;</div><div class=\"line\">                print(&quot;Font:&quot;+fontName)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/iOS项目添加自定义字体/iOS项目添加自定义字体_3.png\" alt=\"打印字体名称\"></p>\n<p>####使用新字体<br>打印完所有的字体名称后，我们需要找到新字体的名称，这个比较考验眼力，需要说明的是导入的字体名称与你的字体文件名不存在必然关联，所以找起来比较麻烦，本项目中导入的字体名称是<code>Woxxdrgnxpjndtijvopiqfvieua</code> <code>Rlwnvqnxbaojotrussvqutrmalm</code> <code>Gjfhtoyvcitsqewokxubciqwsnn</code> <code>Daipwzrbqhqhabefqqcwoentynp</code>。<br>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[UIFont fontWithName:@&quot;Woxxdrgnxpjndtijvopiqfvieua&quot; size:9];</div></pre></td></tr></table></figure></p>\n"},{"title":"iOS的引用计数与循环引用","date":"2018-08-22T05:36:00.000Z","_content":"## 什么是引用计数？\n\n引用计数是一个简单而有效的管理对象生命周期的方式。\n\n- 当我们创建一个新对象时，它的引用计数为1\n- 当有一个新的指针指向这个对象时，我们将引用计数加1\n- 当某个指针不再指向这个对象时，我们将引用计数减1\n- 当对象的引用计数为0时，说明这个对象不再被任何指针指向了，就可以将对象销毁，回收内存\n\n![memory-ref-count.png.jpeg](http://upload-images.jianshu.io/upload_images/1479547-30385df644b8cd5a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 引用计数的运用场景\n\n引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。\n\n以对象M为例，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完之后再把引用计数减1.所有对象都遵守这个规则的话，对象的生命周期管理就可以完全交给引用计数了。\n\n## ARC下的常见内存管理问题\n\n#### 循环引用问题 (Reference Cycle)\n\n引用计数这种管理内存的方式虽然简单，但是有一个比较大的瑕疵，`它不能很好的解决循环引用问题`\n\n1. 什么是循环引用问题？\n\n对象A和对象B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减1，这就导致了A的销毁依赖于B的销毁，同样B的销毁依赖于A的销毁，这样就造成了循环引用问题。\n\n![memory-cycle-1.png.jpeg](http://upload-images.jianshu.io/upload_images/1479547-121197b1f2cebf08.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不仅仅只在两个对象中存在循环引用问题，多个对象依次持有对方，形成一个环状，也会造成循环引用问题。\n\n![memory-cycle-2.png](http://upload-images.jianshu.io/upload_images/1479547-1943ef26038fcb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 如何解决循环引用问题？\n\n###### 主动断开循环引用\n\n在合理的位置主动断开环中的一个引用，使得对象得以回收。\n![memory-cycle-3.png](http://upload-images.jianshu.io/upload_images/1479547-f73d7d5934c88e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n主动断开循环引用这种方式常见于各种与block相关的代码逻辑中。\n\n例如：网络请求的回调block是被持有的，如果这个block中又存在对于View Controller的引用，就容易产生循环引用。\n- Controller 持有网络请求对象\n- 网络请求对象持有了回调的block\n- 回调的block里面使用了self，所以持有了Controller\n\n```\n// View Controller\n\n- (void)sendRequest {\n// Controller 持有网络请求对象\n    Request *request = [Request alloc] initWithPath:@\"https://www.baidu.com\"];\n    [request startWithCompletionBlockWithSuccess:^(Block block) {\n    // 回调的block里面使用了self，所以持有了Controller\n        [self reloadView];\n    } failure:^(NSError *error) {\n        [self toast];\n    }\n}\n\n// Request\n\n// 网络请求对象持有了回调block\n- (void)startWithCompletionBlockWithSuccess:(void (^)(Block block))success failure:(void (^)(NSError *error) {\n    self.successCompletionBlock = success;\n    self.failureCompletionBlock = failure;\n}\n\n```\n\n解决这个问题的办法就是在网络请求结束后，主动释放对block的持有，打破循环引用\n\n```\n- (void)clearCompletionBlock {\n    self.successCompletionBlock = nil;\n    self.failureCompletionBlock = nil;\n}\n```\n\n##### 使用弱引用\n\n主动断开循环引用需要程序员能够准确发现循环引用，并知道什么时机断开循环引用，所以这种解决方法并不常见，更常见的办法是使用弱引用\n\n弱引用虽然持有对象，但是不增加引用计数，这样就避免了循环引用的产生。例如delegate模式中的weak声明。View Controller的delegate成员变量通常是一个弱引用，以避免两个View Controller互相引用对方造成循环引用。\n\n![memory-cycle-4.png.jpeg](http://upload-images.jianshu.io/upload_images/1479547-05e4202ef56b249c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 弱引用的实现原理\n\n系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为0时，系统就通过这张表，找到所有的弱引用指针，将他们置为nil。`弱引用的使用是有额外的开销的，虽然这个开销很小，但是如果肯定不需要使用弱引用特性时，就不应该盲目使用弱引用`\n\n##### Block如何避免循环引用\n\n- 当block本身不被self持有，而被别的对象持有，同时不产生循环引用的时候，就不需要weakself，最常见的代码就是UIView的动画代码\n\n```\n[UIView animateWithDuration:0.2 animations:^{  \n  self.alpha = 1;\n}];\n```\n- 通过weakSelf和strongSelf解决循环引用\n\n```\n__weak __typeof (self)weakSelf = self;\n\n_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"Change\" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) {\n    __strong __typeof(weakSelf)strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf reload];\n    }\n}\n```\n1. 在block之前定义对self的弱引用weakSelf,因为是弱引用，所以self被释放时weakSelf会变成nil\n2. 在block中引用该弱引用，考虑到多线程情况，通过强引用strongSelf来引用该弱引用，如果self不为nil，就会retain self，以防在block内部使用过程中self被释放\n3. 在block块中使用该强引用strongSelf，注意对strongSelf进行nil检测，因为多线程在弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了\n4. 强引用strongSelf在block作用域结束之后，自动释放\n\n- weakSelf为什么需要strongSelf配合使用\n\n在block块中先写一个strongSelf，是为了避免在block的执行过程中，突然出现self被释放的情况。\n\n##### __weak与__block的区别\n\n`__weak`可以避免循环引用，`__block`不能避免循环引用，`__block`的作用是提升变量的作用域\n\n\n## 总结\n\n- 引用计数是一种简单高效的管理对象生命周期的方法\n- 引用计数无法避免循环引用\n- 循环引用的解决分为弱引用（事先规避）和主动断开循环引用（事后补救）两个方案\n- `__weak` 可以避免循环引用，但是其存在外部对象释放后，block内部也访问不到这个对象的问题，所以我们通过在block内部声明一个 `__strong`的变量来指向weakObj，使得外部对象既能在block内部保持，又能避免循环引用的问题\n- `__block`无法避免循环引用的问题，它的作用是提升了变量的作用域，在block内外访问的都是同一个对象，如果想要在block中改变变量的值，就需要在变量声明的时候加上`__block`修饰符","source":"_posts/iOS的引用计数与循环引用.md","raw":"title: iOS的引用计数与循环引用\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2018-08-22 13:36:00\n---\n## 什么是引用计数？\n\n引用计数是一个简单而有效的管理对象生命周期的方式。\n\n- 当我们创建一个新对象时，它的引用计数为1\n- 当有一个新的指针指向这个对象时，我们将引用计数加1\n- 当某个指针不再指向这个对象时，我们将引用计数减1\n- 当对象的引用计数为0时，说明这个对象不再被任何指针指向了，就可以将对象销毁，回收内存\n\n![memory-ref-count.png.jpeg](http://upload-images.jianshu.io/upload_images/1479547-30385df644b8cd5a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 引用计数的运用场景\n\n引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。\n\n以对象M为例，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完之后再把引用计数减1.所有对象都遵守这个规则的话，对象的生命周期管理就可以完全交给引用计数了。\n\n## ARC下的常见内存管理问题\n\n#### 循环引用问题 (Reference Cycle)\n\n引用计数这种管理内存的方式虽然简单，但是有一个比较大的瑕疵，`它不能很好的解决循环引用问题`\n\n1. 什么是循环引用问题？\n\n对象A和对象B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减1，这就导致了A的销毁依赖于B的销毁，同样B的销毁依赖于A的销毁，这样就造成了循环引用问题。\n\n![memory-cycle-1.png.jpeg](http://upload-images.jianshu.io/upload_images/1479547-121197b1f2cebf08.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不仅仅只在两个对象中存在循环引用问题，多个对象依次持有对方，形成一个环状，也会造成循环引用问题。\n\n![memory-cycle-2.png](http://upload-images.jianshu.io/upload_images/1479547-1943ef26038fcb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 如何解决循环引用问题？\n\n###### 主动断开循环引用\n\n在合理的位置主动断开环中的一个引用，使得对象得以回收。\n![memory-cycle-3.png](http://upload-images.jianshu.io/upload_images/1479547-f73d7d5934c88e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n主动断开循环引用这种方式常见于各种与block相关的代码逻辑中。\n\n例如：网络请求的回调block是被持有的，如果这个block中又存在对于View Controller的引用，就容易产生循环引用。\n- Controller 持有网络请求对象\n- 网络请求对象持有了回调的block\n- 回调的block里面使用了self，所以持有了Controller\n\n```\n// View Controller\n\n- (void)sendRequest {\n// Controller 持有网络请求对象\n    Request *request = [Request alloc] initWithPath:@\"https://www.baidu.com\"];\n    [request startWithCompletionBlockWithSuccess:^(Block block) {\n    // 回调的block里面使用了self，所以持有了Controller\n        [self reloadView];\n    } failure:^(NSError *error) {\n        [self toast];\n    }\n}\n\n// Request\n\n// 网络请求对象持有了回调block\n- (void)startWithCompletionBlockWithSuccess:(void (^)(Block block))success failure:(void (^)(NSError *error) {\n    self.successCompletionBlock = success;\n    self.failureCompletionBlock = failure;\n}\n\n```\n\n解决这个问题的办法就是在网络请求结束后，主动释放对block的持有，打破循环引用\n\n```\n- (void)clearCompletionBlock {\n    self.successCompletionBlock = nil;\n    self.failureCompletionBlock = nil;\n}\n```\n\n##### 使用弱引用\n\n主动断开循环引用需要程序员能够准确发现循环引用，并知道什么时机断开循环引用，所以这种解决方法并不常见，更常见的办法是使用弱引用\n\n弱引用虽然持有对象，但是不增加引用计数，这样就避免了循环引用的产生。例如delegate模式中的weak声明。View Controller的delegate成员变量通常是一个弱引用，以避免两个View Controller互相引用对方造成循环引用。\n\n![memory-cycle-4.png.jpeg](http://upload-images.jianshu.io/upload_images/1479547-05e4202ef56b249c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 弱引用的实现原理\n\n系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为0时，系统就通过这张表，找到所有的弱引用指针，将他们置为nil。`弱引用的使用是有额外的开销的，虽然这个开销很小，但是如果肯定不需要使用弱引用特性时，就不应该盲目使用弱引用`\n\n##### Block如何避免循环引用\n\n- 当block本身不被self持有，而被别的对象持有，同时不产生循环引用的时候，就不需要weakself，最常见的代码就是UIView的动画代码\n\n```\n[UIView animateWithDuration:0.2 animations:^{  \n  self.alpha = 1;\n}];\n```\n- 通过weakSelf和strongSelf解决循环引用\n\n```\n__weak __typeof (self)weakSelf = self;\n\n_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"Change\" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) {\n    __strong __typeof(weakSelf)strongSelf = weakSelf;\n    if (strongSelf) {\n        [strongSelf reload];\n    }\n}\n```\n1. 在block之前定义对self的弱引用weakSelf,因为是弱引用，所以self被释放时weakSelf会变成nil\n2. 在block中引用该弱引用，考虑到多线程情况，通过强引用strongSelf来引用该弱引用，如果self不为nil，就会retain self，以防在block内部使用过程中self被释放\n3. 在block块中使用该强引用strongSelf，注意对strongSelf进行nil检测，因为多线程在弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了\n4. 强引用strongSelf在block作用域结束之后，自动释放\n\n- weakSelf为什么需要strongSelf配合使用\n\n在block块中先写一个strongSelf，是为了避免在block的执行过程中，突然出现self被释放的情况。\n\n##### __weak与__block的区别\n\n`__weak`可以避免循环引用，`__block`不能避免循环引用，`__block`的作用是提升变量的作用域\n\n\n## 总结\n\n- 引用计数是一种简单高效的管理对象生命周期的方法\n- 引用计数无法避免循环引用\n- 循环引用的解决分为弱引用（事先规避）和主动断开循环引用（事后补救）两个方案\n- `__weak` 可以避免循环引用，但是其存在外部对象释放后，block内部也访问不到这个对象的问题，所以我们通过在block内部声明一个 `__strong`的变量来指向weakObj，使得外部对象既能在block内部保持，又能避免循环引用的问题\n- `__block`无法避免循环引用的问题，它的作用是提升了变量的作用域，在block内外访问的都是同一个对象，如果想要在block中改变变量的值，就需要在变量声明的时候加上`__block`修饰符","slug":"iOS的引用计数与循环引用","published":1,"updated":"2018-08-31T09:40:45.313Z","_id":"cjlhoqwit002bkj7976aqcwvs","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是引用计数？\"><a href=\"#什么是引用计数？\" class=\"headerlink\" title=\"什么是引用计数？\"></a>什么是引用计数？</h2><p>引用计数是一个简单而有效的管理对象生命周期的方式。</p>\n<ul>\n<li>当我们创建一个新对象时，它的引用计数为1</li>\n<li>当有一个新的指针指向这个对象时，我们将引用计数加1</li>\n<li>当某个指针不再指向这个对象时，我们将引用计数减1</li>\n<li>当对象的引用计数为0时，说明这个对象不再被任何指针指向了，就可以将对象销毁，回收内存</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-30385df644b8cd5a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-ref-count.png.jpeg\"></p>\n<h2 id=\"引用计数的运用场景\"><a href=\"#引用计数的运用场景\" class=\"headerlink\" title=\"引用计数的运用场景\"></a>引用计数的运用场景</h2><p>引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。</p>\n<p>以对象M为例，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完之后再把引用计数减1.所有对象都遵守这个规则的话，对象的生命周期管理就可以完全交给引用计数了。</p>\n<h2 id=\"ARC下的常见内存管理问题\"><a href=\"#ARC下的常见内存管理问题\" class=\"headerlink\" title=\"ARC下的常见内存管理问题\"></a>ARC下的常见内存管理问题</h2><h4 id=\"循环引用问题-Reference-Cycle\"><a href=\"#循环引用问题-Reference-Cycle\" class=\"headerlink\" title=\"循环引用问题 (Reference Cycle)\"></a>循环引用问题 (Reference Cycle)</h4><p>引用计数这种管理内存的方式虽然简单，但是有一个比较大的瑕疵，<code>它不能很好的解决循环引用问题</code></p>\n<ol>\n<li>什么是循环引用问题？</li>\n</ol>\n<p>对象A和对象B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减1，这就导致了A的销毁依赖于B的销毁，同样B的销毁依赖于A的销毁，这样就造成了循环引用问题。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-121197b1f2cebf08.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-1.png.jpeg\"></p>\n<p>不仅仅只在两个对象中存在循环引用问题，多个对象依次持有对方，形成一个环状，也会造成循环引用问题。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-1943ef26038fcb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-2.png\"></p>\n<ol>\n<li>如何解决循环引用问题？</li>\n</ol>\n<h6 id=\"主动断开循环引用\"><a href=\"#主动断开循环引用\" class=\"headerlink\" title=\"主动断开循环引用\"></a>主动断开循环引用</h6><p>在合理的位置主动断开环中的一个引用，使得对象得以回收。<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-f73d7d5934c88e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-3.png\"><br>主动断开循环引用这种方式常见于各种与block相关的代码逻辑中。</p>\n<p>例如：网络请求的回调block是被持有的，如果这个block中又存在对于View Controller的引用，就容易产生循环引用。</p>\n<ul>\n<li>Controller 持有网络请求对象</li>\n<li>网络请求对象持有了回调的block</li>\n<li>回调的block里面使用了self，所以持有了Controller</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// View Controller</div><div class=\"line\"></div><div class=\"line\">- (void)sendRequest &#123;</div><div class=\"line\">// Controller 持有网络请求对象</div><div class=\"line\">    Request *request = [Request alloc] initWithPath:@&quot;https://www.baidu.com&quot;];</div><div class=\"line\">    [request startWithCompletionBlockWithSuccess:^(Block block) &#123;</div><div class=\"line\">    // 回调的block里面使用了self，所以持有了Controller</div><div class=\"line\">        [self reloadView];</div><div class=\"line\">    &#125; failure:^(NSError *error) &#123;</div><div class=\"line\">        [self toast];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Request</div><div class=\"line\"></div><div class=\"line\">// 网络请求对象持有了回调block</div><div class=\"line\">- (void)startWithCompletionBlockWithSuccess:(void (^)(Block block))success failure:(void (^)(NSError *error) &#123;</div><div class=\"line\">    self.successCompletionBlock = success;</div><div class=\"line\">    self.failureCompletionBlock = failure;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决这个问题的办法就是在网络请求结束后，主动释放对block的持有，打破循环引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)clearCompletionBlock &#123;</div><div class=\"line\">    self.successCompletionBlock = nil;</div><div class=\"line\">    self.failureCompletionBlock = nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"使用弱引用\"><a href=\"#使用弱引用\" class=\"headerlink\" title=\"使用弱引用\"></a>使用弱引用</h5><p>主动断开循环引用需要程序员能够准确发现循环引用，并知道什么时机断开循环引用，所以这种解决方法并不常见，更常见的办法是使用弱引用</p>\n<p>弱引用虽然持有对象，但是不增加引用计数，这样就避免了循环引用的产生。例如delegate模式中的weak声明。View Controller的delegate成员变量通常是一个弱引用，以避免两个View Controller互相引用对方造成循环引用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-05e4202ef56b249c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-4.png.jpeg\"></p>\n<h5 id=\"弱引用的实现原理\"><a href=\"#弱引用的实现原理\" class=\"headerlink\" title=\"弱引用的实现原理\"></a>弱引用的实现原理</h5><p>系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为0时，系统就通过这张表，找到所有的弱引用指针，将他们置为nil。<code>弱引用的使用是有额外的开销的，虽然这个开销很小，但是如果肯定不需要使用弱引用特性时，就不应该盲目使用弱引用</code></p>\n<h5 id=\"Block如何避免循环引用\"><a href=\"#Block如何避免循环引用\" class=\"headerlink\" title=\"Block如何避免循环引用\"></a>Block如何避免循环引用</h5><ul>\n<li>当block本身不被self持有，而被别的对象持有，同时不产生循环引用的时候，就不需要weakself，最常见的代码就是UIView的动画代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[UIView animateWithDuration:0.2 animations:^&#123;  </div><div class=\"line\">  self.alpha = 1;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>通过weakSelf和strongSelf解决循环引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak __typeof (self)weakSelf = self;</div><div class=\"line\"></div><div class=\"line\">_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;Change&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</div><div class=\"line\">    __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">    if (strongSelf) &#123;</div><div class=\"line\">        [strongSelf reload];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>在block之前定义对self的弱引用weakSelf,因为是弱引用，所以self被释放时weakSelf会变成nil</li>\n<li>在block中引用该弱引用，考虑到多线程情况，通过强引用strongSelf来引用该弱引用，如果self不为nil，就会retain self，以防在block内部使用过程中self被释放</li>\n<li>在block块中使用该强引用strongSelf，注意对strongSelf进行nil检测，因为多线程在弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了</li>\n<li>强引用strongSelf在block作用域结束之后，自动释放</li>\n</ol>\n<ul>\n<li>weakSelf为什么需要strongSelf配合使用</li>\n</ul>\n<p>在block块中先写一个strongSelf，是为了避免在block的执行过程中，突然出现self被释放的情况。</p>\n<h5 id=\"weak与block的区别\"><a href=\"#weak与block的区别\" class=\"headerlink\" title=\"weak与block的区别\"></a><strong>weak与</strong>block的区别</h5><p><code>__weak</code>可以避免循环引用，<code>__block</code>不能避免循环引用，<code>__block</code>的作用是提升变量的作用域</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>引用计数是一种简单高效的管理对象生命周期的方法</li>\n<li>引用计数无法避免循环引用</li>\n<li>循环引用的解决分为弱引用（事先规避）和主动断开循环引用（事后补救）两个方案</li>\n<li><code>__weak</code> 可以避免循环引用，但是其存在外部对象释放后，block内部也访问不到这个对象的问题，所以我们通过在block内部声明一个 <code>__strong</code>的变量来指向weakObj，使得外部对象既能在block内部保持，又能避免循环引用的问题</li>\n<li><code>__block</code>无法避免循环引用的问题，它的作用是提升了变量的作用域，在block内外访问的都是同一个对象，如果想要在block中改变变量的值，就需要在变量声明的时候加上<code>__block</code>修饰符</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"什么是引用计数？\"><a href=\"#什么是引用计数？\" class=\"headerlink\" title=\"什么是引用计数？\"></a>什么是引用计数？</h2><p>引用计数是一个简单而有效的管理对象生命周期的方式。</p>\n<ul>\n<li>当我们创建一个新对象时，它的引用计数为1</li>\n<li>当有一个新的指针指向这个对象时，我们将引用计数加1</li>\n<li>当某个指针不再指向这个对象时，我们将引用计数减1</li>\n<li>当对象的引用计数为0时，说明这个对象不再被任何指针指向了，就可以将对象销毁，回收内存</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-30385df644b8cd5a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-ref-count.png.jpeg\"></p>\n<h2 id=\"引用计数的运用场景\"><a href=\"#引用计数的运用场景\" class=\"headerlink\" title=\"引用计数的运用场景\"></a>引用计数的运用场景</h2><p>引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。</p>\n<p>以对象M为例，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完之后再把引用计数减1.所有对象都遵守这个规则的话，对象的生命周期管理就可以完全交给引用计数了。</p>\n<h2 id=\"ARC下的常见内存管理问题\"><a href=\"#ARC下的常见内存管理问题\" class=\"headerlink\" title=\"ARC下的常见内存管理问题\"></a>ARC下的常见内存管理问题</h2><h4 id=\"循环引用问题-Reference-Cycle\"><a href=\"#循环引用问题-Reference-Cycle\" class=\"headerlink\" title=\"循环引用问题 (Reference Cycle)\"></a>循环引用问题 (Reference Cycle)</h4><p>引用计数这种管理内存的方式虽然简单，但是有一个比较大的瑕疵，<code>它不能很好的解决循环引用问题</code></p>\n<ol>\n<li>什么是循环引用问题？</li>\n</ol>\n<p>对象A和对象B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减1，这就导致了A的销毁依赖于B的销毁，同样B的销毁依赖于A的销毁，这样就造成了循环引用问题。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-121197b1f2cebf08.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-1.png.jpeg\"></p>\n<p>不仅仅只在两个对象中存在循环引用问题，多个对象依次持有对方，形成一个环状，也会造成循环引用问题。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-1943ef26038fcb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-2.png\"></p>\n<ol>\n<li>如何解决循环引用问题？</li>\n</ol>\n<h6 id=\"主动断开循环引用\"><a href=\"#主动断开循环引用\" class=\"headerlink\" title=\"主动断开循环引用\"></a>主动断开循环引用</h6><p>在合理的位置主动断开环中的一个引用，使得对象得以回收。<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-f73d7d5934c88e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-3.png\"><br>主动断开循环引用这种方式常见于各种与block相关的代码逻辑中。</p>\n<p>例如：网络请求的回调block是被持有的，如果这个block中又存在对于View Controller的引用，就容易产生循环引用。</p>\n<ul>\n<li>Controller 持有网络请求对象</li>\n<li>网络请求对象持有了回调的block</li>\n<li>回调的block里面使用了self，所以持有了Controller</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// View Controller</div><div class=\"line\"></div><div class=\"line\">- (void)sendRequest &#123;</div><div class=\"line\">// Controller 持有网络请求对象</div><div class=\"line\">    Request *request = [Request alloc] initWithPath:@&quot;https://www.baidu.com&quot;];</div><div class=\"line\">    [request startWithCompletionBlockWithSuccess:^(Block block) &#123;</div><div class=\"line\">    // 回调的block里面使用了self，所以持有了Controller</div><div class=\"line\">        [self reloadView];</div><div class=\"line\">    &#125; failure:^(NSError *error) &#123;</div><div class=\"line\">        [self toast];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Request</div><div class=\"line\"></div><div class=\"line\">// 网络请求对象持有了回调block</div><div class=\"line\">- (void)startWithCompletionBlockWithSuccess:(void (^)(Block block))success failure:(void (^)(NSError *error) &#123;</div><div class=\"line\">    self.successCompletionBlock = success;</div><div class=\"line\">    self.failureCompletionBlock = failure;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决这个问题的办法就是在网络请求结束后，主动释放对block的持有，打破循环引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)clearCompletionBlock &#123;</div><div class=\"line\">    self.successCompletionBlock = nil;</div><div class=\"line\">    self.failureCompletionBlock = nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"使用弱引用\"><a href=\"#使用弱引用\" class=\"headerlink\" title=\"使用弱引用\"></a>使用弱引用</h5><p>主动断开循环引用需要程序员能够准确发现循环引用，并知道什么时机断开循环引用，所以这种解决方法并不常见，更常见的办法是使用弱引用</p>\n<p>弱引用虽然持有对象，但是不增加引用计数，这样就避免了循环引用的产生。例如delegate模式中的weak声明。View Controller的delegate成员变量通常是一个弱引用，以避免两个View Controller互相引用对方造成循环引用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1479547-05e4202ef56b249c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"memory-cycle-4.png.jpeg\"></p>\n<h5 id=\"弱引用的实现原理\"><a href=\"#弱引用的实现原理\" class=\"headerlink\" title=\"弱引用的实现原理\"></a>弱引用的实现原理</h5><p>系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为0时，系统就通过这张表，找到所有的弱引用指针，将他们置为nil。<code>弱引用的使用是有额外的开销的，虽然这个开销很小，但是如果肯定不需要使用弱引用特性时，就不应该盲目使用弱引用</code></p>\n<h5 id=\"Block如何避免循环引用\"><a href=\"#Block如何避免循环引用\" class=\"headerlink\" title=\"Block如何避免循环引用\"></a>Block如何避免循环引用</h5><ul>\n<li>当block本身不被self持有，而被别的对象持有，同时不产生循环引用的时候，就不需要weakself，最常见的代码就是UIView的动画代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[UIView animateWithDuration:0.2 animations:^&#123;  </div><div class=\"line\">  self.alpha = 1;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<ul>\n<li>通过weakSelf和strongSelf解决循环引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak __typeof (self)weakSelf = self;</div><div class=\"line\"></div><div class=\"line\">_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;Change&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</div><div class=\"line\">    __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">    if (strongSelf) &#123;</div><div class=\"line\">        [strongSelf reload];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>在block之前定义对self的弱引用weakSelf,因为是弱引用，所以self被释放时weakSelf会变成nil</li>\n<li>在block中引用该弱引用，考虑到多线程情况，通过强引用strongSelf来引用该弱引用，如果self不为nil，就会retain self，以防在block内部使用过程中self被释放</li>\n<li>在block块中使用该强引用strongSelf，注意对strongSelf进行nil检测，因为多线程在弱引用weakSelf对强引用strongSelf赋值时，弱引用weakSelf可能已经为nil了</li>\n<li>强引用strongSelf在block作用域结束之后，自动释放</li>\n</ol>\n<ul>\n<li>weakSelf为什么需要strongSelf配合使用</li>\n</ul>\n<p>在block块中先写一个strongSelf，是为了避免在block的执行过程中，突然出现self被释放的情况。</p>\n<h5 id=\"weak与block的区别\"><a href=\"#weak与block的区别\" class=\"headerlink\" title=\"weak与block的区别\"></a><strong>weak与</strong>block的区别</h5><p><code>__weak</code>可以避免循环引用，<code>__block</code>不能避免循环引用，<code>__block</code>的作用是提升变量的作用域</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>引用计数是一种简单高效的管理对象生命周期的方法</li>\n<li>引用计数无法避免循环引用</li>\n<li>循环引用的解决分为弱引用（事先规避）和主动断开循环引用（事后补救）两个方案</li>\n<li><code>__weak</code> 可以避免循环引用，但是其存在外部对象释放后，block内部也访问不到这个对象的问题，所以我们通过在block内部声明一个 <code>__strong</code>的变量来指向weakObj，使得外部对象既能在block内部保持，又能避免循环引用的问题</li>\n<li><code>__block</code>无法避免循环引用的问题，它的作用是提升了变量的作用域，在block内外访问的都是同一个对象，如果想要在block中改变变量的值，就需要在变量声明的时候加上<code>__block</code>修饰符</li>\n</ul>\n"},{"title":"runtime机制","catgories":"iOS","date":"2016-12-27T07:46:00.000Z","_content":"### runtime实现的机制是什么？\nruntime是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时我们编写的OC代码在程序运行过程时，最终都是转换成了runtime的C语言\n```\n  OC: [[User alloc] init]\n  runtime: objc_msgSend(objc_msgSend(\"User\", \"alloc\"), \"init\")\n```\n\n### runtime能用来干什么？\n1. 在程序运行过程中，动态的创建一个类\n2. 在程序运行过程中，动态的为某个类添加属性、方法，修改属性值、方法\n3. 遍历一个类的所有成员变量、所有方法\n\n### runtime相关知识\n1. 相关头文件\n   ```\n     <objc/runtime.h>\n     <objc/message.h>\n   ```\n2. 相关函数\n   ```\n    objc_msgSend: 给对象发送消息\n    class_copyMethodList: 获得某个类内部的所有方法\n    class_copyIvarList: 获得某个类内部的所有成员变量\n    class_getInstanceMethod: 获得某个实例方法\n    class_getClassMethod: 获得某个类方法\n    method_exchangeImplementations: 交换两个方法的具体实现\n    objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 关联对象\n   ```\n\n### runtime用法介绍\n1. 发送消息\n   OC方法调用的本质就是发送消息，消息机制的原理就是对象根据方法编号SEL去映射表中查找对应的方法实现\n   ```\n   Person *person = [[Person alloc] init];\n   [person eat];\n\n   // 本质：让对象发送消息\n   objc_msgSend(p, @selector(eat));\n\n   [Person eat];\n\n   // 本质：让类对象发送消息\n   objc_msgSend([Person class], @selector(eat));\n   ```\n2. 交换方法\n   ```\n   + (void)load {\n       // 交换吃和读这两个方法\n       Method m1 = class_getInstanceMethod(self, @selector(eat));\n       Method m2 = class_getInstanceMethod(self, @selector(read));\n    \n       method_exchangeImplementations(m1, m2);\n    }\n\n#pragma mark - Methods\n\n    - (void)eat {\n       NSLog(@\"我非常喜欢美食\");\n    }\n\n    - (void)read {\n       NSLog(@\"我非常喜欢名著\");\n    }\n\n   ```\n3. 动态添加方法\n   ```\n   // 动态给Person类中添加drink方法\n      class_addMethod([person class], @selector(drink), (IMP)drinkWater, \"v@:\");\n   \n   // 调用drink方法         \n      if ([person respondsToSelector:@selector(drink)]) {\n            [person performSelector:@selector(drink)];\n      }\n\n   // 编写drinkWater的实现\n   // 注意点：1、void 前面没有+、- 号 因为是C语言代码  2、必须有两个指定参数(id self, SEL _cmd)\n      void drinkWater(id self, SEL _cmd) {\n          NSLog(@\"我喜欢喝饮料\");\n      }\n   ```\n4. 在方法上添加额外功能\n   ```\n   // 以UIButton为类，扩展点击事件\n\n   @implementation UIButton (Hook)\n\n   + (void)load {\n       static dispatch_once_t onceToken;\n       dispatch_once(&onceToken, ^{\n          Class selfClass = [self class];\n\n          SEL oriSEL = @selector(sendAction:to:forEvent:);\n          Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);\n\n          SEL cusSEL = @selector(mySendAction:to:forEvent:);\n          Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);\n\n          BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n\n          if (addSucc) {\n             class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n          } else {             \n            method_exchangeImplementations(oriMethod, cusMethod);\n          }\n       })\n   }\n\n   - (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n     // 自定义事件\n     [self doSomething];\n\n     [self mySendAction:action to:target forEvent:event];\n   }\n   ```\n\n5. 关联\n   ```\n    void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n    // 参数说明：\n    // object: 与谁关联\n    // key: 唯一键\n    // value: 关联所设置的值\n    // policy: 内存管理策略\n\n    id objc_getAssociatedObject(id object, const void *key)\n    // 参数说明：\n    // object: 与谁关联\n    // key: 唯一键\n\n    void objec_remoteAssociatedObjects(id object)\n    // 参数说明：\n    // object: 与谁关联\n   ```","source":"_posts/runtime机制.md","raw":"title: runtime机制\ntags:\n  - iOS进阶\n  - ''\ncatgories: iOS\ncategories:\n  - iOS\ndate: 2016-12-27 15:46:00\n---\n### runtime实现的机制是什么？\nruntime是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时我们编写的OC代码在程序运行过程时，最终都是转换成了runtime的C语言\n```\n  OC: [[User alloc] init]\n  runtime: objc_msgSend(objc_msgSend(\"User\", \"alloc\"), \"init\")\n```\n\n### runtime能用来干什么？\n1. 在程序运行过程中，动态的创建一个类\n2. 在程序运行过程中，动态的为某个类添加属性、方法，修改属性值、方法\n3. 遍历一个类的所有成员变量、所有方法\n\n### runtime相关知识\n1. 相关头文件\n   ```\n     <objc/runtime.h>\n     <objc/message.h>\n   ```\n2. 相关函数\n   ```\n    objc_msgSend: 给对象发送消息\n    class_copyMethodList: 获得某个类内部的所有方法\n    class_copyIvarList: 获得某个类内部的所有成员变量\n    class_getInstanceMethod: 获得某个实例方法\n    class_getClassMethod: 获得某个类方法\n    method_exchangeImplementations: 交换两个方法的具体实现\n    objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 关联对象\n   ```\n\n### runtime用法介绍\n1. 发送消息\n   OC方法调用的本质就是发送消息，消息机制的原理就是对象根据方法编号SEL去映射表中查找对应的方法实现\n   ```\n   Person *person = [[Person alloc] init];\n   [person eat];\n\n   // 本质：让对象发送消息\n   objc_msgSend(p, @selector(eat));\n\n   [Person eat];\n\n   // 本质：让类对象发送消息\n   objc_msgSend([Person class], @selector(eat));\n   ```\n2. 交换方法\n   ```\n   + (void)load {\n       // 交换吃和读这两个方法\n       Method m1 = class_getInstanceMethod(self, @selector(eat));\n       Method m2 = class_getInstanceMethod(self, @selector(read));\n    \n       method_exchangeImplementations(m1, m2);\n    }\n\n#pragma mark - Methods\n\n    - (void)eat {\n       NSLog(@\"我非常喜欢美食\");\n    }\n\n    - (void)read {\n       NSLog(@\"我非常喜欢名著\");\n    }\n\n   ```\n3. 动态添加方法\n   ```\n   // 动态给Person类中添加drink方法\n      class_addMethod([person class], @selector(drink), (IMP)drinkWater, \"v@:\");\n   \n   // 调用drink方法         \n      if ([person respondsToSelector:@selector(drink)]) {\n            [person performSelector:@selector(drink)];\n      }\n\n   // 编写drinkWater的实现\n   // 注意点：1、void 前面没有+、- 号 因为是C语言代码  2、必须有两个指定参数(id self, SEL _cmd)\n      void drinkWater(id self, SEL _cmd) {\n          NSLog(@\"我喜欢喝饮料\");\n      }\n   ```\n4. 在方法上添加额外功能\n   ```\n   // 以UIButton为类，扩展点击事件\n\n   @implementation UIButton (Hook)\n\n   + (void)load {\n       static dispatch_once_t onceToken;\n       dispatch_once(&onceToken, ^{\n          Class selfClass = [self class];\n\n          SEL oriSEL = @selector(sendAction:to:forEvent:);\n          Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);\n\n          SEL cusSEL = @selector(mySendAction:to:forEvent:);\n          Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);\n\n          BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n\n          if (addSucc) {\n             class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n          } else {             \n            method_exchangeImplementations(oriMethod, cusMethod);\n          }\n       })\n   }\n\n   - (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n     // 自定义事件\n     [self doSomething];\n\n     [self mySendAction:action to:target forEvent:event];\n   }\n   ```\n\n5. 关联\n   ```\n    void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n    // 参数说明：\n    // object: 与谁关联\n    // key: 唯一键\n    // value: 关联所设置的值\n    // policy: 内存管理策略\n\n    id objc_getAssociatedObject(id object, const void *key)\n    // 参数说明：\n    // object: 与谁关联\n    // key: 唯一键\n\n    void objec_remoteAssociatedObjects(id object)\n    // 参数说明：\n    // object: 与谁关联\n   ```","slug":"runtime机制","published":1,"updated":"2018-08-31T09:48:09.414Z","_id":"cjlhoqwiv002ekj79vdjzdnx7","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"runtime实现的机制是什么？\"><a href=\"#runtime实现的机制是什么？\" class=\"headerlink\" title=\"runtime实现的机制是什么？\"></a>runtime实现的机制是什么？</h3><p>runtime是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时我们编写的OC代码在程序运行过程时，最终都是转换成了runtime的C语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">OC: [[User alloc] init]</div><div class=\"line\">runtime: objc_msgSend(objc_msgSend(&quot;User&quot;, &quot;alloc&quot;), &quot;init&quot;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"runtime能用来干什么？\"><a href=\"#runtime能用来干什么？\" class=\"headerlink\" title=\"runtime能用来干什么？\"></a>runtime能用来干什么？</h3><ol>\n<li>在程序运行过程中，动态的创建一个类</li>\n<li>在程序运行过程中，动态的为某个类添加属性、方法，修改属性值、方法</li>\n<li>遍历一个类的所有成员变量、所有方法</li>\n</ol>\n<h3 id=\"runtime相关知识\"><a href=\"#runtime相关知识\" class=\"headerlink\" title=\"runtime相关知识\"></a>runtime相关知识</h3><ol>\n<li><p>相关头文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;objc/runtime.h&gt;</div><div class=\"line\">&lt;objc/message.h&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>相关函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend: 给对象发送消息</div><div class=\"line\">class_copyMethodList: 获得某个类内部的所有方法</div><div class=\"line\">class_copyIvarList: 获得某个类内部的所有成员变量</div><div class=\"line\">class_getInstanceMethod: 获得某个实例方法</div><div class=\"line\">class_getClassMethod: 获得某个类方法</div><div class=\"line\">method_exchangeImplementations: 交换两个方法的具体实现</div><div class=\"line\">objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 关联对象</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"runtime用法介绍\"><a href=\"#runtime用法介绍\" class=\"headerlink\" title=\"runtime用法介绍\"></a>runtime用法介绍</h3><ol>\n<li><p>发送消息<br>OC方法调用的本质就是发送消息，消息机制的原理就是对象根据方法编号SEL去映射表中查找对应的方法实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *person = [[Person alloc] init];</div><div class=\"line\">[person eat];</div><div class=\"line\"></div><div class=\"line\">// 本质：让对象发送消息</div><div class=\"line\">objc_msgSend(p, @selector(eat));</div><div class=\"line\"></div><div class=\"line\">[Person eat];</div><div class=\"line\"></div><div class=\"line\">// 本质：让类对象发送消息</div><div class=\"line\">objc_msgSend([Person class], @selector(eat));</div></pre></td></tr></table></figure>\n</li>\n<li><p>交换方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">   + (void)load &#123;</div><div class=\"line\">       // 交换吃和读这两个方法</div><div class=\"line\">       Method m1 = class_getInstanceMethod(self, @selector(eat));</div><div class=\"line\">       Method m2 = class_getInstanceMethod(self, @selector(read));</div><div class=\"line\">    </div><div class=\"line\">       method_exchangeImplementations(m1, m2);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark - Methods</div><div class=\"line\"></div><div class=\"line\">    - (void)eat &#123;</div><div class=\"line\">       NSLog(@&quot;我非常喜欢美食&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    - (void)read &#123;</div><div class=\"line\">       NSLog(@&quot;我非常喜欢名著&quot;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>动态添加方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 动态给Person类中添加drink方法</div><div class=\"line\">   class_addMethod([person class], @selector(drink), (IMP)drinkWater, &quot;v@:&quot;);</div><div class=\"line\"></div><div class=\"line\">// 调用drink方法         </div><div class=\"line\">   if ([person respondsToSelector:@selector(drink)]) &#123;</div><div class=\"line\">         [person performSelector:@selector(drink)];</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">// 编写drinkWater的实现</div><div class=\"line\">// 注意点：1、void 前面没有+、- 号 因为是C语言代码  2、必须有两个指定参数(id self, SEL _cmd)</div><div class=\"line\">   void drinkWater(id self, SEL _cmd) &#123;</div><div class=\"line\">       NSLog(@&quot;我喜欢喝饮料&quot;);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在方法上添加额外功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 以UIButton为类，扩展点击事件</div><div class=\"line\"></div><div class=\"line\">@implementation UIButton (Hook)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">       Class selfClass = [self class];</div><div class=\"line\"></div><div class=\"line\">       SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class=\"line\">       Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class=\"line\"></div><div class=\"line\">       SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class=\"line\">       Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class=\"line\"></div><div class=\"line\">       BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\"></div><div class=\"line\">       if (addSucc) &#123;</div><div class=\"line\">          class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">       &#125; else &#123;             </div><div class=\"line\">         method_exchangeImplementations(oriMethod, cusMethod);</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class=\"line\">  // 自定义事件</div><div class=\"line\">  [self doSomething];</div><div class=\"line\"></div><div class=\"line\">  [self mySendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</div><div class=\"line\">// 参数说明：</div><div class=\"line\">// object: 与谁关联</div><div class=\"line\">// key: 唯一键</div><div class=\"line\">// value: 关联所设置的值</div><div class=\"line\">// policy: 内存管理策略</div><div class=\"line\"></div><div class=\"line\">id objc_getAssociatedObject(id object, const void *key)</div><div class=\"line\">// 参数说明：</div><div class=\"line\">// object: 与谁关联</div><div class=\"line\">// key: 唯一键</div><div class=\"line\"></div><div class=\"line\">void objec_remoteAssociatedObjects(id object)</div><div class=\"line\">// 参数说明：</div><div class=\"line\">// object: 与谁关联</div></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"runtime实现的机制是什么？\"><a href=\"#runtime实现的机制是什么？\" class=\"headerlink\" title=\"runtime实现的机制是什么？\"></a>runtime实现的机制是什么？</h3><p>runtime是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时我们编写的OC代码在程序运行过程时，最终都是转换成了runtime的C语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">OC: [[User alloc] init]</div><div class=\"line\">runtime: objc_msgSend(objc_msgSend(&quot;User&quot;, &quot;alloc&quot;), &quot;init&quot;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"runtime能用来干什么？\"><a href=\"#runtime能用来干什么？\" class=\"headerlink\" title=\"runtime能用来干什么？\"></a>runtime能用来干什么？</h3><ol>\n<li>在程序运行过程中，动态的创建一个类</li>\n<li>在程序运行过程中，动态的为某个类添加属性、方法，修改属性值、方法</li>\n<li>遍历一个类的所有成员变量、所有方法</li>\n</ol>\n<h3 id=\"runtime相关知识\"><a href=\"#runtime相关知识\" class=\"headerlink\" title=\"runtime相关知识\"></a>runtime相关知识</h3><ol>\n<li><p>相关头文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;objc/runtime.h&gt;</div><div class=\"line\">&lt;objc/message.h&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>相关函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend: 给对象发送消息</div><div class=\"line\">class_copyMethodList: 获得某个类内部的所有方法</div><div class=\"line\">class_copyIvarList: 获得某个类内部的所有成员变量</div><div class=\"line\">class_getInstanceMethod: 获得某个实例方法</div><div class=\"line\">class_getClassMethod: 获得某个类方法</div><div class=\"line\">method_exchangeImplementations: 交换两个方法的具体实现</div><div class=\"line\">objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 关联对象</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"runtime用法介绍\"><a href=\"#runtime用法介绍\" class=\"headerlink\" title=\"runtime用法介绍\"></a>runtime用法介绍</h3><ol>\n<li><p>发送消息<br>OC方法调用的本质就是发送消息，消息机制的原理就是对象根据方法编号SEL去映射表中查找对应的方法实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *person = [[Person alloc] init];</div><div class=\"line\">[person eat];</div><div class=\"line\"></div><div class=\"line\">// 本质：让对象发送消息</div><div class=\"line\">objc_msgSend(p, @selector(eat));</div><div class=\"line\"></div><div class=\"line\">[Person eat];</div><div class=\"line\"></div><div class=\"line\">// 本质：让类对象发送消息</div><div class=\"line\">objc_msgSend([Person class], @selector(eat));</div></pre></td></tr></table></figure>\n</li>\n<li><p>交换方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">   + (void)load &#123;</div><div class=\"line\">       // 交换吃和读这两个方法</div><div class=\"line\">       Method m1 = class_getInstanceMethod(self, @selector(eat));</div><div class=\"line\">       Method m2 = class_getInstanceMethod(self, @selector(read));</div><div class=\"line\">    </div><div class=\"line\">       method_exchangeImplementations(m1, m2);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">#pragma mark - Methods</div><div class=\"line\"></div><div class=\"line\">    - (void)eat &#123;</div><div class=\"line\">       NSLog(@&quot;我非常喜欢美食&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    - (void)read &#123;</div><div class=\"line\">       NSLog(@&quot;我非常喜欢名著&quot;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>动态添加方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 动态给Person类中添加drink方法</div><div class=\"line\">   class_addMethod([person class], @selector(drink), (IMP)drinkWater, &quot;v@:&quot;);</div><div class=\"line\"></div><div class=\"line\">// 调用drink方法         </div><div class=\"line\">   if ([person respondsToSelector:@selector(drink)]) &#123;</div><div class=\"line\">         [person performSelector:@selector(drink)];</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">// 编写drinkWater的实现</div><div class=\"line\">// 注意点：1、void 前面没有+、- 号 因为是C语言代码  2、必须有两个指定参数(id self, SEL _cmd)</div><div class=\"line\">   void drinkWater(id self, SEL _cmd) &#123;</div><div class=\"line\">       NSLog(@&quot;我喜欢喝饮料&quot;);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在方法上添加额外功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 以UIButton为类，扩展点击事件</div><div class=\"line\"></div><div class=\"line\">@implementation UIButton (Hook)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">       Class selfClass = [self class];</div><div class=\"line\"></div><div class=\"line\">       SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class=\"line\">       Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class=\"line\"></div><div class=\"line\">       SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class=\"line\">       Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class=\"line\"></div><div class=\"line\">       BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\"></div><div class=\"line\">       if (addSucc) &#123;</div><div class=\"line\">          class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">       &#125; else &#123;             </div><div class=\"line\">         method_exchangeImplementations(oriMethod, cusMethod);</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class=\"line\">  // 自定义事件</div><div class=\"line\">  [self doSomething];</div><div class=\"line\"></div><div class=\"line\">  [self mySendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</div><div class=\"line\">// 参数说明：</div><div class=\"line\">// object: 与谁关联</div><div class=\"line\">// key: 唯一键</div><div class=\"line\">// value: 关联所设置的值</div><div class=\"line\">// policy: 内存管理策略</div><div class=\"line\"></div><div class=\"line\">id objc_getAssociatedObject(id object, const void *key)</div><div class=\"line\">// 参数说明：</div><div class=\"line\">// object: 与谁关联</div><div class=\"line\">// key: 唯一键</div><div class=\"line\"></div><div class=\"line\">void objec_remoteAssociatedObjects(id object)</div><div class=\"line\">// 参数说明：</div><div class=\"line\">// object: 与谁关联</div></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"个人博客进阶--Hexo搭建博客","date":"2016-08-25T02:31:00.000Z","_content":"\n在结合Github、Jekyll搭建好自己的博客后，发现无法方便的更换主题和给文章进行分类，通过调查发现很多精美的博客都是结合Github和[Hexo](https://github.com/hexojs/hexo)搭建的，本文就是分享一下我是如何利用Hexo搭建自己的博客的。\n\n### 安装Hexo\n\n#### 安装Node.js\nhexo是一款基于[Node.js](https://nodejs.org/en/)的静态博客框架，所以想要安装Hexo，我们首先需要安装Node.js库。我们可以到Node.js的[官网](https://nodejs.org/en/)下载相应平台的最新版本，一路安装即可。\n\n#### 正式安装Hexo\n\n1.执行安装Hexo命令\n        \n         sudo npm install -g hexo\n        \n2.创建blog文件夹并cd到blog文件夹内\n\n3.执行init命令初始化hexo\n\n         hexo init\n         \n4.生成静态页面\n\n         hexo g\n       \n5.本地启动服务器，进行文章预览\n\n         hexo server\n         \n  在浏览器中输入http://localhost:4000 即可预览文章\n  \n6.将github仓库与blog建立关联\n\n         vi _config.yml\n         \n         deploy:\n            type: git\n            repo: https://github.com/luzhiyongGit/luzhiyongGit.github.io\n            branch: master\n            \n   \n  执行配置命令\n  \n         npm install hexo-deployer-git -S\n         \n7.发布博客\n\n         hexo d\n         \n  执行完毕后，你会发现你的github仓库内容已经发生了更改，同时打开[https://luzhiyonggit.github.io](https://luzhiyonggit.github.io)，能够看到一篇默认博客\n  \n### 利用hexo编写博客\n\n1.新建一篇博客\n\n        hexo new 博客名称\n        \n2.生成博客页面\n\n        hexo g\n        \n3.发布博客\n\n        hexo d\n        \n### 博客主题\n\nHexo有非常多的主题可以选择替换，替换流程也特别方便\n\n1.从[Hexo Themes](https://github.com/hexojs/hexo/wiki/Themes)中找到一个你心仪的主题，本博客使用的是[next](https://github.com/iissnan/hexo-theme-next)\n\n2.在你的blog文件目录下，执行下面的命令\n\n     git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n     \n3.编辑配置信息\n\n     vi _config.yml\n     \n     # Extensions\n     ## Plugins: http://hexo.io/plugins/\n     ## Themes: http://hexo.io/themes/\n     theme: next\n\n\n4.生成博客页面\n\n     hexo g\n     \n5.发布博客\n\n     hexo d\n\n### 特效配置\n\n    next主题有一个[next wiki](https://github.com/iissnan/hexo-theme-next/wiki/)提供了很多特性配置的方案，我们可以通过参考它完成很多特性配置\n     \n### 参考链接\n\n[简洁轻便的博客平台: Hexo详解](http://www.tuicool.com/articles/ueI7naV)\n","source":"_posts/个人博客进阶-Hexo搭建博客.md","raw":"title: 个人博客进阶--Hexo搭建博客\ntags:\n  - 博客\ncategories:\n  - 工具\n  - ''\ndate: 2016-08-25 10:31:00\n---\n\n在结合Github、Jekyll搭建好自己的博客后，发现无法方便的更换主题和给文章进行分类，通过调查发现很多精美的博客都是结合Github和[Hexo](https://github.com/hexojs/hexo)搭建的，本文就是分享一下我是如何利用Hexo搭建自己的博客的。\n\n### 安装Hexo\n\n#### 安装Node.js\nhexo是一款基于[Node.js](https://nodejs.org/en/)的静态博客框架，所以想要安装Hexo，我们首先需要安装Node.js库。我们可以到Node.js的[官网](https://nodejs.org/en/)下载相应平台的最新版本，一路安装即可。\n\n#### 正式安装Hexo\n\n1.执行安装Hexo命令\n        \n         sudo npm install -g hexo\n        \n2.创建blog文件夹并cd到blog文件夹内\n\n3.执行init命令初始化hexo\n\n         hexo init\n         \n4.生成静态页面\n\n         hexo g\n       \n5.本地启动服务器，进行文章预览\n\n         hexo server\n         \n  在浏览器中输入http://localhost:4000 即可预览文章\n  \n6.将github仓库与blog建立关联\n\n         vi _config.yml\n         \n         deploy:\n            type: git\n            repo: https://github.com/luzhiyongGit/luzhiyongGit.github.io\n            branch: master\n            \n   \n  执行配置命令\n  \n         npm install hexo-deployer-git -S\n         \n7.发布博客\n\n         hexo d\n         \n  执行完毕后，你会发现你的github仓库内容已经发生了更改，同时打开[https://luzhiyonggit.github.io](https://luzhiyonggit.github.io)，能够看到一篇默认博客\n  \n### 利用hexo编写博客\n\n1.新建一篇博客\n\n        hexo new 博客名称\n        \n2.生成博客页面\n\n        hexo g\n        \n3.发布博客\n\n        hexo d\n        \n### 博客主题\n\nHexo有非常多的主题可以选择替换，替换流程也特别方便\n\n1.从[Hexo Themes](https://github.com/hexojs/hexo/wiki/Themes)中找到一个你心仪的主题，本博客使用的是[next](https://github.com/iissnan/hexo-theme-next)\n\n2.在你的blog文件目录下，执行下面的命令\n\n     git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n     \n3.编辑配置信息\n\n     vi _config.yml\n     \n     # Extensions\n     ## Plugins: http://hexo.io/plugins/\n     ## Themes: http://hexo.io/themes/\n     theme: next\n\n\n4.生成博客页面\n\n     hexo g\n     \n5.发布博客\n\n     hexo d\n\n### 特效配置\n\n    next主题有一个[next wiki](https://github.com/iissnan/hexo-theme-next/wiki/)提供了很多特性配置的方案，我们可以通过参考它完成很多特性配置\n     \n### 参考链接\n\n[简洁轻便的博客平台: Hexo详解](http://www.tuicool.com/articles/ueI7naV)\n","slug":"个人博客进阶-Hexo搭建博客","published":1,"updated":"2018-08-31T09:49:57.153Z","_id":"cjlhoqwiw002hkj79qbzkvcnv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在结合Github、Jekyll搭建好自己的博客后，发现无法方便的更换主题和给文章进行分类，通过调查发现很多精美的博客都是结合Github和<a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"external\">Hexo</a>搭建的，本文就是分享一下我是如何利用Hexo搭建自己的博客的。</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><p>hexo是一款基于<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a>的静态博客框架，所以想要安装Hexo，我们首先需要安装Node.js库。我们可以到Node.js的<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">官网</a>下载相应平台的最新版本，一路安装即可。</p>\n<h4 id=\"正式安装Hexo\"><a href=\"#正式安装Hexo\" class=\"headerlink\" title=\"正式安装Hexo\"></a>正式安装Hexo</h4><p>1.执行安装Hexo命令</p>\n<pre><code>sudo npm install -g hexo\n</code></pre><p>2.创建blog文件夹并cd到blog文件夹内</p>\n<p>3.执行init命令初始化hexo</p>\n<pre><code>hexo init\n</code></pre><p>4.生成静态页面</p>\n<pre><code>hexo g\n</code></pre><p>5.本地启动服务器，进行文章预览</p>\n<pre><code>hexo server\n</code></pre><p>  在浏览器中输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 即可预览文章</p>\n<p>6.将github仓库与blog建立关联</p>\n<pre><code>vi _config.yml\n\ndeploy:\n   type: git\n   repo: https://github.com/luzhiyongGit/luzhiyongGit.github.io\n   branch: master\n</code></pre><p>  执行配置命令</p>\n<pre><code>npm install hexo-deployer-git -S\n</code></pre><p>7.发布博客</p>\n<pre><code>hexo d\n</code></pre><p>  执行完毕后，你会发现你的github仓库内容已经发生了更改，同时打开<a href=\"https://luzhiyonggit.github.io\" target=\"_blank\" rel=\"external\">https://luzhiyonggit.github.io</a>，能够看到一篇默认博客</p>\n<h3 id=\"利用hexo编写博客\"><a href=\"#利用hexo编写博客\" class=\"headerlink\" title=\"利用hexo编写博客\"></a>利用hexo编写博客</h3><p>1.新建一篇博客</p>\n<pre><code>hexo new 博客名称\n</code></pre><p>2.生成博客页面</p>\n<pre><code>hexo g\n</code></pre><p>3.发布博客</p>\n<pre><code>hexo d\n</code></pre><h3 id=\"博客主题\"><a href=\"#博客主题\" class=\"headerlink\" title=\"博客主题\"></a>博客主题</h3><p>Hexo有非常多的主题可以选择替换，替换流程也特别方便</p>\n<p>1.从<a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">Hexo Themes</a>中找到一个你心仪的主题，本博客使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">next</a></p>\n<p>2.在你的blog文件目录下，执行下面的命令</p>\n<pre><code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n</code></pre><p>3.编辑配置信息</p>\n<pre><code>vi _config.yml\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: next\n</code></pre><p>4.生成博客页面</p>\n<pre><code>hexo g\n</code></pre><p>5.发布博客</p>\n<pre><code>hexo d\n</code></pre><h3 id=\"特效配置\"><a href=\"#特效配置\" class=\"headerlink\" title=\"特效配置\"></a>特效配置</h3><pre><code>next主题有一个[next wiki](https://github.com/iissnan/hexo-theme-next/wiki/)提供了很多特性配置的方案，我们可以通过参考它完成很多特性配置\n</code></pre><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://www.tuicool.com/articles/ueI7naV\" target=\"_blank\" rel=\"external\">简洁轻便的博客平台: Hexo详解</a></p>\n","excerpt":"","more":"<p>在结合Github、Jekyll搭建好自己的博客后，发现无法方便的更换主题和给文章进行分类，通过调查发现很多精美的博客都是结合Github和<a href=\"https://github.com/hexojs/hexo\">Hexo</a>搭建的，本文就是分享一下我是如何利用Hexo搭建自己的博客的。</p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><p>hexo是一款基于<a href=\"https://nodejs.org/en/\">Node.js</a>的静态博客框架，所以想要安装Hexo，我们首先需要安装Node.js库。我们可以到Node.js的<a href=\"https://nodejs.org/en/\">官网</a>下载相应平台的最新版本，一路安装即可。</p>\n<h4 id=\"正式安装Hexo\"><a href=\"#正式安装Hexo\" class=\"headerlink\" title=\"正式安装Hexo\"></a>正式安装Hexo</h4><p>1.执行安装Hexo命令</p>\n<pre><code>sudo npm install -g hexo\n</code></pre><p>2.创建blog文件夹并cd到blog文件夹内</p>\n<p>3.执行init命令初始化hexo</p>\n<pre><code>hexo init\n</code></pre><p>4.生成静态页面</p>\n<pre><code>hexo g\n</code></pre><p>5.本地启动服务器，进行文章预览</p>\n<pre><code>hexo server\n</code></pre><p>  在浏览器中输入<a href=\"http://localhost:4000\">http://localhost:4000</a> 即可预览文章</p>\n<p>6.将github仓库与blog建立关联</p>\n<pre><code>vi _config.yml\n\ndeploy:\n   type: git\n   repo: https://github.com/luzhiyongGit/luzhiyongGit.github.io\n   branch: master\n</code></pre><p>  执行配置命令</p>\n<pre><code>npm install hexo-deployer-git -S\n</code></pre><p>7.发布博客</p>\n<pre><code>hexo d\n</code></pre><p>  执行完毕后，你会发现你的github仓库内容已经发生了更改，同时打开<a href=\"https://luzhiyonggit.github.io\">https://luzhiyonggit.github.io</a>，能够看到一篇默认博客</p>\n<h3 id=\"利用hexo编写博客\"><a href=\"#利用hexo编写博客\" class=\"headerlink\" title=\"利用hexo编写博客\"></a>利用hexo编写博客</h3><p>1.新建一篇博客</p>\n<pre><code>hexo new 博客名称\n</code></pre><p>2.生成博客页面</p>\n<pre><code>hexo g\n</code></pre><p>3.发布博客</p>\n<pre><code>hexo d\n</code></pre><h3 id=\"博客主题\"><a href=\"#博客主题\" class=\"headerlink\" title=\"博客主题\"></a>博客主题</h3><p>Hexo有非常多的主题可以选择替换，替换流程也特别方便</p>\n<p>1.从<a href=\"https://github.com/hexojs/hexo/wiki/Themes\">Hexo Themes</a>中找到一个你心仪的主题，本博客使用的是<a href=\"https://github.com/iissnan/hexo-theme-next\">next</a></p>\n<p>2.在你的blog文件目录下，执行下面的命令</p>\n<pre><code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n</code></pre><p>3.编辑配置信息</p>\n<pre><code>vi _config.yml\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: next\n</code></pre><p>4.生成博客页面</p>\n<pre><code>hexo g\n</code></pre><p>5.发布博客</p>\n<pre><code>hexo d\n</code></pre><h3 id=\"特效配置\"><a href=\"#特效配置\" class=\"headerlink\" title=\"特效配置\"></a>特效配置</h3><pre><code>next主题有一个[next wiki](https://github.com/iissnan/hexo-theme-next/wiki/)提供了很多特性配置的方案，我们可以通过参考它完成很多特性配置\n</code></pre><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://www.tuicool.com/articles/ueI7naV\">简洁轻便的博客平台: Hexo详解</a></p>\n"},{"title":"如何使用OmniPlan","date":"2018-01-30T08:05:00.000Z","_content":"\n近期项目组打算使用`OmniPlan`来制定版本开发计划，这里对如何使用`OmniPlan`进行一个简单的总结。\n\n## 任务视图\n\n点击视图控件中的第一个按钮可以看到任务视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_02_taskview.png)\n\n任务视图包含两部分：任务大纲和甘特图，可以方便的在任务大纲创建、编辑和组合相关的任务，甘特图可以很好的表示任务的周期和关系。\n\n## 资源视图\n\n点击视图控件的第二个按钮可以看到资源视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_03_resourceview.png)\n\n可以在资源视图里添加和管理人员、设备、材料。资源视图也分两部分：大纲和时间轴。可以在大纲里添加、分组和管理资源，在时间轴里可以通过拖拽、删除快速的给任务分配资源。\n\n## 日历视图\n\n点击视图控件的第三个按钮可以看到日历视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_04_calendarview.png)\n\n日历视图分两部分：项目资源列表和编辑工作时间的日历，日历视图还进一步划分了正常时间、额外和业务时间两个模式。\n在正常时间模式里，可以编辑整个项目的工作日历，单个人员的正常工作时间等等，一般用绿色块表示。\n在额外和业余时间模式里，可以设置额外时间或假期时间等，分别用蓝色和红色表示。\n\n## 网络视图\n\n点击视图控件的第四个按钮可以看到网络视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_05_networkview.png)\n\n网络视图提供了一个画布展示项目的任务和线路图。\n\n## 样式视图\n\n点击视图控件的第五个按钮可以看到样式视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_06_stylesview.png)\n\n样式视图主要用于自定义样式风格。\n\n## 使用流程\n\n### 创建项目\n\n选择`文件`->`创建`\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_01_newfile.png)\n创建一个全新的项目，并命名。\n\n### 选择起止日期\n\n为项目选择起止时间，如果无法确定截止时间可以只选择起始时间。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_03_projectstart.png)\n\n### 创建任务\n\n在任务视图按下`Enter`就可以创建一个任务，给每个任务设置持续时间\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_06_tasksandmilestones.png)\n\n### 创建里程碑\n\n里程碑是项目的锚点，用来标记重要的节点，创建里程碑可以通过`结构`->`添加`->`里程碑`来创建或者将任务类型切换为里程碑。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_04_taskinfomilestone.png)\n\n### 编辑工作周\n\n切换到日历视图，默认情况下工作时间是周一到周五的8:00 AM到5:00 PM，中间有一个小时的午饭时间，不过可以自定义工作时间。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_07_defaultcalendar.png)\n\n有时因为一些原因不会正常工作，这些时间就需要从我们的工作计划中排查，日历视图下有一个额外和业余时间的模式，通过这个模式可以方便的设置额外或假期时间。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_09_extraandoffhours.png)\n\n选择对应的日历，双击拖拽会产生一个蓝色区域，这个区域表示正常工作时数之外的可用时数。按住`Shift`然后拖拽会产生一个红色区域，这个区域会把正常工作时间标记为不可用。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_11_thanksgivingtimeoff.png)\n\n### 组任务\n\n如果任务关系精密或相互依赖，可以把他们放入一个组里。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_13_tasksselectedforgrouping.png)\n\n### 链接任务依赖性\n\n我们不可能同时进行所有的任务，我们可以通过给任务直接建立依赖来排列我们的工作。\n\n选中需要建立依赖的两个任务，点击菜单栏上的`关联线`按钮，就能成功在两个任务之间建立好依赖。\n\n\n","source":"_posts/如何使用OmniPlan.md","raw":"title: 如何使用OmniPlan\ntags:\n  - ''\ncategories:\n  - 工具\ndate: 2018-01-30 16:05:00\n---\n\n近期项目组打算使用`OmniPlan`来制定版本开发计划，这里对如何使用`OmniPlan`进行一个简单的总结。\n\n## 任务视图\n\n点击视图控件中的第一个按钮可以看到任务视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_02_taskview.png)\n\n任务视图包含两部分：任务大纲和甘特图，可以方便的在任务大纲创建、编辑和组合相关的任务，甘特图可以很好的表示任务的周期和关系。\n\n## 资源视图\n\n点击视图控件的第二个按钮可以看到资源视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_03_resourceview.png)\n\n可以在资源视图里添加和管理人员、设备、材料。资源视图也分两部分：大纲和时间轴。可以在大纲里添加、分组和管理资源，在时间轴里可以通过拖拽、删除快速的给任务分配资源。\n\n## 日历视图\n\n点击视图控件的第三个按钮可以看到日历视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_04_calendarview.png)\n\n日历视图分两部分：项目资源列表和编辑工作时间的日历，日历视图还进一步划分了正常时间、额外和业务时间两个模式。\n在正常时间模式里，可以编辑整个项目的工作日历，单个人员的正常工作时间等等，一般用绿色块表示。\n在额外和业余时间模式里，可以设置额外时间或假期时间等，分别用蓝色和红色表示。\n\n## 网络视图\n\n点击视图控件的第四个按钮可以看到网络视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_05_networkview.png)\n\n网络视图提供了一个画布展示项目的任务和线路图。\n\n## 样式视图\n\n点击视图控件的第五个按钮可以看到样式视图。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_06_stylesview.png)\n\n样式视图主要用于自定义样式风格。\n\n## 使用流程\n\n### 创建项目\n\n选择`文件`->`创建`\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_01_newfile.png)\n创建一个全新的项目，并命名。\n\n### 选择起止日期\n\n为项目选择起止时间，如果无法确定截止时间可以只选择起始时间。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_03_projectstart.png)\n\n### 创建任务\n\n在任务视图按下`Enter`就可以创建一个任务，给每个任务设置持续时间\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_06_tasksandmilestones.png)\n\n### 创建里程碑\n\n里程碑是项目的锚点，用来标记重要的节点，创建里程碑可以通过`结构`->`添加`->`里程碑`来创建或者将任务类型切换为里程碑。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_04_taskinfomilestone.png)\n\n### 编辑工作周\n\n切换到日历视图，默认情况下工作时间是周一到周五的8:00 AM到5:00 PM，中间有一个小时的午饭时间，不过可以自定义工作时间。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_07_defaultcalendar.png)\n\n有时因为一些原因不会正常工作，这些时间就需要从我们的工作计划中排查，日历视图下有一个额外和业余时间的模式，通过这个模式可以方便的设置额外或假期时间。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_09_extraandoffhours.png)\n\n选择对应的日历，双击拖拽会产生一个蓝色区域，这个区域表示正常工作时数之外的可用时数。按住`Shift`然后拖拽会产生一个红色区域，这个区域会把正常工作时间标记为不可用。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_11_thanksgivingtimeoff.png)\n\n### 组任务\n\n如果任务关系精密或相互依赖，可以把他们放入一个组里。\n\n![](https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_13_tasksselectedforgrouping.png)\n\n### 链接任务依赖性\n\n我们不可能同时进行所有的任务，我们可以通过给任务直接建立依赖来排列我们的工作。\n\n选中需要建立依赖的两个任务，点击菜单栏上的`关联线`按钮，就能成功在两个任务之间建立好依赖。\n\n\n","slug":"如何使用OmniPlan","published":1,"updated":"2018-08-31T09:36:32.796Z","_id":"cjlhoqwiy002lkj79qdz7ipe4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近期项目组打算使用<code>OmniPlan</code>来制定版本开发计划，这里对如何使用<code>OmniPlan</code>进行一个简单的总结。</p>\n<h2 id=\"任务视图\"><a href=\"#任务视图\" class=\"headerlink\" title=\"任务视图\"></a>任务视图</h2><p>点击视图控件中的第一个按钮可以看到任务视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_02_taskview.png\" alt=\"\"></p>\n<p>任务视图包含两部分：任务大纲和甘特图，可以方便的在任务大纲创建、编辑和组合相关的任务，甘特图可以很好的表示任务的周期和关系。</p>\n<h2 id=\"资源视图\"><a href=\"#资源视图\" class=\"headerlink\" title=\"资源视图\"></a>资源视图</h2><p>点击视图控件的第二个按钮可以看到资源视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_03_resourceview.png\" alt=\"\"></p>\n<p>可以在资源视图里添加和管理人员、设备、材料。资源视图也分两部分：大纲和时间轴。可以在大纲里添加、分组和管理资源，在时间轴里可以通过拖拽、删除快速的给任务分配资源。</p>\n<h2 id=\"日历视图\"><a href=\"#日历视图\" class=\"headerlink\" title=\"日历视图\"></a>日历视图</h2><p>点击视图控件的第三个按钮可以看到日历视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_04_calendarview.png\" alt=\"\"></p>\n<p>日历视图分两部分：项目资源列表和编辑工作时间的日历，日历视图还进一步划分了正常时间、额外和业务时间两个模式。<br>在正常时间模式里，可以编辑整个项目的工作日历，单个人员的正常工作时间等等，一般用绿色块表示。<br>在额外和业余时间模式里，可以设置额外时间或假期时间等，分别用蓝色和红色表示。</p>\n<h2 id=\"网络视图\"><a href=\"#网络视图\" class=\"headerlink\" title=\"网络视图\"></a>网络视图</h2><p>点击视图控件的第四个按钮可以看到网络视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_05_networkview.png\" alt=\"\"></p>\n<p>网络视图提供了一个画布展示项目的任务和线路图。</p>\n<h2 id=\"样式视图\"><a href=\"#样式视图\" class=\"headerlink\" title=\"样式视图\"></a>样式视图</h2><p>点击视图控件的第五个按钮可以看到样式视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_06_stylesview.png\" alt=\"\"></p>\n<p>样式视图主要用于自定义样式风格。</p>\n<h2 id=\"使用流程\"><a href=\"#使用流程\" class=\"headerlink\" title=\"使用流程\"></a>使用流程</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>选择<code>文件</code>-&gt;<code>创建</code><br><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_01_newfile.png\" alt=\"\"><br>创建一个全新的项目，并命名。</p>\n<h3 id=\"选择起止日期\"><a href=\"#选择起止日期\" class=\"headerlink\" title=\"选择起止日期\"></a>选择起止日期</h3><p>为项目选择起止时间，如果无法确定截止时间可以只选择起始时间。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_03_projectstart.png\" alt=\"\"></p>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><p>在任务视图按下<code>Enter</code>就可以创建一个任务，给每个任务设置持续时间</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_06_tasksandmilestones.png\" alt=\"\"></p>\n<h3 id=\"创建里程碑\"><a href=\"#创建里程碑\" class=\"headerlink\" title=\"创建里程碑\"></a>创建里程碑</h3><p>里程碑是项目的锚点，用来标记重要的节点，创建里程碑可以通过<code>结构</code>-&gt;<code>添加</code>-&gt;<code>里程碑</code>来创建或者将任务类型切换为里程碑。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_04_taskinfomilestone.png\" alt=\"\"></p>\n<h3 id=\"编辑工作周\"><a href=\"#编辑工作周\" class=\"headerlink\" title=\"编辑工作周\"></a>编辑工作周</h3><p>切换到日历视图，默认情况下工作时间是周一到周五的8:00 AM到5:00 PM，中间有一个小时的午饭时间，不过可以自定义工作时间。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_07_defaultcalendar.png\" alt=\"\"></p>\n<p>有时因为一些原因不会正常工作，这些时间就需要从我们的工作计划中排查，日历视图下有一个额外和业余时间的模式，通过这个模式可以方便的设置额外或假期时间。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_09_extraandoffhours.png\" alt=\"\"></p>\n<p>选择对应的日历，双击拖拽会产生一个蓝色区域，这个区域表示正常工作时数之外的可用时数。按住<code>Shift</code>然后拖拽会产生一个红色区域，这个区域会把正常工作时间标记为不可用。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_11_thanksgivingtimeoff.png\" alt=\"\"></p>\n<h3 id=\"组任务\"><a href=\"#组任务\" class=\"headerlink\" title=\"组任务\"></a>组任务</h3><p>如果任务关系精密或相互依赖，可以把他们放入一个组里。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_13_tasksselectedforgrouping.png\" alt=\"\"></p>\n<h3 id=\"链接任务依赖性\"><a href=\"#链接任务依赖性\" class=\"headerlink\" title=\"链接任务依赖性\"></a>链接任务依赖性</h3><p>我们不可能同时进行所有的任务，我们可以通过给任务直接建立依赖来排列我们的工作。</p>\n<p>选中需要建立依赖的两个任务，点击菜单栏上的<code>关联线</code>按钮，就能成功在两个任务之间建立好依赖。</p>\n","excerpt":"","more":"<p>近期项目组打算使用<code>OmniPlan</code>来制定版本开发计划，这里对如何使用<code>OmniPlan</code>进行一个简单的总结。</p>\n<h2 id=\"任务视图\"><a href=\"#任务视图\" class=\"headerlink\" title=\"任务视图\"></a>任务视图</h2><p>点击视图控件中的第一个按钮可以看到任务视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_02_taskview.png\" alt=\"\"></p>\n<p>任务视图包含两部分：任务大纲和甘特图，可以方便的在任务大纲创建、编辑和组合相关的任务，甘特图可以很好的表示任务的周期和关系。</p>\n<h2 id=\"资源视图\"><a href=\"#资源视图\" class=\"headerlink\" title=\"资源视图\"></a>资源视图</h2><p>点击视图控件的第二个按钮可以看到资源视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_03_resourceview.png\" alt=\"\"></p>\n<p>可以在资源视图里添加和管理人员、设备、材料。资源视图也分两部分：大纲和时间轴。可以在大纲里添加、分组和管理资源，在时间轴里可以通过拖拽、删除快速的给任务分配资源。</p>\n<h2 id=\"日历视图\"><a href=\"#日历视图\" class=\"headerlink\" title=\"日历视图\"></a>日历视图</h2><p>点击视图控件的第三个按钮可以看到日历视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_04_calendarview.png\" alt=\"\"></p>\n<p>日历视图分两部分：项目资源列表和编辑工作时间的日历，日历视图还进一步划分了正常时间、额外和业务时间两个模式。<br>在正常时间模式里，可以编辑整个项目的工作日历，单个人员的正常工作时间等等，一般用绿色块表示。<br>在额外和业余时间模式里，可以设置额外时间或假期时间等，分别用蓝色和红色表示。</p>\n<h2 id=\"网络视图\"><a href=\"#网络视图\" class=\"headerlink\" title=\"网络视图\"></a>网络视图</h2><p>点击视图控件的第四个按钮可以看到网络视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_05_networkview.png\" alt=\"\"></p>\n<p>网络视图提供了一个画布展示项目的任务和线路图。</p>\n<h2 id=\"样式视图\"><a href=\"#样式视图\" class=\"headerlink\" title=\"样式视图\"></a>样式视图</h2><p>点击视图控件的第五个按钮可以看到样式视图。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch02_06_stylesview.png\" alt=\"\"></p>\n<p>样式视图主要用于自定义样式风格。</p>\n<h2 id=\"使用流程\"><a href=\"#使用流程\" class=\"headerlink\" title=\"使用流程\"></a>使用流程</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>选择<code>文件</code>-&gt;<code>创建</code><br><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_01_newfile.png\" alt=\"\"><br>创建一个全新的项目，并命名。</p>\n<h3 id=\"选择起止日期\"><a href=\"#选择起止日期\" class=\"headerlink\" title=\"选择起止日期\"></a>选择起止日期</h3><p>为项目选择起止时间，如果无法确定截止时间可以只选择起始时间。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_03_projectstart.png\" alt=\"\"></p>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><p>在任务视图按下<code>Enter</code>就可以创建一个任务，给每个任务设置持续时间</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_06_tasksandmilestones.png\" alt=\"\"></p>\n<h3 id=\"创建里程碑\"><a href=\"#创建里程碑\" class=\"headerlink\" title=\"创建里程碑\"></a>创建里程碑</h3><p>里程碑是项目的锚点，用来标记重要的节点，创建里程碑可以通过<code>结构</code>-&gt;<code>添加</code>-&gt;<code>里程碑</code>来创建或者将任务类型切换为里程碑。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_04_taskinfomilestone.png\" alt=\"\"></p>\n<h3 id=\"编辑工作周\"><a href=\"#编辑工作周\" class=\"headerlink\" title=\"编辑工作周\"></a>编辑工作周</h3><p>切换到日历视图，默认情况下工作时间是周一到周五的8:00 AM到5:00 PM，中间有一个小时的午饭时间，不过可以自定义工作时间。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_07_defaultcalendar.png\" alt=\"\"></p>\n<p>有时因为一些原因不会正常工作，这些时间就需要从我们的工作计划中排查，日历视图下有一个额外和业余时间的模式，通过这个模式可以方便的设置额外或假期时间。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_09_extraandoffhours.png\" alt=\"\"></p>\n<p>选择对应的日历，双击拖拽会产生一个蓝色区域，这个区域表示正常工作时数之外的可用时数。按住<code>Shift</code>然后拖拽会产生一个红色区域，这个区域会把正常工作时间标记为不可用。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_11_thanksgivingtimeoff.png\" alt=\"\"></p>\n<h3 id=\"组任务\"><a href=\"#组任务\" class=\"headerlink\" title=\"组任务\"></a>组任务</h3><p>如果任务关系精密或相互依赖，可以把他们放入一个组里。</p>\n<p><img src=\"https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.6.0.0/en/EPUB/art/op3mac_ch03_13_tasksselectedforgrouping.png\" alt=\"\"></p>\n<h3 id=\"链接任务依赖性\"><a href=\"#链接任务依赖性\" class=\"headerlink\" title=\"链接任务依赖性\"></a>链接任务依赖性</h3><p>我们不可能同时进行所有的任务，我们可以通过给任务直接建立依赖来排列我们的工作。</p>\n<p>选中需要建立依赖的两个任务，点击菜单栏上的<code>关联线</code>按钮，就能成功在两个任务之间建立好依赖。</p>\n"},{"title":"如何搭建属于自己的博客？","date":"2016-08-08T02:19:00.000Z","_content":"本文主要介绍使用 Github、Jekyll 打造自己的免费独立博客的方法\n\n[Github](http://www.github.com)是一个代码托管网站，现在很多开源项目都放在Github上。Github还提供了一个功能，叫Github Pages，利用这个功能，我们可以为项目建立网站，当然，这也意味着我们可以通过Github Pages建立自己的博客。\n\n[Jekyll](http://jekyllrb.com/)是一个简单的，针对博客设计的静态网站生成器。通过结合使用Github和Jekyll，我们可以打造自己的独立博客，可以自由的定制网站风格，并且这一切都是免费的。\n\n## 入门指引\n\n[Github Pages](https://pages.github.com/)的主页提供了一个简单的入门指引，阅读并操作一遍，会有一个直观的认识。\n\n阮一峰的文章[搭建一个免费的，无限流量的Blog---Github Pages和Jekyll入门](http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html)是一篇特别好的入门文章。\n\n## 建立自己的博客\n\n在搭建独立博客时，通过有三种方式可以选择：\n \n   1. 完全自定义博客\n   2. 找一个框架，基于框架修改使用\n   3. 从Github上找一个比较好的源码，fork使用\n\n本博客选择的是第三种方法，在Github上有一个比较火的开源博客项目[jekyll-now](https://github.com/barryclark/jekyll-now)，这个项目的特点是，所有操作都是通过网页进行，不需要懂命令行，对于刚入门的新手来说非常实用。\n\n## 参考文章\n[搭建一个免费的，无限流量的Blog---Github Pages和Jekyll入门](http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html)\n\n[使用Github、Jekyll打造自己的免费独立博客](http://blog.csdn.net/on_1y/article/details/19259435)","source":"_posts/如何搭建属于自己的博客.md","raw":"title: 如何搭建属于自己的博客？\ntags:\n  - 博客\ncategories:\n  - 工具\n  - ''\ndate: 2016-08-08 10:19:00\n---\n本文主要介绍使用 Github、Jekyll 打造自己的免费独立博客的方法\n\n[Github](http://www.github.com)是一个代码托管网站，现在很多开源项目都放在Github上。Github还提供了一个功能，叫Github Pages，利用这个功能，我们可以为项目建立网站，当然，这也意味着我们可以通过Github Pages建立自己的博客。\n\n[Jekyll](http://jekyllrb.com/)是一个简单的，针对博客设计的静态网站生成器。通过结合使用Github和Jekyll，我们可以打造自己的独立博客，可以自由的定制网站风格，并且这一切都是免费的。\n\n## 入门指引\n\n[Github Pages](https://pages.github.com/)的主页提供了一个简单的入门指引，阅读并操作一遍，会有一个直观的认识。\n\n阮一峰的文章[搭建一个免费的，无限流量的Blog---Github Pages和Jekyll入门](http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html)是一篇特别好的入门文章。\n\n## 建立自己的博客\n\n在搭建独立博客时，通过有三种方式可以选择：\n \n   1. 完全自定义博客\n   2. 找一个框架，基于框架修改使用\n   3. 从Github上找一个比较好的源码，fork使用\n\n本博客选择的是第三种方法，在Github上有一个比较火的开源博客项目[jekyll-now](https://github.com/barryclark/jekyll-now)，这个项目的特点是，所有操作都是通过网页进行，不需要懂命令行，对于刚入门的新手来说非常实用。\n\n## 参考文章\n[搭建一个免费的，无限流量的Blog---Github Pages和Jekyll入门](http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html)\n\n[使用Github、Jekyll打造自己的免费独立博客](http://blog.csdn.net/on_1y/article/details/19259435)","slug":"如何搭建属于自己的博客","published":1,"updated":"2018-08-31T09:48:41.452Z","_id":"cjlhoqwiz002nkj79ka96zc0i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要介绍使用 Github、Jekyll 打造自己的免费独立博客的方法</p>\n<p><a href=\"http://www.github.com\" target=\"_blank\" rel=\"external\">Github</a>是一个代码托管网站，现在很多开源项目都放在Github上。Github还提供了一个功能，叫Github Pages，利用这个功能，我们可以为项目建立网站，当然，这也意味着我们可以通过Github Pages建立自己的博客。</p>\n<p><a href=\"http://jekyllrb.com/\" target=\"_blank\" rel=\"external\">Jekyll</a>是一个简单的，针对博客设计的静态网站生成器。通过结合使用Github和Jekyll，我们可以打造自己的独立博客，可以自由的定制网站风格，并且这一切都是免费的。</p>\n<h2 id=\"入门指引\"><a href=\"#入门指引\" class=\"headerlink\" title=\"入门指引\"></a>入门指引</h2><p><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">Github Pages</a>的主页提供了一个简单的入门指引，阅读并操作一遍，会有一个直观的认识。</p>\n<p>阮一峰的文章<a href=\"http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\" target=\"_blank\" rel=\"external\">搭建一个免费的，无限流量的Blog—Github Pages和Jekyll入门</a>是一篇特别好的入门文章。</p>\n<h2 id=\"建立自己的博客\"><a href=\"#建立自己的博客\" class=\"headerlink\" title=\"建立自己的博客\"></a>建立自己的博客</h2><p>在搭建独立博客时，通过有三种方式可以选择：</p>\n<ol>\n<li>完全自定义博客</li>\n<li>找一个框架，基于框架修改使用</li>\n<li>从Github上找一个比较好的源码，fork使用</li>\n</ol>\n<p>本博客选择的是第三种方法，在Github上有一个比较火的开源博客项目<a href=\"https://github.com/barryclark/jekyll-now\" target=\"_blank\" rel=\"external\">jekyll-now</a>，这个项目的特点是，所有操作都是通过网页进行，不需要懂命令行，对于刚入门的新手来说非常实用。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\" target=\"_blank\" rel=\"external\">搭建一个免费的，无限流量的Blog—Github Pages和Jekyll入门</a></p>\n<p><a href=\"http://blog.csdn.net/on_1y/article/details/19259435\" target=\"_blank\" rel=\"external\">使用Github、Jekyll打造自己的免费独立博客</a></p>\n","excerpt":"","more":"<p>本文主要介绍使用 Github、Jekyll 打造自己的免费独立博客的方法</p>\n<p><a href=\"http://www.github.com\">Github</a>是一个代码托管网站，现在很多开源项目都放在Github上。Github还提供了一个功能，叫Github Pages，利用这个功能，我们可以为项目建立网站，当然，这也意味着我们可以通过Github Pages建立自己的博客。</p>\n<p><a href=\"http://jekyllrb.com/\">Jekyll</a>是一个简单的，针对博客设计的静态网站生成器。通过结合使用Github和Jekyll，我们可以打造自己的独立博客，可以自由的定制网站风格，并且这一切都是免费的。</p>\n<h2 id=\"入门指引\"><a href=\"#入门指引\" class=\"headerlink\" title=\"入门指引\"></a>入门指引</h2><p><a href=\"https://pages.github.com/\">Github Pages</a>的主页提供了一个简单的入门指引，阅读并操作一遍，会有一个直观的认识。</p>\n<p>阮一峰的文章<a href=\"http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\">搭建一个免费的，无限流量的Blog—Github Pages和Jekyll入门</a>是一篇特别好的入门文章。</p>\n<h2 id=\"建立自己的博客\"><a href=\"#建立自己的博客\" class=\"headerlink\" title=\"建立自己的博客\"></a>建立自己的博客</h2><p>在搭建独立博客时，通过有三种方式可以选择：</p>\n<ol>\n<li>完全自定义博客</li>\n<li>找一个框架，基于框架修改使用</li>\n<li>从Github上找一个比较好的源码，fork使用</li>\n</ol>\n<p>本博客选择的是第三种方法，在Github上有一个比较火的开源博客项目<a href=\"https://github.com/barryclark/jekyll-now\">jekyll-now</a>，这个项目的特点是，所有操作都是通过网页进行，不需要懂命令行，对于刚入门的新手来说非常实用。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\">搭建一个免费的，无限流量的Blog—Github Pages和Jekyll入门</a></p>\n<p><a href=\"http://blog.csdn.net/on_1y/article/details/19259435\">使用Github、Jekyll打造自己的免费独立博客</a></p>\n"},{"title":"利用SDWebImage下载图片","date":"2017-07-05T07:04:00.000Z","_content":"\n\n### 利用SDWebImage下载图片的原因\n\n近期项目中有一个关于开屏广告加的需求变更。需要客户端将一段时间内的开屏广告图都预先下载到本地，确保用户在网络不佳甚至断网的情况下都能看到我们的开屏广告。一般情况下我们都是通过`SDWebImage`来动态的加载网络图片，能不能通过`SDWebImage`来帮我们预先下载好图片呢？下面就来分享一下我是怎么通过`SDWebImage`预加载图片的 :)\n\n### 封装好的下载类\n\n为了能方便的实现图片的下载，使用，移除等功能的调用，我封装了一个类[ZYImageDownloader](https://github.com/luzhiyongGit/ZYImageDownloader)，并且已经在github上开源，有兴趣的伙伴可以直接前往下载\n\n### 原理分析\n\n其实`SDWebImage`内部已经帮我们实现了图片下载的类，`SDWebImageDownloader`一个专门用来下载图片的类，`SDWebImagePrefetcher`一个专门用来批量下载图片的类\n\n这里我们主要就是使用了`SDWebImagePrefetcher`来下载图片，我们只需要将要下载的图片地址传入，`SDWebImagePrefetcher`就会帮我们将图片逐个下载下来，并且缓存在本地，缓存的方式和我们通常使用的动态加载图片一样以url为key存储\n\n```\n[[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:prefetchURLs progress:^(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls) {\n        \n} completed:^(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls) {\n        \n}];\n\n```\n当我们需要使用对应地址的图片时，我们只需要以url为key来获取图片即可\n\n```\nNSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:[NSURL URLWithString:imageURL]];\n    UIImage *image = [[SDImageCache sharedImageCache] imageFromCacheForKey:key];\n    return image;\n```\n","source":"_posts/利用SDWebImage下载图片.md","raw":"title: 利用SDWebImage下载图片\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2017-07-05 15:04:00\n---\n\n\n### 利用SDWebImage下载图片的原因\n\n近期项目中有一个关于开屏广告加的需求变更。需要客户端将一段时间内的开屏广告图都预先下载到本地，确保用户在网络不佳甚至断网的情况下都能看到我们的开屏广告。一般情况下我们都是通过`SDWebImage`来动态的加载网络图片，能不能通过`SDWebImage`来帮我们预先下载好图片呢？下面就来分享一下我是怎么通过`SDWebImage`预加载图片的 :)\n\n### 封装好的下载类\n\n为了能方便的实现图片的下载，使用，移除等功能的调用，我封装了一个类[ZYImageDownloader](https://github.com/luzhiyongGit/ZYImageDownloader)，并且已经在github上开源，有兴趣的伙伴可以直接前往下载\n\n### 原理分析\n\n其实`SDWebImage`内部已经帮我们实现了图片下载的类，`SDWebImageDownloader`一个专门用来下载图片的类，`SDWebImagePrefetcher`一个专门用来批量下载图片的类\n\n这里我们主要就是使用了`SDWebImagePrefetcher`来下载图片，我们只需要将要下载的图片地址传入，`SDWebImagePrefetcher`就会帮我们将图片逐个下载下来，并且缓存在本地，缓存的方式和我们通常使用的动态加载图片一样以url为key存储\n\n```\n[[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:prefetchURLs progress:^(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls) {\n        \n} completed:^(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls) {\n        \n}];\n\n```\n当我们需要使用对应地址的图片时，我们只需要以url为key来获取图片即可\n\n```\nNSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:[NSURL URLWithString:imageURL]];\n    UIImage *image = [[SDImageCache sharedImageCache] imageFromCacheForKey:key];\n    return image;\n```\n","slug":"利用SDWebImage下载图片","published":1,"updated":"2018-08-31T09:44:10.993Z","_id":"cjlhoqwj1002rkj79gwy5i3gx","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"利用SDWebImage下载图片的原因\"><a href=\"#利用SDWebImage下载图片的原因\" class=\"headerlink\" title=\"利用SDWebImage下载图片的原因\"></a>利用SDWebImage下载图片的原因</h3><p>近期项目中有一个关于开屏广告加的需求变更。需要客户端将一段时间内的开屏广告图都预先下载到本地，确保用户在网络不佳甚至断网的情况下都能看到我们的开屏广告。一般情况下我们都是通过<code>SDWebImage</code>来动态的加载网络图片，能不能通过<code>SDWebImage</code>来帮我们预先下载好图片呢？下面就来分享一下我是怎么通过<code>SDWebImage</code>预加载图片的 :)</p>\n<h3 id=\"封装好的下载类\"><a href=\"#封装好的下载类\" class=\"headerlink\" title=\"封装好的下载类\"></a>封装好的下载类</h3><p>为了能方便的实现图片的下载，使用，移除等功能的调用，我封装了一个类<a href=\"https://github.com/luzhiyongGit/ZYImageDownloader\" target=\"_blank\" rel=\"external\">ZYImageDownloader</a>，并且已经在github上开源，有兴趣的伙伴可以直接前往下载</p>\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>其实<code>SDWebImage</code>内部已经帮我们实现了图片下载的类，<code>SDWebImageDownloader</code>一个专门用来下载图片的类，<code>SDWebImagePrefetcher</code>一个专门用来批量下载图片的类</p>\n<p>这里我们主要就是使用了<code>SDWebImagePrefetcher</code>来下载图片，我们只需要将要下载的图片地址传入，<code>SDWebImagePrefetcher</code>就会帮我们将图片逐个下载下来，并且缓存在本地，缓存的方式和我们通常使用的动态加载图片一样以url为key存储</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:prefetchURLs progress:^(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls) &#123;</div><div class=\"line\">        </div><div class=\"line\">&#125; completed:^(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls) &#123;</div><div class=\"line\">        </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>当我们需要使用对应地址的图片时，我们只需要以url为key来获取图片即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:[NSURL URLWithString:imageURL]];</div><div class=\"line\">    UIImage *image = [[SDImageCache sharedImageCache] imageFromCacheForKey:key];</div><div class=\"line\">    return image;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"利用SDWebImage下载图片的原因\"><a href=\"#利用SDWebImage下载图片的原因\" class=\"headerlink\" title=\"利用SDWebImage下载图片的原因\"></a>利用SDWebImage下载图片的原因</h3><p>近期项目中有一个关于开屏广告加的需求变更。需要客户端将一段时间内的开屏广告图都预先下载到本地，确保用户在网络不佳甚至断网的情况下都能看到我们的开屏广告。一般情况下我们都是通过<code>SDWebImage</code>来动态的加载网络图片，能不能通过<code>SDWebImage</code>来帮我们预先下载好图片呢？下面就来分享一下我是怎么通过<code>SDWebImage</code>预加载图片的 :)</p>\n<h3 id=\"封装好的下载类\"><a href=\"#封装好的下载类\" class=\"headerlink\" title=\"封装好的下载类\"></a>封装好的下载类</h3><p>为了能方便的实现图片的下载，使用，移除等功能的调用，我封装了一个类<a href=\"https://github.com/luzhiyongGit/ZYImageDownloader\">ZYImageDownloader</a>，并且已经在github上开源，有兴趣的伙伴可以直接前往下载</p>\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>其实<code>SDWebImage</code>内部已经帮我们实现了图片下载的类，<code>SDWebImageDownloader</code>一个专门用来下载图片的类，<code>SDWebImagePrefetcher</code>一个专门用来批量下载图片的类</p>\n<p>这里我们主要就是使用了<code>SDWebImagePrefetcher</code>来下载图片，我们只需要将要下载的图片地址传入，<code>SDWebImagePrefetcher</code>就会帮我们将图片逐个下载下来，并且缓存在本地，缓存的方式和我们通常使用的动态加载图片一样以url为key存储</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:prefetchURLs progress:^(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls) &#123;</div><div class=\"line\">        </div><div class=\"line\">&#125; completed:^(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls) &#123;</div><div class=\"line\">        </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>当我们需要使用对应地址的图片时，我们只需要以url为key来获取图片即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:[NSURL URLWithString:imageURL]];</div><div class=\"line\">    UIImage *image = [[SDImageCache sharedImageCache] imageFromCacheForKey:key];</div><div class=\"line\">    return image;</div></pre></td></tr></table></figure>\n"},{"title":"开发者账号批量导入设备号","date":"2017-12-14T11:08:00.000Z","_content":"\n最近项目需要分发一个包给一批同事提前试用一下，如果通过testflight分发的话还需要提交苹果审核有点麻烦，通过adhoc分发不失为一个比较好的方法，这就需要我们往开发者账号里导入一批uuid。\n\n开发者账号后台为我们提供了一个批量上传的方案，这里为大家做一个简单的总结\n\n- 进入开发者账号后台，选择批量注册设备\n![add_multiple_devices.png](http://upload-images.jianshu.io/upload_images/1479547-6b88a99ac4141fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 开发者账号后台为我们提供了批量导入设备的示范文件\n![download_sample.png](http://upload-images.jianshu.io/upload_images/1479547-38501221b45b8119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 下载下来的示范文件包含三个文件，我们只需要打开`multiple-device-upload-ios.txt`即可\n![sample_files.png](http://upload-images.jianshu.io/upload_images/1479547-204b3479d305cf36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 参考示范格式，写入你的设备uuid和对应名称\n![upload_content.png](http://upload-images.jianshu.io/upload_images/1479547-a4b3d661fa8d62de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 上传文件注册成功后会显示如图界面\n![upload_success.png](http://upload-images.jianshu.io/upload_images/1479547-d2791809b4e981d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n根据系统提示操作直至完成。","source":"_posts/开发者账号批量导入设备号.md","raw":"title: 开发者账号批量导入设备号\ntags:\n  - iOS技巧\n  - ''\ncategories:\n  - iOS\ndate: 2017-12-14 19:08:00\n---\n\n最近项目需要分发一个包给一批同事提前试用一下，如果通过testflight分发的话还需要提交苹果审核有点麻烦，通过adhoc分发不失为一个比较好的方法，这就需要我们往开发者账号里导入一批uuid。\n\n开发者账号后台为我们提供了一个批量上传的方案，这里为大家做一个简单的总结\n\n- 进入开发者账号后台，选择批量注册设备\n![add_multiple_devices.png](http://upload-images.jianshu.io/upload_images/1479547-6b88a99ac4141fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 开发者账号后台为我们提供了批量导入设备的示范文件\n![download_sample.png](http://upload-images.jianshu.io/upload_images/1479547-38501221b45b8119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 下载下来的示范文件包含三个文件，我们只需要打开`multiple-device-upload-ios.txt`即可\n![sample_files.png](http://upload-images.jianshu.io/upload_images/1479547-204b3479d305cf36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 参考示范格式，写入你的设备uuid和对应名称\n![upload_content.png](http://upload-images.jianshu.io/upload_images/1479547-a4b3d661fa8d62de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 上传文件注册成功后会显示如图界面\n![upload_success.png](http://upload-images.jianshu.io/upload_images/1479547-d2791809b4e981d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n根据系统提示操作直至完成。","slug":"开发者账号批量导入设备号","published":1,"updated":"2018-08-31T09:42:15.252Z","_id":"cjlhoqwj2002tkj79099qu2rk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近项目需要分发一个包给一批同事提前试用一下，如果通过testflight分发的话还需要提交苹果审核有点麻烦，通过adhoc分发不失为一个比较好的方法，这就需要我们往开发者账号里导入一批uuid。</p>\n<p>开发者账号后台为我们提供了一个批量上传的方案，这里为大家做一个简单的总结</p>\n<ul>\n<li><p>进入开发者账号后台，选择批量注册设备<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-6b88a99ac4141fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"add_multiple_devices.png\"></p>\n</li>\n<li><p>开发者账号后台为我们提供了批量导入设备的示范文件<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-38501221b45b8119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"download_sample.png\"></p>\n</li>\n<li><p>下载下来的示范文件包含三个文件，我们只需要打开<code>multiple-device-upload-ios.txt</code>即可<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-204b3479d305cf36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"sample_files.png\"></p>\n</li>\n<li><p>参考示范格式，写入你的设备uuid和对应名称<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-a4b3d661fa8d62de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"upload_content.png\"></p>\n</li>\n<li><p>上传文件注册成功后会显示如图界面<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-d2791809b4e981d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"upload_success.png\"></p>\n</li>\n</ul>\n<p>根据系统提示操作直至完成。</p>\n","excerpt":"","more":"<p>最近项目需要分发一个包给一批同事提前试用一下，如果通过testflight分发的话还需要提交苹果审核有点麻烦，通过adhoc分发不失为一个比较好的方法，这就需要我们往开发者账号里导入一批uuid。</p>\n<p>开发者账号后台为我们提供了一个批量上传的方案，这里为大家做一个简单的总结</p>\n<ul>\n<li><p>进入开发者账号后台，选择批量注册设备<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-6b88a99ac4141fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"add_multiple_devices.png\"></p>\n</li>\n<li><p>开发者账号后台为我们提供了批量导入设备的示范文件<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-38501221b45b8119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"download_sample.png\"></p>\n</li>\n<li><p>下载下来的示范文件包含三个文件，我们只需要打开<code>multiple-device-upload-ios.txt</code>即可<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-204b3479d305cf36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"sample_files.png\"></p>\n</li>\n<li><p>参考示范格式，写入你的设备uuid和对应名称<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-a4b3d661fa8d62de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"upload_content.png\"></p>\n</li>\n<li><p>上传文件注册成功后会显示如图界面<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-d2791809b4e981d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"upload_success.png\"></p>\n</li>\n</ul>\n<p>根据系统提示操作直至完成。</p>\n"},{"title":"搭建私有Pod","date":"2016-08-12T02:21:00.000Z","_content":"\n[Cocoapods](http://cocoapods.org/)是一款非常好用的iOS依赖库管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库。同时我们也可以将公司中的公共组件或者项目中的核心组件交由它去管理。本文就是给大家介绍一下，如何使用Cocoapods创建私有的Pod仓库。\n\n \n### 创建一个私有Pod的步骤：\n \n 1. 创建并设置一个私有的 **Spec Repo**\n 2. 创建Pod所需管理的项目\n 3. 创建Pod所对应的podspec文件\n 4. 本地测试配置好的podspec文件是否可用\n 5. 向私有的Spec Repo中提交podspec\n 6. 在个人项目中的Podfile中增加刚刚制作好的Pod并使用\n 7. 更新维护podspec\n \n### 创建私有Spec Repo\n \n先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，我们常用的第三方库都是放在[Github](http://www.github.com)里开源的[Specs](https://github.com/CocoaPods/Specs)中，当我们使用CocoaPods后就会在~/.cocoapods/repos目录下生成一个官方的Spec Repo文件夹master。这个master目录的结构如图：\n![Spec Repo](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/Pod/spec_struct.png)\n\n我们首先需要做的就是创建一个类似于master的私有Spec Repo：  \n   1. 创建一个Git仓库  \n   2. 创建完成之后再终端执行如下命令\n      \n      pod repo add [Private Repo Name] [Github Https clone URL]\n \n### 创建Pod项目工程文件\n\nCocoapods为我们提供了一个工具，用来创建Pod管理的项目，相关的文档介绍是[using-pod-lib-create](http://guides.cocoapods.org/making/using-pod-lib-create)，下面我们通过创建一个podDemoLibrary\n     \n     pod lib create podDemoLibrary\n\n这段命令执行完之后，它会问你四个问题：\n\n1.是否需要一个例子工程\n\n2.选择一个测试框架\n\n3.是否基于View测试\n\n4.类的前缀\n\n根据你的实际需求回答这四个问题，通常我们都会选择需要一个例子工程，至于是否需要测试框架或者类的前缀都根据实际请求选择。\n\n回答完问题后，pod会自动帮你创建对应的目录结构，接下来你可以通过终端进入Example文件夹内执行**pod install**，然后打开**podDemoLibrary.workspace**，在Pods工程下面，会有一个Resources文件夹用来存放你的图片资源和一个Classes文件夹用来存放你的代码。至此，pod项目创建已经完成。\n\n### 编辑Pod项目工程文件\npod项目创建完之后你还需要修改它，已达到实现你的功能需求的目的，接下来就是如何编辑Pod文件。\n\n#### 如何添加代码\n\n添加代码的方法同正常的文件创建一样，只是在创建完成之后我们并不能直接使用它，我们需要重新在终端进入Example文件夹内执行**pod install**\n\n#### 如何添加图片资源\n\n想要添加图片资源，首先，我们需要在Assets文件夹内存放图片资源，然后打开**podDemoLibrary.podspec**文件，找到如下代码：\n\n     s.resource_bundles = {\n       'podDemoLibrary' => ['podDemoLibrary/Assets/*.png']\n     } \n\n放开注释，重新执行**pod install**，这样你就能在项目中看到Resource文件夹了。\n\n虽然，你已经能看到Resource文件夹，但是，你并不能直接通过\n   \n      [UIImage imageWithNamed:@\"pic\"];\n      \n加载图片。你可以通过一个宏定义方法加载图片，\n   \n      #define SrcWithName(name) [@\"podDemoLibrary.bundle\" stringByAppendingPathComponent:name]\n      [UIImage imageWithNamed:SrcWithName(@\"pic\")];\n\n\n#### 如何添加依赖库\n\n依赖库的添加需要在**podDemoLibrary.podspec**中添加，s.frameworks 对应的是系统库，s.denpendency 对应的是第三方pod库\n\n### 发布Pod项目\n1.上传代码到git master\n   \n      git add .\n      git commit -m \"Initial Commit\"\n      git push origin master\n      \n2.tag标记\n     \n      git tag -m \"first release\" 0.1.0\n      git push --tags\n      \n3.验证pod\n\n      pod lib lint\n      \n4.发布pod\n\n      pod repo push Specs podDemoLibrary.podspec\n\n### 查找Pod项目\n\n      pod search podDemoLibrary\n      \n如果你能查询到**podDemoLibrary**项目，说明你的pod创建成功了。\n\n### 注意点\n\n在实际使用中遇到了各种零散的问题，这里将遇到的问题做一个总结。\n\n1. 上传了一个错误的tag，需要删除已经上传的tag\n    \n        git tag -d 0.1.0\n        git push origin :refs/tags/0.1.0\n      \n2. pod lib lint时，发现存在warning\n   \n        pod repo push Specs podDemoLibrary.podspec --allow-warnings\n        \n3. 依赖库中有一个framework\n\n        pod repo push Specs podDemoLibrary.podspec --use-libraries\n        \n\n### 参考\n\n[使用Cocoapods创建私有podspec](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n\n\n","source":"_posts/搭建私有Pod.md","raw":"title: 搭建私有Pod\ntags:\n  - iOS进阶\n  - ''\ncategories:\n  - iOS\ndate: 2016-08-12 10:21:00\n---\n\n[Cocoapods](http://cocoapods.org/)是一款非常好用的iOS依赖库管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库。同时我们也可以将公司中的公共组件或者项目中的核心组件交由它去管理。本文就是给大家介绍一下，如何使用Cocoapods创建私有的Pod仓库。\n\n \n### 创建一个私有Pod的步骤：\n \n 1. 创建并设置一个私有的 **Spec Repo**\n 2. 创建Pod所需管理的项目\n 3. 创建Pod所对应的podspec文件\n 4. 本地测试配置好的podspec文件是否可用\n 5. 向私有的Spec Repo中提交podspec\n 6. 在个人项目中的Podfile中增加刚刚制作好的Pod并使用\n 7. 更新维护podspec\n \n### 创建私有Spec Repo\n \n先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，我们常用的第三方库都是放在[Github](http://www.github.com)里开源的[Specs](https://github.com/CocoaPods/Specs)中，当我们使用CocoaPods后就会在~/.cocoapods/repos目录下生成一个官方的Spec Repo文件夹master。这个master目录的结构如图：\n![Spec Repo](https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/Pod/spec_struct.png)\n\n我们首先需要做的就是创建一个类似于master的私有Spec Repo：  \n   1. 创建一个Git仓库  \n   2. 创建完成之后再终端执行如下命令\n      \n      pod repo add [Private Repo Name] [Github Https clone URL]\n \n### 创建Pod项目工程文件\n\nCocoapods为我们提供了一个工具，用来创建Pod管理的项目，相关的文档介绍是[using-pod-lib-create](http://guides.cocoapods.org/making/using-pod-lib-create)，下面我们通过创建一个podDemoLibrary\n     \n     pod lib create podDemoLibrary\n\n这段命令执行完之后，它会问你四个问题：\n\n1.是否需要一个例子工程\n\n2.选择一个测试框架\n\n3.是否基于View测试\n\n4.类的前缀\n\n根据你的实际需求回答这四个问题，通常我们都会选择需要一个例子工程，至于是否需要测试框架或者类的前缀都根据实际请求选择。\n\n回答完问题后，pod会自动帮你创建对应的目录结构，接下来你可以通过终端进入Example文件夹内执行**pod install**，然后打开**podDemoLibrary.workspace**，在Pods工程下面，会有一个Resources文件夹用来存放你的图片资源和一个Classes文件夹用来存放你的代码。至此，pod项目创建已经完成。\n\n### 编辑Pod项目工程文件\npod项目创建完之后你还需要修改它，已达到实现你的功能需求的目的，接下来就是如何编辑Pod文件。\n\n#### 如何添加代码\n\n添加代码的方法同正常的文件创建一样，只是在创建完成之后我们并不能直接使用它，我们需要重新在终端进入Example文件夹内执行**pod install**\n\n#### 如何添加图片资源\n\n想要添加图片资源，首先，我们需要在Assets文件夹内存放图片资源，然后打开**podDemoLibrary.podspec**文件，找到如下代码：\n\n     s.resource_bundles = {\n       'podDemoLibrary' => ['podDemoLibrary/Assets/*.png']\n     } \n\n放开注释，重新执行**pod install**，这样你就能在项目中看到Resource文件夹了。\n\n虽然，你已经能看到Resource文件夹，但是，你并不能直接通过\n   \n      [UIImage imageWithNamed:@\"pic\"];\n      \n加载图片。你可以通过一个宏定义方法加载图片，\n   \n      #define SrcWithName(name) [@\"podDemoLibrary.bundle\" stringByAppendingPathComponent:name]\n      [UIImage imageWithNamed:SrcWithName(@\"pic\")];\n\n\n#### 如何添加依赖库\n\n依赖库的添加需要在**podDemoLibrary.podspec**中添加，s.frameworks 对应的是系统库，s.denpendency 对应的是第三方pod库\n\n### 发布Pod项目\n1.上传代码到git master\n   \n      git add .\n      git commit -m \"Initial Commit\"\n      git push origin master\n      \n2.tag标记\n     \n      git tag -m \"first release\" 0.1.0\n      git push --tags\n      \n3.验证pod\n\n      pod lib lint\n      \n4.发布pod\n\n      pod repo push Specs podDemoLibrary.podspec\n\n### 查找Pod项目\n\n      pod search podDemoLibrary\n      \n如果你能查询到**podDemoLibrary**项目，说明你的pod创建成功了。\n\n### 注意点\n\n在实际使用中遇到了各种零散的问题，这里将遇到的问题做一个总结。\n\n1. 上传了一个错误的tag，需要删除已经上传的tag\n    \n        git tag -d 0.1.0\n        git push origin :refs/tags/0.1.0\n      \n2. pod lib lint时，发现存在warning\n   \n        pod repo push Specs podDemoLibrary.podspec --allow-warnings\n        \n3. 依赖库中有一个framework\n\n        pod repo push Specs podDemoLibrary.podspec --use-libraries\n        \n\n### 参考\n\n[使用Cocoapods创建私有podspec](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n\n\n","slug":"搭建私有Pod","published":1,"updated":"2018-08-31T09:49:46.856Z","_id":"cjlhoqwj3002xkj79z50567z3","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"http://cocoapods.org/\" target=\"_blank\" rel=\"external\">Cocoapods</a>是一款非常好用的iOS依赖库管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库。同时我们也可以将公司中的公共组件或者项目中的核心组件交由它去管理。本文就是给大家介绍一下，如何使用Cocoapods创建私有的Pod仓库。</p>\n<h3 id=\"创建一个私有Pod的步骤：\"><a href=\"#创建一个私有Pod的步骤：\" class=\"headerlink\" title=\"创建一个私有Pod的步骤：\"></a>创建一个私有Pod的步骤：</h3><ol>\n<li>创建并设置一个私有的 <strong>Spec Repo</strong></li>\n<li>创建Pod所需管理的项目</li>\n<li>创建Pod所对应的podspec文件</li>\n<li>本地测试配置好的podspec文件是否可用</li>\n<li>向私有的Spec Repo中提交podspec</li>\n<li>在个人项目中的Podfile中增加刚刚制作好的Pod并使用</li>\n<li>更新维护podspec</li>\n</ol>\n<h3 id=\"创建私有Spec-Repo\"><a href=\"#创建私有Spec-Repo\" class=\"headerlink\" title=\"创建私有Spec Repo\"></a>创建私有Spec Repo</h3><p>先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，我们常用的第三方库都是放在<a href=\"http://www.github.com\" target=\"_blank\" rel=\"external\">Github</a>里开源的<a href=\"https://github.com/CocoaPods/Specs\" target=\"_blank\" rel=\"external\">Specs</a>中，当我们使用CocoaPods后就会在~/.cocoapods/repos目录下生成一个官方的Spec Repo文件夹master。这个master目录的结构如图：<br><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/Pod/spec_struct.png\" alt=\"Spec Repo\"></p>\n<p>我们首先需要做的就是创建一个类似于master的私有Spec Repo：  </p>\n<ol>\n<li>创建一个Git仓库  </li>\n<li><p>创建完成之后再终端执行如下命令</p>\n<p>pod repo add [Private Repo Name] [Github Https clone URL]</p>\n</li>\n</ol>\n<h3 id=\"创建Pod项目工程文件\"><a href=\"#创建Pod项目工程文件\" class=\"headerlink\" title=\"创建Pod项目工程文件\"></a>创建Pod项目工程文件</h3><p>Cocoapods为我们提供了一个工具，用来创建Pod管理的项目，相关的文档介绍是<a href=\"http://guides.cocoapods.org/making/using-pod-lib-create\" target=\"_blank\" rel=\"external\">using-pod-lib-create</a>，下面我们通过创建一个podDemoLibrary</p>\n<pre><code>pod lib create podDemoLibrary\n</code></pre><p>这段命令执行完之后，它会问你四个问题：</p>\n<p>1.是否需要一个例子工程</p>\n<p>2.选择一个测试框架</p>\n<p>3.是否基于View测试</p>\n<p>4.类的前缀</p>\n<p>根据你的实际需求回答这四个问题，通常我们都会选择需要一个例子工程，至于是否需要测试框架或者类的前缀都根据实际请求选择。</p>\n<p>回答完问题后，pod会自动帮你创建对应的目录结构，接下来你可以通过终端进入Example文件夹内执行<strong>pod install</strong>，然后打开<strong>podDemoLibrary.workspace</strong>，在Pods工程下面，会有一个Resources文件夹用来存放你的图片资源和一个Classes文件夹用来存放你的代码。至此，pod项目创建已经完成。</p>\n<h3 id=\"编辑Pod项目工程文件\"><a href=\"#编辑Pod项目工程文件\" class=\"headerlink\" title=\"编辑Pod项目工程文件\"></a>编辑Pod项目工程文件</h3><p>pod项目创建完之后你还需要修改它，已达到实现你的功能需求的目的，接下来就是如何编辑Pod文件。</p>\n<h4 id=\"如何添加代码\"><a href=\"#如何添加代码\" class=\"headerlink\" title=\"如何添加代码\"></a>如何添加代码</h4><p>添加代码的方法同正常的文件创建一样，只是在创建完成之后我们并不能直接使用它，我们需要重新在终端进入Example文件夹内执行<strong>pod install</strong></p>\n<h4 id=\"如何添加图片资源\"><a href=\"#如何添加图片资源\" class=\"headerlink\" title=\"如何添加图片资源\"></a>如何添加图片资源</h4><p>想要添加图片资源，首先，我们需要在Assets文件夹内存放图片资源，然后打开<strong>podDemoLibrary.podspec</strong>文件，找到如下代码：</p>\n<pre><code>s.resource_bundles = {\n  &apos;podDemoLibrary&apos; =&gt; [&apos;podDemoLibrary/Assets/*.png&apos;]\n} \n</code></pre><p>放开注释，重新执行<strong>pod install</strong>，这样你就能在项目中看到Resource文件夹了。</p>\n<p>虽然，你已经能看到Resource文件夹，但是，你并不能直接通过</p>\n<pre><code>[UIImage imageWithNamed:@&quot;pic&quot;];\n</code></pre><p>加载图片。你可以通过一个宏定义方法加载图片，</p>\n<pre><code>#define SrcWithName(name) [@&quot;podDemoLibrary.bundle&quot; stringByAppendingPathComponent:name]\n[UIImage imageWithNamed:SrcWithName(@&quot;pic&quot;)];\n</code></pre><h4 id=\"如何添加依赖库\"><a href=\"#如何添加依赖库\" class=\"headerlink\" title=\"如何添加依赖库\"></a>如何添加依赖库</h4><p>依赖库的添加需要在<strong>podDemoLibrary.podspec</strong>中添加，s.frameworks 对应的是系统库，s.denpendency 对应的是第三方pod库</p>\n<h3 id=\"发布Pod项目\"><a href=\"#发布Pod项目\" class=\"headerlink\" title=\"发布Pod项目\"></a>发布Pod项目</h3><p>1.上传代码到git master</p>\n<pre><code>git add .\ngit commit -m &quot;Initial Commit&quot;\ngit push origin master\n</code></pre><p>2.tag标记</p>\n<pre><code>git tag -m &quot;first release&quot; 0.1.0\ngit push --tags\n</code></pre><p>3.验证pod</p>\n<pre><code>pod lib lint\n</code></pre><p>4.发布pod</p>\n<pre><code>pod repo push Specs podDemoLibrary.podspec\n</code></pre><h3 id=\"查找Pod项目\"><a href=\"#查找Pod项目\" class=\"headerlink\" title=\"查找Pod项目\"></a>查找Pod项目</h3><pre><code>pod search podDemoLibrary\n</code></pre><p>如果你能查询到<strong>podDemoLibrary</strong>项目，说明你的pod创建成功了。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>在实际使用中遇到了各种零散的问题，这里将遇到的问题做一个总结。</p>\n<ol>\n<li><p>上传了一个错误的tag，需要删除已经上传的tag</p>\n<pre><code>git tag -d 0.1.0\ngit push origin :refs/tags/0.1.0\n</code></pre></li>\n<li><p>pod lib lint时，发现存在warning</p>\n<pre><code>pod repo push Specs podDemoLibrary.podspec --allow-warnings\n</code></pre></li>\n<li><p>依赖库中有一个framework</p>\n<pre><code>pod repo push Specs podDemoLibrary.podspec --use-libraries\n</code></pre></li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"external\">使用Cocoapods创建私有podspec</a></p>\n","excerpt":"","more":"<p><a href=\"http://cocoapods.org/\">Cocoapods</a>是一款非常好用的iOS依赖库管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库。同时我们也可以将公司中的公共组件或者项目中的核心组件交由它去管理。本文就是给大家介绍一下，如何使用Cocoapods创建私有的Pod仓库。</p>\n<h3 id=\"创建一个私有Pod的步骤：\"><a href=\"#创建一个私有Pod的步骤：\" class=\"headerlink\" title=\"创建一个私有Pod的步骤：\"></a>创建一个私有Pod的步骤：</h3><ol>\n<li>创建并设置一个私有的 <strong>Spec Repo</strong></li>\n<li>创建Pod所需管理的项目</li>\n<li>创建Pod所对应的podspec文件</li>\n<li>本地测试配置好的podspec文件是否可用</li>\n<li>向私有的Spec Repo中提交podspec</li>\n<li>在个人项目中的Podfile中增加刚刚制作好的Pod并使用</li>\n<li>更新维护podspec</li>\n</ol>\n<h3 id=\"创建私有Spec-Repo\"><a href=\"#创建私有Spec-Repo\" class=\"headerlink\" title=\"创建私有Spec Repo\"></a>创建私有Spec Repo</h3><p>先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，我们常用的第三方库都是放在<a href=\"http://www.github.com\">Github</a>里开源的<a href=\"https://github.com/CocoaPods/Specs\">Specs</a>中，当我们使用CocoaPods后就会在~/.cocoapods/repos目录下生成一个官方的Spec Repo文件夹master。这个master目录的结构如图：<br><img src=\"https://github.com/luzhiyongGit/luzhiyongGit.github.io/raw/hexo/images/Pod/spec_struct.png\" alt=\"Spec Repo\"></p>\n<p>我们首先需要做的就是创建一个类似于master的私有Spec Repo：  </p>\n<ol>\n<li>创建一个Git仓库  </li>\n<li><p>创建完成之后再终端执行如下命令</p>\n<p>pod repo add [Private Repo Name] [Github Https clone URL]</p>\n</li>\n</ol>\n<h3 id=\"创建Pod项目工程文件\"><a href=\"#创建Pod项目工程文件\" class=\"headerlink\" title=\"创建Pod项目工程文件\"></a>创建Pod项目工程文件</h3><p>Cocoapods为我们提供了一个工具，用来创建Pod管理的项目，相关的文档介绍是<a href=\"http://guides.cocoapods.org/making/using-pod-lib-create\">using-pod-lib-create</a>，下面我们通过创建一个podDemoLibrary</p>\n<pre><code>pod lib create podDemoLibrary\n</code></pre><p>这段命令执行完之后，它会问你四个问题：</p>\n<p>1.是否需要一个例子工程</p>\n<p>2.选择一个测试框架</p>\n<p>3.是否基于View测试</p>\n<p>4.类的前缀</p>\n<p>根据你的实际需求回答这四个问题，通常我们都会选择需要一个例子工程，至于是否需要测试框架或者类的前缀都根据实际请求选择。</p>\n<p>回答完问题后，pod会自动帮你创建对应的目录结构，接下来你可以通过终端进入Example文件夹内执行<strong>pod install</strong>，然后打开<strong>podDemoLibrary.workspace</strong>，在Pods工程下面，会有一个Resources文件夹用来存放你的图片资源和一个Classes文件夹用来存放你的代码。至此，pod项目创建已经完成。</p>\n<h3 id=\"编辑Pod项目工程文件\"><a href=\"#编辑Pod项目工程文件\" class=\"headerlink\" title=\"编辑Pod项目工程文件\"></a>编辑Pod项目工程文件</h3><p>pod项目创建完之后你还需要修改它，已达到实现你的功能需求的目的，接下来就是如何编辑Pod文件。</p>\n<h4 id=\"如何添加代码\"><a href=\"#如何添加代码\" class=\"headerlink\" title=\"如何添加代码\"></a>如何添加代码</h4><p>添加代码的方法同正常的文件创建一样，只是在创建完成之后我们并不能直接使用它，我们需要重新在终端进入Example文件夹内执行<strong>pod install</strong></p>\n<h4 id=\"如何添加图片资源\"><a href=\"#如何添加图片资源\" class=\"headerlink\" title=\"如何添加图片资源\"></a>如何添加图片资源</h4><p>想要添加图片资源，首先，我们需要在Assets文件夹内存放图片资源，然后打开<strong>podDemoLibrary.podspec</strong>文件，找到如下代码：</p>\n<pre><code>s.resource_bundles = {\n  &apos;podDemoLibrary&apos; =&gt; [&apos;podDemoLibrary/Assets/*.png&apos;]\n} \n</code></pre><p>放开注释，重新执行<strong>pod install</strong>，这样你就能在项目中看到Resource文件夹了。</p>\n<p>虽然，你已经能看到Resource文件夹，但是，你并不能直接通过</p>\n<pre><code>[UIImage imageWithNamed:@&quot;pic&quot;];\n</code></pre><p>加载图片。你可以通过一个宏定义方法加载图片，</p>\n<pre><code>#define SrcWithName(name) [@&quot;podDemoLibrary.bundle&quot; stringByAppendingPathComponent:name]\n[UIImage imageWithNamed:SrcWithName(@&quot;pic&quot;)];\n</code></pre><h4 id=\"如何添加依赖库\"><a href=\"#如何添加依赖库\" class=\"headerlink\" title=\"如何添加依赖库\"></a>如何添加依赖库</h4><p>依赖库的添加需要在<strong>podDemoLibrary.podspec</strong>中添加，s.frameworks 对应的是系统库，s.denpendency 对应的是第三方pod库</p>\n<h3 id=\"发布Pod项目\"><a href=\"#发布Pod项目\" class=\"headerlink\" title=\"发布Pod项目\"></a>发布Pod项目</h3><p>1.上传代码到git master</p>\n<pre><code>git add .\ngit commit -m &quot;Initial Commit&quot;\ngit push origin master\n</code></pre><p>2.tag标记</p>\n<pre><code>git tag -m &quot;first release&quot; 0.1.0\ngit push --tags\n</code></pre><p>3.验证pod</p>\n<pre><code>pod lib lint\n</code></pre><p>4.发布pod</p>\n<pre><code>pod repo push Specs podDemoLibrary.podspec\n</code></pre><h3 id=\"查找Pod项目\"><a href=\"#查找Pod项目\" class=\"headerlink\" title=\"查找Pod项目\"></a>查找Pod项目</h3><pre><code>pod search podDemoLibrary\n</code></pre><p>如果你能查询到<strong>podDemoLibrary</strong>项目，说明你的pod创建成功了。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>在实际使用中遇到了各种零散的问题，这里将遇到的问题做一个总结。</p>\n<ol>\n<li><p>上传了一个错误的tag，需要删除已经上传的tag</p>\n<pre><code>git tag -d 0.1.0\ngit push origin :refs/tags/0.1.0\n</code></pre></li>\n<li><p>pod lib lint时，发现存在warning</p>\n<pre><code>pod repo push Specs podDemoLibrary.podspec --allow-warnings\n</code></pre></li>\n<li><p>依赖库中有一个framework</p>\n<pre><code>pod repo push Specs podDemoLibrary.podspec --use-libraries\n</code></pre></li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\">使用Cocoapods创建私有podspec</a></p>\n"},{"title":"引导用户设置支付方式","date":"2018-08-22T05:27:00.000Z","_content":"\n## 背景介绍\n最近改版项目中的支付方式引导流程，参考了几个大厂他们的设置，发现大家都在引导页中添加了一个`去App Store设置`的按钮，用户点击后会帮用户自动跳转到App Store并打开用户的账户设置页，这样一来用户就能很方便的在App Store中添加支付宝或微信支付方式了。既然这个流程这么好当然我们也要实现啦。\n\n## 调研\n网上各种姿势搜索如何帮助用户跳转App Store设置支付方式的页面，发现居然搜不到相关的问题。后来通过抓包分析了其他App调用的链接找到了跳转地址\n\n## 实现\n拿到了跳转地址，后续的流程就简单了，只需要通过`openURL`方法调用即可\n\n```\n[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/editAddress?mt=8\"]];\n```\n","source":"_posts/引导用户设置支付方式.md","raw":"title: 引导用户设置支付方式\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2018-08-22 13:27:00\n---\n\n## 背景介绍\n最近改版项目中的支付方式引导流程，参考了几个大厂他们的设置，发现大家都在引导页中添加了一个`去App Store设置`的按钮，用户点击后会帮用户自动跳转到App Store并打开用户的账户设置页，这样一来用户就能很方便的在App Store中添加支付宝或微信支付方式了。既然这个流程这么好当然我们也要实现啦。\n\n## 调研\n网上各种姿势搜索如何帮助用户跳转App Store设置支付方式的页面，发现居然搜不到相关的问题。后来通过抓包分析了其他App调用的链接找到了跳转地址\n\n## 实现\n拿到了跳转地址，后续的流程就简单了，只需要通过`openURL`方法调用即可\n\n```\n[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/editAddress?mt=8\"]];\n```\n","slug":"引导用户设置支付方式","published":1,"updated":"2018-08-31T09:40:58.229Z","_id":"cjlhoqwj4002zkj796jjqb8hi","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>最近改版项目中的支付方式引导流程，参考了几个大厂他们的设置，发现大家都在引导页中添加了一个<code>去App Store设置</code>的按钮，用户点击后会帮用户自动跳转到App Store并打开用户的账户设置页，这样一来用户就能很方便的在App Store中添加支付宝或微信支付方式了。既然这个流程这么好当然我们也要实现啦。</p>\n<h2 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h2><p>网上各种姿势搜索如何帮助用户跳转App Store设置支付方式的页面，发现居然搜不到相关的问题。后来通过抓包分析了其他App调用的链接找到了跳转地址</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>拿到了跳转地址，后续的流程就简单了，只需要通过<code>openURL</code>方法调用即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/editAddress?mt=8&quot;]];</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>最近改版项目中的支付方式引导流程，参考了几个大厂他们的设置，发现大家都在引导页中添加了一个<code>去App Store设置</code>的按钮，用户点击后会帮用户自动跳转到App Store并打开用户的账户设置页，这样一来用户就能很方便的在App Store中添加支付宝或微信支付方式了。既然这个流程这么好当然我们也要实现啦。</p>\n<h2 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h2><p>网上各种姿势搜索如何帮助用户跳转App Store设置支付方式的页面，发现居然搜不到相关的问题。后来通过抓包分析了其他App调用的链接找到了跳转地址</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>拿到了跳转地址，后续的流程就简单了，只需要通过<code>openURL</code>方法调用即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/editAddress?mt=8&quot;]];</div></pre></td></tr></table></figure>\n"},{"title":"私有pod创建进阶--如何通过pod管理静态库","date":"2016-09-10T07:46:00.000Z","_content":"\n在[搭建私有Pod](http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/)一文中我们已经总结了如何创建私有的Pod，这次来总结一下如果利用Pod生成和管理静态库。\n\n## 创建并发布Pod项目\n\n首先，我们需要参考[搭建私有Pod](http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/)创建一个pod项目至**pod lib lint**验证无误。\n\n## 打包类库\n\n我们需要使用一个cocoapods的插件[cocoapods-packager](https://github.com/CocoaPods/cocoapods-packager)来完成类库的打包。当然也可以手动编译打包，只是过程会很繁琐。\n  \n   1. 安装打包插件\n   \n        sudo gem install cocoapods-packager\n        \n   2. 打包\n   \n        pod package Lib.podspec --library --force\n        \n   **--library**指定打包成 **.a** 文件，如果不带上将会打包成 **.framework** 文件。 **--force**是指强制覆盖。\n   \n## 问题解决\n\n打包完成后我们就能在当前工程的目录下找到类库文件，将类库拖拽到项目中集成遇到了编译报错\n造成编译通不过的原因是无法找到类库中使用的一些系统方法，这是因为我们没有在`podspec`文件里添加系统库的引用和开放头文件。\n    \n        s.public_header_files = 'ZYLib/Classes/**/*.h'\n            \n        s.frameworks = 'UIKit', 'CoreFoundation', 'QuartzCore', 'AssetsLibrary', 'ImageIO', 'Accelerate', 'MobileCoreServices', 'sqlite3', 'libz'\n\n\n   \n## 管理类库\n\n打包完成之后，我们能够在对应项目根目录里找到打包好的文件，我们可以直接将他们拖拽到项目中使用。当然，我们也可以利用Pod来帮我们管理打包好的类库。\n\n1. 在项目根目录中建一个文件夹命名为Release，里面存放一个podspec文件和项目打包成功的.a文件以及.h文件\n2. 修改podspec   \n\n            // 指定.h代码源文件地址\n            s.source_files = 'Release/**/*.h'\n            // 指定.a库地址\n            s.vendored_libraries = 'Release/Lib.a'\n            \n3. 上传Release代码到git master分支，并打上对应tag\n4. 发布pod\n\n贴上Demo中的podspec供参考\n\n         Pod::Spec.new do |s|\n            s.name             = 'ZYLib'\n            s.version          = '0.1.0'\n            s.summary          = 'A short description of ZYLib.'\n\n            s.homepage         = 'https://coding.net/u/ileafly/p/ZYLib/git'\n            s.license          = { :type => 'MIT', :file => 'LICENSE' }\n            s.author           = { 'luzy' => 'luzy@2345.com' }\n            s.source           = { :git => 'https://coding.net/u/ileafly/p/ZYLib/git', :tag => s.version.to_s }\n\n            s.ios.deployment_target = '7.0'\n\n            s.source_files = 'Release/**/*'\n\n            s.vendored_frameworks = 'Release/ZYLib.a'\n  \n            #s.resource_bundles = {\n            #  'ZYLib' => ['ZYLib/Assets/*.png']\n            #}\n\n            s.public_header_files = 'ZYLib/Classes/**/*.h'\n            s.frameworks = 'UIKit', 'CoreFoundation', 'QuartzCore', 'AssetsLibrary', 'ImageIO', 'Accelerate', 'MobileCoreServices', 'sqlite3', 'libz'\n            s.dependency 'AFNetworking', '~> 2.3'\n         end \n\n   \n## 参考文章\n\n[使用CocoaPods开发并打包静态库](http://www.cnblogs.com/brycezhang/p/4117180.html)\n","source":"_posts/私有pod创建进阶-如何通过pod管理静态库.md","raw":"title: 私有pod创建进阶--如何通过pod管理静态库\ntags:\n  - iOS进阶\n  - ''\ncategories:\n  - iOS\ndate: 2016-09-10 15:46:00\n---\n\n在[搭建私有Pod](http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/)一文中我们已经总结了如何创建私有的Pod，这次来总结一下如果利用Pod生成和管理静态库。\n\n## 创建并发布Pod项目\n\n首先，我们需要参考[搭建私有Pod](http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/)创建一个pod项目至**pod lib lint**验证无误。\n\n## 打包类库\n\n我们需要使用一个cocoapods的插件[cocoapods-packager](https://github.com/CocoaPods/cocoapods-packager)来完成类库的打包。当然也可以手动编译打包，只是过程会很繁琐。\n  \n   1. 安装打包插件\n   \n        sudo gem install cocoapods-packager\n        \n   2. 打包\n   \n        pod package Lib.podspec --library --force\n        \n   **--library**指定打包成 **.a** 文件，如果不带上将会打包成 **.framework** 文件。 **--force**是指强制覆盖。\n   \n## 问题解决\n\n打包完成后我们就能在当前工程的目录下找到类库文件，将类库拖拽到项目中集成遇到了编译报错\n造成编译通不过的原因是无法找到类库中使用的一些系统方法，这是因为我们没有在`podspec`文件里添加系统库的引用和开放头文件。\n    \n        s.public_header_files = 'ZYLib/Classes/**/*.h'\n            \n        s.frameworks = 'UIKit', 'CoreFoundation', 'QuartzCore', 'AssetsLibrary', 'ImageIO', 'Accelerate', 'MobileCoreServices', 'sqlite3', 'libz'\n\n\n   \n## 管理类库\n\n打包完成之后，我们能够在对应项目根目录里找到打包好的文件，我们可以直接将他们拖拽到项目中使用。当然，我们也可以利用Pod来帮我们管理打包好的类库。\n\n1. 在项目根目录中建一个文件夹命名为Release，里面存放一个podspec文件和项目打包成功的.a文件以及.h文件\n2. 修改podspec   \n\n            // 指定.h代码源文件地址\n            s.source_files = 'Release/**/*.h'\n            // 指定.a库地址\n            s.vendored_libraries = 'Release/Lib.a'\n            \n3. 上传Release代码到git master分支，并打上对应tag\n4. 发布pod\n\n贴上Demo中的podspec供参考\n\n         Pod::Spec.new do |s|\n            s.name             = 'ZYLib'\n            s.version          = '0.1.0'\n            s.summary          = 'A short description of ZYLib.'\n\n            s.homepage         = 'https://coding.net/u/ileafly/p/ZYLib/git'\n            s.license          = { :type => 'MIT', :file => 'LICENSE' }\n            s.author           = { 'luzy' => 'luzy@2345.com' }\n            s.source           = { :git => 'https://coding.net/u/ileafly/p/ZYLib/git', :tag => s.version.to_s }\n\n            s.ios.deployment_target = '7.0'\n\n            s.source_files = 'Release/**/*'\n\n            s.vendored_frameworks = 'Release/ZYLib.a'\n  \n            #s.resource_bundles = {\n            #  'ZYLib' => ['ZYLib/Assets/*.png']\n            #}\n\n            s.public_header_files = 'ZYLib/Classes/**/*.h'\n            s.frameworks = 'UIKit', 'CoreFoundation', 'QuartzCore', 'AssetsLibrary', 'ImageIO', 'Accelerate', 'MobileCoreServices', 'sqlite3', 'libz'\n            s.dependency 'AFNetworking', '~> 2.3'\n         end \n\n   \n## 参考文章\n\n[使用CocoaPods开发并打包静态库](http://www.cnblogs.com/brycezhang/p/4117180.html)\n","slug":"私有pod创建进阶-如何通过pod管理静态库","published":1,"updated":"2018-08-31T09:50:33.035Z","_id":"cjlhoqwj50032kj793fn9z0u1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在<a href=\"http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/\">搭建私有Pod</a>一文中我们已经总结了如何创建私有的Pod，这次来总结一下如果利用Pod生成和管理静态库。</p>\n<h2 id=\"创建并发布Pod项目\"><a href=\"#创建并发布Pod项目\" class=\"headerlink\" title=\"创建并发布Pod项目\"></a>创建并发布Pod项目</h2><p>首先，我们需要参考<a href=\"http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/\">搭建私有Pod</a>创建一个pod项目至<strong>pod lib lint</strong>验证无误。</p>\n<h2 id=\"打包类库\"><a href=\"#打包类库\" class=\"headerlink\" title=\"打包类库\"></a>打包类库</h2><p>我们需要使用一个cocoapods的插件<a href=\"https://github.com/CocoaPods/cocoapods-packager\" target=\"_blank\" rel=\"external\">cocoapods-packager</a>来完成类库的打包。当然也可以手动编译打包，只是过程会很繁琐。</p>\n<ol>\n<li><p>安装打包插件</p>\n<p>  sudo gem install cocoapods-packager</p>\n</li>\n<li><p>打包</p>\n<p>  pod package Lib.podspec –library –force</p>\n<p><strong>–library</strong>指定打包成 <strong>.a</strong> 文件，如果不带上将会打包成 <strong>.framework</strong> 文件。 <strong>–force</strong>是指强制覆盖。</p>\n</li>\n</ol>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>打包完成后我们就能在当前工程的目录下找到类库文件，将类库拖拽到项目中集成遇到了编译报错<br>造成编译通不过的原因是无法找到类库中使用的一些系统方法，这是因为我们没有在<code>podspec</code>文件里添加系统库的引用和开放头文件。</p>\n<pre><code>s.public_header_files = &apos;ZYLib/Classes/**/*.h&apos;\n\ns.frameworks = &apos;UIKit&apos;, &apos;CoreFoundation&apos;, &apos;QuartzCore&apos;, &apos;AssetsLibrary&apos;, &apos;ImageIO&apos;, &apos;Accelerate&apos;, &apos;MobileCoreServices&apos;, &apos;sqlite3&apos;, &apos;libz&apos;\n</code></pre><h2 id=\"管理类库\"><a href=\"#管理类库\" class=\"headerlink\" title=\"管理类库\"></a>管理类库</h2><p>打包完成之后，我们能够在对应项目根目录里找到打包好的文件，我们可以直接将他们拖拽到项目中使用。当然，我们也可以利用Pod来帮我们管理打包好的类库。</p>\n<ol>\n<li>在项目根目录中建一个文件夹命名为Release，里面存放一个podspec文件和项目打包成功的.a文件以及.h文件</li>\n<li><p>修改podspec   </p>\n<pre><code>// 指定.h代码源文件地址\ns.source_files = &apos;Release/**/*.h&apos;\n// 指定.a库地址\ns.vendored_libraries = &apos;Release/Lib.a&apos;\n</code></pre></li>\n<li><p>上传Release代码到git master分支，并打上对应tag</p>\n</li>\n<li>发布pod</li>\n</ol>\n<p>贴上Demo中的podspec供参考</p>\n<pre><code>Pod::Spec.new do |s|\n   s.name             = &apos;ZYLib&apos;\n   s.version          = &apos;0.1.0&apos;\n   s.summary          = &apos;A short description of ZYLib.&apos;\n\n   s.homepage         = &apos;https://coding.net/u/ileafly/p/ZYLib/git&apos;\n   s.license          = { :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; }\n   s.author           = { &apos;luzy&apos; =&gt; &apos;luzy@2345.com&apos; }\n   s.source           = { :git =&gt; &apos;https://coding.net/u/ileafly/p/ZYLib/git&apos;, :tag =&gt; s.version.to_s }\n\n   s.ios.deployment_target = &apos;7.0&apos;\n\n   s.source_files = &apos;Release/**/*&apos;\n\n   s.vendored_frameworks = &apos;Release/ZYLib.a&apos;\n\n   #s.resource_bundles = {\n   #  &apos;ZYLib&apos; =&gt; [&apos;ZYLib/Assets/*.png&apos;]\n   #}\n\n   s.public_header_files = &apos;ZYLib/Classes/**/*.h&apos;\n   s.frameworks = &apos;UIKit&apos;, &apos;CoreFoundation&apos;, &apos;QuartzCore&apos;, &apos;AssetsLibrary&apos;, &apos;ImageIO&apos;, &apos;Accelerate&apos;, &apos;MobileCoreServices&apos;, &apos;sqlite3&apos;, &apos;libz&apos;\n   s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;\nend \n</code></pre><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.cnblogs.com/brycezhang/p/4117180.html\" target=\"_blank\" rel=\"external\">使用CocoaPods开发并打包静态库</a></p>\n","excerpt":"","more":"<p>在<a href=\"http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/\">搭建私有Pod</a>一文中我们已经总结了如何创建私有的Pod，这次来总结一下如果利用Pod生成和管理静态库。</p>\n<h2 id=\"创建并发布Pod项目\"><a href=\"#创建并发布Pod项目\" class=\"headerlink\" title=\"创建并发布Pod项目\"></a>创建并发布Pod项目</h2><p>首先，我们需要参考<a href=\"http://www.ileafly.com/2016/08/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Pod/\">搭建私有Pod</a>创建一个pod项目至<strong>pod lib lint</strong>验证无误。</p>\n<h2 id=\"打包类库\"><a href=\"#打包类库\" class=\"headerlink\" title=\"打包类库\"></a>打包类库</h2><p>我们需要使用一个cocoapods的插件<a href=\"https://github.com/CocoaPods/cocoapods-packager\">cocoapods-packager</a>来完成类库的打包。当然也可以手动编译打包，只是过程会很繁琐。</p>\n<ol>\n<li><p>安装打包插件</p>\n<p>  sudo gem install cocoapods-packager</p>\n</li>\n<li><p>打包</p>\n<p>  pod package Lib.podspec –library –force</p>\n<p><strong>–library</strong>指定打包成 <strong>.a</strong> 文件，如果不带上将会打包成 <strong>.framework</strong> 文件。 <strong>–force</strong>是指强制覆盖。</p>\n</li>\n</ol>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>打包完成后我们就能在当前工程的目录下找到类库文件，将类库拖拽到项目中集成遇到了编译报错<br>造成编译通不过的原因是无法找到类库中使用的一些系统方法，这是因为我们没有在<code>podspec</code>文件里添加系统库的引用和开放头文件。</p>\n<pre><code>s.public_header_files = &apos;ZYLib/Classes/**/*.h&apos;\n\ns.frameworks = &apos;UIKit&apos;, &apos;CoreFoundation&apos;, &apos;QuartzCore&apos;, &apos;AssetsLibrary&apos;, &apos;ImageIO&apos;, &apos;Accelerate&apos;, &apos;MobileCoreServices&apos;, &apos;sqlite3&apos;, &apos;libz&apos;\n</code></pre><h2 id=\"管理类库\"><a href=\"#管理类库\" class=\"headerlink\" title=\"管理类库\"></a>管理类库</h2><p>打包完成之后，我们能够在对应项目根目录里找到打包好的文件，我们可以直接将他们拖拽到项目中使用。当然，我们也可以利用Pod来帮我们管理打包好的类库。</p>\n<ol>\n<li>在项目根目录中建一个文件夹命名为Release，里面存放一个podspec文件和项目打包成功的.a文件以及.h文件</li>\n<li><p>修改podspec   </p>\n<pre><code>// 指定.h代码源文件地址\ns.source_files = &apos;Release/**/*.h&apos;\n// 指定.a库地址\ns.vendored_libraries = &apos;Release/Lib.a&apos;\n</code></pre></li>\n<li><p>上传Release代码到git master分支，并打上对应tag</p>\n</li>\n<li>发布pod</li>\n</ol>\n<p>贴上Demo中的podspec供参考</p>\n<pre><code>Pod::Spec.new do |s|\n   s.name             = &apos;ZYLib&apos;\n   s.version          = &apos;0.1.0&apos;\n   s.summary          = &apos;A short description of ZYLib.&apos;\n\n   s.homepage         = &apos;https://coding.net/u/ileafly/p/ZYLib/git&apos;\n   s.license          = { :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; }\n   s.author           = { &apos;luzy&apos; =&gt; &apos;luzy@2345.com&apos; }\n   s.source           = { :git =&gt; &apos;https://coding.net/u/ileafly/p/ZYLib/git&apos;, :tag =&gt; s.version.to_s }\n\n   s.ios.deployment_target = &apos;7.0&apos;\n\n   s.source_files = &apos;Release/**/*&apos;\n\n   s.vendored_frameworks = &apos;Release/ZYLib.a&apos;\n\n   #s.resource_bundles = {\n   #  &apos;ZYLib&apos; =&gt; [&apos;ZYLib/Assets/*.png&apos;]\n   #}\n\n   s.public_header_files = &apos;ZYLib/Classes/**/*.h&apos;\n   s.frameworks = &apos;UIKit&apos;, &apos;CoreFoundation&apos;, &apos;QuartzCore&apos;, &apos;AssetsLibrary&apos;, &apos;ImageIO&apos;, &apos;Accelerate&apos;, &apos;MobileCoreServices&apos;, &apos;sqlite3&apos;, &apos;libz&apos;\n   s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;\nend \n</code></pre><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.cnblogs.com/brycezhang/p/4117180.html\">使用CocoaPods开发并打包静态库</a></p>\n"},{"title":"移除Pod管理的库后编译报Link错误","categries":"iOS","date":"2016-10-24T05:59:00.000Z","_content":"\n在将项目中用pod管理的一个库移除后编译居然报错，查看了一下报错信息，编译时还会link被删除的那个库，但是无法link成功，不论是重新执行`pod install`还是清除缓存，clean项目，都无法解决这个问题。\n这是因为虽然我们将库已经从pod管理中删除，但是我们的项目还在link这个库，我们需要去除掉这个link，具体移除步骤如下：\n\n1. 点击项目工程文件进入Build Setting\n2. 找到Other Linker Flags一栏\n3. 删除到相关库的link\n4. 重新编译即可\n\n","source":"_posts/移除Pod管理的库后编译报Link错误.md","raw":"title: 移除Pod管理的库后编译报Link错误\ntags:\n  - iOS基础\n  - ''\ncategries: iOS\ncategories:\n  - iOS\ndate: 2016-10-24 13:59:00\n---\n\n在将项目中用pod管理的一个库移除后编译居然报错，查看了一下报错信息，编译时还会link被删除的那个库，但是无法link成功，不论是重新执行`pod install`还是清除缓存，clean项目，都无法解决这个问题。\n这是因为虽然我们将库已经从pod管理中删除，但是我们的项目还在link这个库，我们需要去除掉这个link，具体移除步骤如下：\n\n1. 点击项目工程文件进入Build Setting\n2. 找到Other Linker Flags一栏\n3. 删除到相关库的link\n4. 重新编译即可\n\n","slug":"移除Pod管理的库后编译报Link错误","published":1,"updated":"2018-08-31T09:51:33.794Z","_id":"cjlhoqwj60035kj79zfgpg6qm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在将项目中用pod管理的一个库移除后编译居然报错，查看了一下报错信息，编译时还会link被删除的那个库，但是无法link成功，不论是重新执行<code>pod install</code>还是清除缓存，clean项目，都无法解决这个问题。<br>这是因为虽然我们将库已经从pod管理中删除，但是我们的项目还在link这个库，我们需要去除掉这个link，具体移除步骤如下：</p>\n<ol>\n<li>点击项目工程文件进入Build Setting</li>\n<li>找到Other Linker Flags一栏</li>\n<li>删除到相关库的link</li>\n<li>重新编译即可</li>\n</ol>\n","excerpt":"","more":"<p>在将项目中用pod管理的一个库移除后编译居然报错，查看了一下报错信息，编译时还会link被删除的那个库，但是无法link成功，不论是重新执行<code>pod install</code>还是清除缓存，clean项目，都无法解决这个问题。<br>这是因为虽然我们将库已经从pod管理中删除，但是我们的项目还在link这个库，我们需要去除掉这个link，具体移除步骤如下：</p>\n<ol>\n<li>点击项目工程文件进入Build Setting</li>\n<li>找到Other Linker Flags一栏</li>\n<li>删除到相关库的link</li>\n<li>重新编译即可</li>\n</ol>\n"},{"title":"自动化打包IPA脚本","catgories":"iOS","date":"2016-11-17T01:29:00.000Z","_content":"\n### 自动化打包IPA原理\n\n当我们用Xcode编译项目时，其实是Xcode执行了`xcodebuild`这条命令。\n\n当我们用Xcode打包项目时，其实是Xcode执行了`xcrun`这条命令。\n\n##### 常用命令\n\n1. xcodebuild -list\n\n   ```shell\n   xcodebuild -list [[-project ]|[-workspace ]] [-json]\n   ```\n\n2. xcodebuild -project\n\n   ```shell\n   xcodebuild [-project] [[-target]...|-alltargets] [-configuration] [-arch]... [-sdk [|]] [-showBuildSettings] [=]... []...\n   ```\n\n3. xcodebuild -workspace\n\n   ```shell\n   xcodebuild -workspace -scheme [-destination]...[-configuration] [-arch]...[-sdk [|]] [-showBuildSettings] [=]\n   ```\n\n4. xcodebuild -exportArchive\n\n   ```shell\n   xcodebuild archive -workspace xxx.xcworkspace -scheme xx -archivePath xxx.xcarchive\n   ```\n\n   ```shell\n   xcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa\n   ```\n\n5. xcrun\n\n   ```shell\n   xcrun -sdk iphoneos PackageApplication build/Release -iphoneos/xx.app -o ~/Desktop/xx.ipa\n   ```\n\n##### 总结\n\n根据上述命令我们有两种方法来生成我们需要的ipa包。\n\n1. 使用`xcodebuild`命令来编译我们的项目生成app，然后再用`xcrun`将app转成ipa\n\n2. 使用`xcodebuild archive`命令来直接生成我们需要的ipa\n\n   由于在 macos10.12和xcode8的环境下，使用`xcrun`方法会出现一个警告\n\n   `warning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.`\n\n   说明`PackageApplication`已经被弃用了，所以建议选择第二种方法来打包。\n\n##### 项目实践\n\n###### 方案一\n\n```shell\n#!/bin/bash\n\nSCHEMENAME=项目的Scheme Name\n\nDATE=`date +%Y%m%d_%H%M`\nSOURCEPATH=$( cd \"$( dirname %0)\" && pwd)\nIPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE\nARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive\nIPANAME=项目名称_$DATE.ipa\n\nPYG_DOMAIN=\"http://www.pgyer.com\"\nPGY_UPLOAD_URL=\"$PYG_DOMAIN/apiv1/app/upload\"\nPGY_UKEY=\"你的蒲公英账号的ukey\"\nPGY_API_KEY=\"你的蒲公英账号的api key\"\n\n# build \nxcodebuild archive -workspace $SOURCEPATH/项目名称.xcworkspace \\\n-scheme $SCHEMENAME \\\n-configuration Release \\\n-archivePath $ARCHIVEPATH\n\nif [ -e $ARCHIVEPATH ]; then\n\techo \"xcodebuild Successful\"\nelse \n\techo \"error:Build Failed!\"\n\texit 1\nfi\n\n# exportArchive ipa\nxcodebuild -exportArchive -archivePath $ARCHIVEPATH \\\n-exportPath $IPAPATH -exportFormat ipa \n\n# xcrun .ipa\n# xcrun -sdk iphoneos PackageApplication \\\n#       -v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\\n#       -o $IPAPATH/$IPANAME\n\nif [ -e $IPAPATH ]; then\n\techo \"Create IPA Success!\"\n\topen $IPAPATH\nelse \n\techo \"error: Create IPA failed!\"\nfi\n\n# upload ipa  上传ipa到蒲公英发布平台\necho \"Uploading the ipa file...\"\necho $IPAPATH\nresponse=`curl -F \"file=@$IPAPATH\" -F \"uKey=$PGY_UKEY\" -F \"_api_key=$PGY_API_KEY\" $PGY_UPLOAD_URL`\necho $response\n\n# send email 邮件通知同事让他们之间去下载\necho \"蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****\" | mail -s \"ipa更新\" ****@163.com,****@163.com,****@163.com,****@163.com\n```\n\n###### 方案二\n\n```shell\n#!/bin/bash\n\nSCHEMENAME=项目的Scheme Name\n\nDATE=`date +%Y%m%d_%H%M`\nSOURCEPATH=$( cd \"$( dirname %0)\" && pwd)\n# IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/CinemaForiPhoneEnterprise_$DATE.ipa\nIPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE\nARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive\nIPANAME=项目名称_$DATE.ipa\n\nPYG_DOMAIN=\"http://www.pgyer.com\"\nPGY_UPLOAD_URL=\"$PYG_DOMAIN/apiv1/app/upload\"\nPGY_UKEY=\"你的蒲公英账号的ukey\"\nPGY_API_KEY=\"你的蒲公英账号的api key\"\n\n# build \nxcodebuild -workspace $SOURCEPATH/项目.xcworkspace \\\n-scheme $SCHEMENAME \\\n-configuration Release \\\nclean \\\nbuild \\\n-derivedDataPath $IPAPATH\n\nif [ -e $IPAPATH ]; then\n\techo \"xcodebuild Successful\"\nelse \n\techo \"error:Build Failed!\"\n\texit 1\nfi\n\n# xcrun .ipa\nxcrun -sdk iphoneos PackageApplication \\\n-v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\\n-o $IPAPATH/$IPANAME\n\nif [ -e $IPAPATH ]; then\n   echo \"Create IPA Success!\"\n    open $IPAPATH\n\t# upload ipa\n   echo \"Uploading the ipa file...\"\n   echo $IPAPATH\n      response=`curl -F \"file=@$IPAPATH/$IPANAME\" -F \"uKey=$PGY_UKEY\" -F \"_api_key=$PGY_API_KEY\" $PGY_UPLOAD_URL`\n   echo $response\n\n   # send email\n   echo \"蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****\" | mail -s \"ipa更新\" ****@163.com,****@163.com,****@163.com,****@163.com\nelse \n\techo \"error: Create IPA failed!\"\nfi\n```\n\n写好已经脚本后，将它拷贝到`/usr/local/bin`目录下，添加权限：`chmod 777 xbuild`\n\n执行完以上操作后，就可以在项目目录下直接执行xbuild打包\n\n通过实践发现方案二可以正常使用，方案一打出来的企业版ipa不能正常安装，应该是证书配置问题，还需要调研。\n\n##### 参考链接\n\n[从零开始写个自动打包IPA脚本](http://www.jianshu.com/p/97c97c2ec1ca)\n\n[iOS 自动构建命令——xcodebuild](http://www.jianshu.com/p/3f43370437d2)\n\n[关于 iOS 批量打包的总结](http://ios.jobbole.com/90259/)\n\n[脚本发送邮件的实现方法](http://stackoverflow.com/questions/1822425/sending-mail-from-a-bash-shell-script?rq=1)\n\n","source":"_posts/自动化打包IPA脚本.md","raw":"title: 自动化打包IPA脚本\ntags:\n  - iOS技巧\n  - ''\ncatgories: iOS\ncategories:\n  - iOS\ndate: 2016-11-17 09:29:00\n---\n\n### 自动化打包IPA原理\n\n当我们用Xcode编译项目时，其实是Xcode执行了`xcodebuild`这条命令。\n\n当我们用Xcode打包项目时，其实是Xcode执行了`xcrun`这条命令。\n\n##### 常用命令\n\n1. xcodebuild -list\n\n   ```shell\n   xcodebuild -list [[-project ]|[-workspace ]] [-json]\n   ```\n\n2. xcodebuild -project\n\n   ```shell\n   xcodebuild [-project] [[-target]...|-alltargets] [-configuration] [-arch]... [-sdk [|]] [-showBuildSettings] [=]... []...\n   ```\n\n3. xcodebuild -workspace\n\n   ```shell\n   xcodebuild -workspace -scheme [-destination]...[-configuration] [-arch]...[-sdk [|]] [-showBuildSettings] [=]\n   ```\n\n4. xcodebuild -exportArchive\n\n   ```shell\n   xcodebuild archive -workspace xxx.xcworkspace -scheme xx -archivePath xxx.xcarchive\n   ```\n\n   ```shell\n   xcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa\n   ```\n\n5. xcrun\n\n   ```shell\n   xcrun -sdk iphoneos PackageApplication build/Release -iphoneos/xx.app -o ~/Desktop/xx.ipa\n   ```\n\n##### 总结\n\n根据上述命令我们有两种方法来生成我们需要的ipa包。\n\n1. 使用`xcodebuild`命令来编译我们的项目生成app，然后再用`xcrun`将app转成ipa\n\n2. 使用`xcodebuild archive`命令来直接生成我们需要的ipa\n\n   由于在 macos10.12和xcode8的环境下，使用`xcrun`方法会出现一个警告\n\n   `warning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.`\n\n   说明`PackageApplication`已经被弃用了，所以建议选择第二种方法来打包。\n\n##### 项目实践\n\n###### 方案一\n\n```shell\n#!/bin/bash\n\nSCHEMENAME=项目的Scheme Name\n\nDATE=`date +%Y%m%d_%H%M`\nSOURCEPATH=$( cd \"$( dirname %0)\" && pwd)\nIPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE\nARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive\nIPANAME=项目名称_$DATE.ipa\n\nPYG_DOMAIN=\"http://www.pgyer.com\"\nPGY_UPLOAD_URL=\"$PYG_DOMAIN/apiv1/app/upload\"\nPGY_UKEY=\"你的蒲公英账号的ukey\"\nPGY_API_KEY=\"你的蒲公英账号的api key\"\n\n# build \nxcodebuild archive -workspace $SOURCEPATH/项目名称.xcworkspace \\\n-scheme $SCHEMENAME \\\n-configuration Release \\\n-archivePath $ARCHIVEPATH\n\nif [ -e $ARCHIVEPATH ]; then\n\techo \"xcodebuild Successful\"\nelse \n\techo \"error:Build Failed!\"\n\texit 1\nfi\n\n# exportArchive ipa\nxcodebuild -exportArchive -archivePath $ARCHIVEPATH \\\n-exportPath $IPAPATH -exportFormat ipa \n\n# xcrun .ipa\n# xcrun -sdk iphoneos PackageApplication \\\n#       -v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\\n#       -o $IPAPATH/$IPANAME\n\nif [ -e $IPAPATH ]; then\n\techo \"Create IPA Success!\"\n\topen $IPAPATH\nelse \n\techo \"error: Create IPA failed!\"\nfi\n\n# upload ipa  上传ipa到蒲公英发布平台\necho \"Uploading the ipa file...\"\necho $IPAPATH\nresponse=`curl -F \"file=@$IPAPATH\" -F \"uKey=$PGY_UKEY\" -F \"_api_key=$PGY_API_KEY\" $PGY_UPLOAD_URL`\necho $response\n\n# send email 邮件通知同事让他们之间去下载\necho \"蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****\" | mail -s \"ipa更新\" ****@163.com,****@163.com,****@163.com,****@163.com\n```\n\n###### 方案二\n\n```shell\n#!/bin/bash\n\nSCHEMENAME=项目的Scheme Name\n\nDATE=`date +%Y%m%d_%H%M`\nSOURCEPATH=$( cd \"$( dirname %0)\" && pwd)\n# IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/CinemaForiPhoneEnterprise_$DATE.ipa\nIPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE\nARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive\nIPANAME=项目名称_$DATE.ipa\n\nPYG_DOMAIN=\"http://www.pgyer.com\"\nPGY_UPLOAD_URL=\"$PYG_DOMAIN/apiv1/app/upload\"\nPGY_UKEY=\"你的蒲公英账号的ukey\"\nPGY_API_KEY=\"你的蒲公英账号的api key\"\n\n# build \nxcodebuild -workspace $SOURCEPATH/项目.xcworkspace \\\n-scheme $SCHEMENAME \\\n-configuration Release \\\nclean \\\nbuild \\\n-derivedDataPath $IPAPATH\n\nif [ -e $IPAPATH ]; then\n\techo \"xcodebuild Successful\"\nelse \n\techo \"error:Build Failed!\"\n\texit 1\nfi\n\n# xcrun .ipa\nxcrun -sdk iphoneos PackageApplication \\\n-v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\\n-o $IPAPATH/$IPANAME\n\nif [ -e $IPAPATH ]; then\n   echo \"Create IPA Success!\"\n    open $IPAPATH\n\t# upload ipa\n   echo \"Uploading the ipa file...\"\n   echo $IPAPATH\n      response=`curl -F \"file=@$IPAPATH/$IPANAME\" -F \"uKey=$PGY_UKEY\" -F \"_api_key=$PGY_API_KEY\" $PGY_UPLOAD_URL`\n   echo $response\n\n   # send email\n   echo \"蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****\" | mail -s \"ipa更新\" ****@163.com,****@163.com,****@163.com,****@163.com\nelse \n\techo \"error: Create IPA failed!\"\nfi\n```\n\n写好已经脚本后，将它拷贝到`/usr/local/bin`目录下，添加权限：`chmod 777 xbuild`\n\n执行完以上操作后，就可以在项目目录下直接执行xbuild打包\n\n通过实践发现方案二可以正常使用，方案一打出来的企业版ipa不能正常安装，应该是证书配置问题，还需要调研。\n\n##### 参考链接\n\n[从零开始写个自动打包IPA脚本](http://www.jianshu.com/p/97c97c2ec1ca)\n\n[iOS 自动构建命令——xcodebuild](http://www.jianshu.com/p/3f43370437d2)\n\n[关于 iOS 批量打包的总结](http://ios.jobbole.com/90259/)\n\n[脚本发送邮件的实现方法](http://stackoverflow.com/questions/1822425/sending-mail-from-a-bash-shell-script?rq=1)\n\n","slug":"自动化打包IPA脚本","published":1,"updated":"2018-08-31T09:54:07.346Z","_id":"cjlhoqwj70038kj79xxgw5dcp","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"自动化打包IPA原理\"><a href=\"#自动化打包IPA原理\" class=\"headerlink\" title=\"自动化打包IPA原理\"></a>自动化打包IPA原理</h3><p>当我们用Xcode编译项目时，其实是Xcode执行了<code>xcodebuild</code>这条命令。</p>\n<p>当我们用Xcode打包项目时，其实是Xcode执行了<code>xcrun</code>这条命令。</p>\n<h5 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h5><ol>\n<li><p>xcodebuild -list</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -list [[-project ]|[-workspace ]] [-json]</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcodebuild -project</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild [-project] [[-target]...|-alltargets] [-configuration] [-arch]... [-sdk [|]] [-showBuildSettings] [=]... []...</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcodebuild -workspace</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -workspace -scheme [-destination]...[-configuration] [-arch]...[-sdk [|]] [-showBuildSettings] [=]</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcodebuild -exportArchive</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild archive -workspace xxx.xcworkspace -scheme xx -archivePath xxx.xcarchive</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcrun</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos PackageApplication build/Release -iphoneos/xx.app -o ~/Desktop/xx.ipa</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>根据上述命令我们有两种方法来生成我们需要的ipa包。</p>\n<ol>\n<li><p>使用<code>xcodebuild</code>命令来编译我们的项目生成app，然后再用<code>xcrun</code>将app转成ipa</p>\n</li>\n<li><p>使用<code>xcodebuild archive</code>命令来直接生成我们需要的ipa</p>\n<p>由于在 macos10.12和xcode8的环境下，使用<code>xcrun</code>方法会出现一个警告</p>\n<p><code>warning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.</code></p>\n<p>说明<code>PackageApplication</code>已经被弃用了，所以建议选择第二种方法来打包。</p>\n</li>\n</ol>\n<h5 id=\"项目实践\"><a href=\"#项目实践\" class=\"headerlink\" title=\"项目实践\"></a>项目实践</h5><h6 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">SCHEMENAME=项目的Scheme Name</div><div class=\"line\"></div><div class=\"line\">DATE=`date +%Y%m%d_%H%M`</div><div class=\"line\">SOURCEPATH=$( cd &quot;$( dirname %0)&quot; &amp;&amp; pwd)</div><div class=\"line\">IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE</div><div class=\"line\">ARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive</div><div class=\"line\">IPANAME=项目名称_$DATE.ipa</div><div class=\"line\"></div><div class=\"line\">PYG_DOMAIN=&quot;http://www.pgyer.com&quot;</div><div class=\"line\">PGY_UPLOAD_URL=&quot;$PYG_DOMAIN/apiv1/app/upload&quot;</div><div class=\"line\">PGY_UKEY=&quot;你的蒲公英账号的ukey&quot;</div><div class=\"line\">PGY_API_KEY=&quot;你的蒲公英账号的api key&quot;</div><div class=\"line\"></div><div class=\"line\"># build </div><div class=\"line\">xcodebuild archive -workspace $SOURCEPATH/项目名称.xcworkspace \\</div><div class=\"line\">-scheme $SCHEMENAME \\</div><div class=\"line\">-configuration Release \\</div><div class=\"line\">-archivePath $ARCHIVEPATH</div><div class=\"line\"></div><div class=\"line\">if [ -e $ARCHIVEPATH ]; then</div><div class=\"line\">\techo &quot;xcodebuild Successful&quot;</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error:Build Failed!&quot;</div><div class=\"line\">\texit 1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\"># exportArchive ipa</div><div class=\"line\">xcodebuild -exportArchive -archivePath $ARCHIVEPATH \\</div><div class=\"line\">-exportPath $IPAPATH -exportFormat ipa </div><div class=\"line\"></div><div class=\"line\"># xcrun .ipa</div><div class=\"line\"># xcrun -sdk iphoneos PackageApplication \\</div><div class=\"line\">#       -v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\</div><div class=\"line\">#       -o $IPAPATH/$IPANAME</div><div class=\"line\"></div><div class=\"line\">if [ -e $IPAPATH ]; then</div><div class=\"line\">\techo &quot;Create IPA Success!&quot;</div><div class=\"line\">\topen $IPAPATH</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error: Create IPA failed!&quot;</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\"># upload ipa  上传ipa到蒲公英发布平台</div><div class=\"line\">echo &quot;Uploading the ipa file...&quot;</div><div class=\"line\">echo $IPAPATH</div><div class=\"line\">response=`curl -F &quot;file=@$IPAPATH&quot; -F &quot;uKey=$PGY_UKEY&quot; -F &quot;_api_key=$PGY_API_KEY&quot; $PGY_UPLOAD_URL`</div><div class=\"line\">echo $response</div><div class=\"line\"></div><div class=\"line\"># send email 邮件通知同事让他们之间去下载</div><div class=\"line\">echo &quot;蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****&quot; | mail -s &quot;ipa更新&quot; ****@163.com,****@163.com,****@163.com,****@163.com</div></pre></td></tr></table></figure>\n<h6 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">SCHEMENAME=项目的Scheme Name</div><div class=\"line\"></div><div class=\"line\">DATE=`date +%Y%m%d_%H%M`</div><div class=\"line\">SOURCEPATH=$( cd &quot;$( dirname %0)&quot; &amp;&amp; pwd)</div><div class=\"line\"># IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/CinemaForiPhoneEnterprise_$DATE.ipa</div><div class=\"line\">IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE</div><div class=\"line\">ARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive</div><div class=\"line\">IPANAME=项目名称_$DATE.ipa</div><div class=\"line\"></div><div class=\"line\">PYG_DOMAIN=&quot;http://www.pgyer.com&quot;</div><div class=\"line\">PGY_UPLOAD_URL=&quot;$PYG_DOMAIN/apiv1/app/upload&quot;</div><div class=\"line\">PGY_UKEY=&quot;你的蒲公英账号的ukey&quot;</div><div class=\"line\">PGY_API_KEY=&quot;你的蒲公英账号的api key&quot;</div><div class=\"line\"></div><div class=\"line\"># build </div><div class=\"line\">xcodebuild -workspace $SOURCEPATH/项目.xcworkspace \\</div><div class=\"line\">-scheme $SCHEMENAME \\</div><div class=\"line\">-configuration Release \\</div><div class=\"line\">clean \\</div><div class=\"line\">build \\</div><div class=\"line\">-derivedDataPath $IPAPATH</div><div class=\"line\"></div><div class=\"line\">if [ -e $IPAPATH ]; then</div><div class=\"line\">\techo &quot;xcodebuild Successful&quot;</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error:Build Failed!&quot;</div><div class=\"line\">\texit 1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\"># xcrun .ipa</div><div class=\"line\">xcrun -sdk iphoneos PackageApplication \\</div><div class=\"line\">-v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\</div><div class=\"line\">-o $IPAPATH/$IPANAME</div><div class=\"line\"></div><div class=\"line\">if [ -e $IPAPATH ]; then</div><div class=\"line\">   echo &quot;Create IPA Success!&quot;</div><div class=\"line\">    open $IPAPATH</div><div class=\"line\">\t# upload ipa</div><div class=\"line\">   echo &quot;Uploading the ipa file...&quot;</div><div class=\"line\">   echo $IPAPATH</div><div class=\"line\">      response=`curl -F &quot;file=@$IPAPATH/$IPANAME&quot; -F &quot;uKey=$PGY_UKEY&quot; -F &quot;_api_key=$PGY_API_KEY&quot; $PGY_UPLOAD_URL`</div><div class=\"line\">   echo $response</div><div class=\"line\"></div><div class=\"line\">   # send email</div><div class=\"line\">   echo &quot;蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****&quot; | mail -s &quot;ipa更新&quot; ****@163.com,****@163.com,****@163.com,****@163.com</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error: Create IPA failed!&quot;</div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>写好已经脚本后，将它拷贝到<code>/usr/local/bin</code>目录下，添加权限：<code>chmod 777 xbuild</code></p>\n<p>执行完以上操作后，就可以在项目目录下直接执行xbuild打包</p>\n<p>通过实践发现方案二可以正常使用，方案一打出来的企业版ipa不能正常安装，应该是证书配置问题，还需要调研。</p>\n<h5 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h5><p><a href=\"http://www.jianshu.com/p/97c97c2ec1ca\" target=\"_blank\" rel=\"external\">从零开始写个自动打包IPA脚本</a></p>\n<p><a href=\"http://www.jianshu.com/p/3f43370437d2\" target=\"_blank\" rel=\"external\">iOS 自动构建命令——xcodebuild</a></p>\n<p><a href=\"http://ios.jobbole.com/90259/\" target=\"_blank\" rel=\"external\">关于 iOS 批量打包的总结</a></p>\n<p><a href=\"http://stackoverflow.com/questions/1822425/sending-mail-from-a-bash-shell-script?rq=1\" target=\"_blank\" rel=\"external\">脚本发送邮件的实现方法</a></p>\n","excerpt":"","more":"<h3 id=\"自动化打包IPA原理\"><a href=\"#自动化打包IPA原理\" class=\"headerlink\" title=\"自动化打包IPA原理\"></a>自动化打包IPA原理</h3><p>当我们用Xcode编译项目时，其实是Xcode执行了<code>xcodebuild</code>这条命令。</p>\n<p>当我们用Xcode打包项目时，其实是Xcode执行了<code>xcrun</code>这条命令。</p>\n<h5 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h5><ol>\n<li><p>xcodebuild -list</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -list [[-project ]|[-workspace ]] [-json]</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcodebuild -project</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild [-project] [[-target]...|-alltargets] [-configuration] [-arch]... [-sdk [|]] [-showBuildSettings] [=]... []...</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcodebuild -workspace</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -workspace -scheme [-destination]...[-configuration] [-arch]...[-sdk [|]] [-showBuildSettings] [=]</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcodebuild -exportArchive</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild archive -workspace xxx.xcworkspace -scheme xx -archivePath xxx.xcarchive</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa</div></pre></td></tr></table></figure>\n</li>\n<li><p>xcrun</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos PackageApplication build/Release -iphoneos/xx.app -o ~/Desktop/xx.ipa</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>根据上述命令我们有两种方法来生成我们需要的ipa包。</p>\n<ol>\n<li><p>使用<code>xcodebuild</code>命令来编译我们的项目生成app，然后再用<code>xcrun</code>将app转成ipa</p>\n</li>\n<li><p>使用<code>xcodebuild archive</code>命令来直接生成我们需要的ipa</p>\n<p>由于在 macos10.12和xcode8的环境下，使用<code>xcrun</code>方法会出现一个警告</p>\n<p><code>warning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.</code></p>\n<p>说明<code>PackageApplication</code>已经被弃用了，所以建议选择第二种方法来打包。</p>\n</li>\n</ol>\n<h5 id=\"项目实践\"><a href=\"#项目实践\" class=\"headerlink\" title=\"项目实践\"></a>项目实践</h5><h6 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">SCHEMENAME=项目的Scheme Name</div><div class=\"line\"></div><div class=\"line\">DATE=`date +%Y%m%d_%H%M`</div><div class=\"line\">SOURCEPATH=$( cd &quot;$( dirname %0)&quot; &amp;&amp; pwd)</div><div class=\"line\">IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE</div><div class=\"line\">ARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive</div><div class=\"line\">IPANAME=项目名称_$DATE.ipa</div><div class=\"line\"></div><div class=\"line\">PYG_DOMAIN=&quot;http://www.pgyer.com&quot;</div><div class=\"line\">PGY_UPLOAD_URL=&quot;$PYG_DOMAIN/apiv1/app/upload&quot;</div><div class=\"line\">PGY_UKEY=&quot;你的蒲公英账号的ukey&quot;</div><div class=\"line\">PGY_API_KEY=&quot;你的蒲公英账号的api key&quot;</div><div class=\"line\"></div><div class=\"line\"># build </div><div class=\"line\">xcodebuild archive -workspace $SOURCEPATH/项目名称.xcworkspace \\</div><div class=\"line\">-scheme $SCHEMENAME \\</div><div class=\"line\">-configuration Release \\</div><div class=\"line\">-archivePath $ARCHIVEPATH</div><div class=\"line\"></div><div class=\"line\">if [ -e $ARCHIVEPATH ]; then</div><div class=\"line\">\techo &quot;xcodebuild Successful&quot;</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error:Build Failed!&quot;</div><div class=\"line\">\texit 1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\"># exportArchive ipa</div><div class=\"line\">xcodebuild -exportArchive -archivePath $ARCHIVEPATH \\</div><div class=\"line\">-exportPath $IPAPATH -exportFormat ipa </div><div class=\"line\"></div><div class=\"line\"># xcrun .ipa</div><div class=\"line\"># xcrun -sdk iphoneos PackageApplication \\</div><div class=\"line\">#       -v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\</div><div class=\"line\">#       -o $IPAPATH/$IPANAME</div><div class=\"line\"></div><div class=\"line\">if [ -e $IPAPATH ]; then</div><div class=\"line\">\techo &quot;Create IPA Success!&quot;</div><div class=\"line\">\topen $IPAPATH</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error: Create IPA failed!&quot;</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\"># upload ipa  上传ipa到蒲公英发布平台</div><div class=\"line\">echo &quot;Uploading the ipa file...&quot;</div><div class=\"line\">echo $IPAPATH</div><div class=\"line\">response=`curl -F &quot;file=@$IPAPATH&quot; -F &quot;uKey=$PGY_UKEY&quot; -F &quot;_api_key=$PGY_API_KEY&quot; $PGY_UPLOAD_URL`</div><div class=\"line\">echo $response</div><div class=\"line\"></div><div class=\"line\"># send email 邮件通知同事让他们之间去下载</div><div class=\"line\">echo &quot;蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****&quot; | mail -s &quot;ipa更新&quot; ****@163.com,****@163.com,****@163.com,****@163.com</div></pre></td></tr></table></figure>\n<h6 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">SCHEMENAME=项目的Scheme Name</div><div class=\"line\"></div><div class=\"line\">DATE=`date +%Y%m%d_%H%M`</div><div class=\"line\">SOURCEPATH=$( cd &quot;$( dirname %0)&quot; &amp;&amp; pwd)</div><div class=\"line\"># IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/CinemaForiPhoneEnterprise_$DATE.ipa</div><div class=\"line\">IPAPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE</div><div class=\"line\">ARCHIVEPATH=$SOURCEPATH/AUTOBUILDIPA/$DATE/项目名称_$DATE.xcarchive</div><div class=\"line\">IPANAME=项目名称_$DATE.ipa</div><div class=\"line\"></div><div class=\"line\">PYG_DOMAIN=&quot;http://www.pgyer.com&quot;</div><div class=\"line\">PGY_UPLOAD_URL=&quot;$PYG_DOMAIN/apiv1/app/upload&quot;</div><div class=\"line\">PGY_UKEY=&quot;你的蒲公英账号的ukey&quot;</div><div class=\"line\">PGY_API_KEY=&quot;你的蒲公英账号的api key&quot;</div><div class=\"line\"></div><div class=\"line\"># build </div><div class=\"line\">xcodebuild -workspace $SOURCEPATH/项目.xcworkspace \\</div><div class=\"line\">-scheme $SCHEMENAME \\</div><div class=\"line\">-configuration Release \\</div><div class=\"line\">clean \\</div><div class=\"line\">build \\</div><div class=\"line\">-derivedDataPath $IPAPATH</div><div class=\"line\"></div><div class=\"line\">if [ -e $IPAPATH ]; then</div><div class=\"line\">\techo &quot;xcodebuild Successful&quot;</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error:Build Failed!&quot;</div><div class=\"line\">\texit 1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\"># xcrun .ipa</div><div class=\"line\">xcrun -sdk iphoneos PackageApplication \\</div><div class=\"line\">-v $IPAPATH/Build/Products/Release-iphoneos/$SCHEMENAME.app \\</div><div class=\"line\">-o $IPAPATH/$IPANAME</div><div class=\"line\"></div><div class=\"line\">if [ -e $IPAPATH ]; then</div><div class=\"line\">   echo &quot;Create IPA Success!&quot;</div><div class=\"line\">    open $IPAPATH</div><div class=\"line\">\t# upload ipa</div><div class=\"line\">   echo &quot;Uploading the ipa file...&quot;</div><div class=\"line\">   echo $IPAPATH</div><div class=\"line\">      response=`curl -F &quot;file=@$IPAPATH/$IPANAME&quot; -F &quot;uKey=$PGY_UKEY&quot; -F &quot;_api_key=$PGY_API_KEY&quot; $PGY_UPLOAD_URL`</div><div class=\"line\">   echo $response</div><div class=\"line\"></div><div class=\"line\">   # send email</div><div class=\"line\">   echo &quot;蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/****&quot; | mail -s &quot;ipa更新&quot; ****@163.com,****@163.com,****@163.com,****@163.com</div><div class=\"line\">else </div><div class=\"line\">\techo &quot;error: Create IPA failed!&quot;</div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>写好已经脚本后，将它拷贝到<code>/usr/local/bin</code>目录下，添加权限：<code>chmod 777 xbuild</code></p>\n<p>执行完以上操作后，就可以在项目目录下直接执行xbuild打包</p>\n<p>通过实践发现方案二可以正常使用，方案一打出来的企业版ipa不能正常安装，应该是证书配置问题，还需要调研。</p>\n<h5 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h5><p><a href=\"http://www.jianshu.com/p/97c97c2ec1ca\">从零开始写个自动打包IPA脚本</a></p>\n<p><a href=\"http://www.jianshu.com/p/3f43370437d2\">iOS 自动构建命令——xcodebuild</a></p>\n<p><a href=\"http://ios.jobbole.com/90259/\">关于 iOS 批量打包的总结</a></p>\n<p><a href=\"http://stackoverflow.com/questions/1822425/sending-mail-from-a-bash-shell-script?rq=1\">脚本发送邮件的实现方法</a></p>\n"},{"title":"轻松搞定状态栏颜色变化","date":"2018-01-30T08:08:00.000Z","_content":"\niOS系统的状态栏颜色通常有白色和黑色两种，对应的就是`UIStatusBarStyleLightContent`和`UIStatusBarStyleDefault`两种样式，改变状态栏的颜色就是通过设置不同的样式来实现的。\n\niOS为我们提供了两种设置状态栏的方式：统一设置app所有控制器的状态栏颜色和单独设置某个控制器的状态栏颜色\n\n## 统一设置app所有控制器的状态栏颜色\n\n首先，我们需要了解一下`info.plist`里的`View Controller-based status bar appearance`属性，如果将该属性设为YES，则控制器对状态栏的设置优先级最高，可以在控制器中对颜色进行单独修改，如果将该属性设为NO，则以启动图设置为准，即app内部所有控制器view上的状态栏都与启动图上的保持一致，当然我们还可以通过`UIApplication`来进行管理。\n\n```\n[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];\n```\n\n## 单独设置某个控制器的状态栏颜色\n\n单独设置某个控制器的状态栏颜色首先需要将`View Controller-based status bar appearance`属性设为YES，然后在对应的控制器中加入如下代码：\n```\n- (UIStatusBarStyle)preferredStatusBarStyle {\n    return UIStatusBarStyleLightContent;\n}\n```\n\n这里需要注意一点就是如果控制器在navigationController或tabBar中，通过自定义navigationController或tabBar重写如下方法：\n```\n- (UIViewController *)childViewControllerForStatusBarStyle {\n    return self.topViewController;\n}\n```\n\n## 如果随时更改状态栏颜色\n\n有些特殊情况下，我们需要随时改变当前页面的状态栏颜色，这时就需要通过调用`setNeedsStatusBarAppearanceUpdate`方法，这个方法会通知系统去调用当前控制器的`preferredStatusBarStyle`方法，然后根据设置的方法来设置颜色。\n\n","source":"_posts/轻松搞定状态栏颜色变化.md","raw":"title: 轻松搞定状态栏颜色变化\ntags:\n  - iOS基础\n  - ''\ncategories:\n  - iOS\ndate: 2018-01-30 16:08:00\n---\n\niOS系统的状态栏颜色通常有白色和黑色两种，对应的就是`UIStatusBarStyleLightContent`和`UIStatusBarStyleDefault`两种样式，改变状态栏的颜色就是通过设置不同的样式来实现的。\n\niOS为我们提供了两种设置状态栏的方式：统一设置app所有控制器的状态栏颜色和单独设置某个控制器的状态栏颜色\n\n## 统一设置app所有控制器的状态栏颜色\n\n首先，我们需要了解一下`info.plist`里的`View Controller-based status bar appearance`属性，如果将该属性设为YES，则控制器对状态栏的设置优先级最高，可以在控制器中对颜色进行单独修改，如果将该属性设为NO，则以启动图设置为准，即app内部所有控制器view上的状态栏都与启动图上的保持一致，当然我们还可以通过`UIApplication`来进行管理。\n\n```\n[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];\n```\n\n## 单独设置某个控制器的状态栏颜色\n\n单独设置某个控制器的状态栏颜色首先需要将`View Controller-based status bar appearance`属性设为YES，然后在对应的控制器中加入如下代码：\n```\n- (UIStatusBarStyle)preferredStatusBarStyle {\n    return UIStatusBarStyleLightContent;\n}\n```\n\n这里需要注意一点就是如果控制器在navigationController或tabBar中，通过自定义navigationController或tabBar重写如下方法：\n```\n- (UIViewController *)childViewControllerForStatusBarStyle {\n    return self.topViewController;\n}\n```\n\n## 如果随时更改状态栏颜色\n\n有些特殊情况下，我们需要随时改变当前页面的状态栏颜色，这时就需要通过调用`setNeedsStatusBarAppearanceUpdate`方法，这个方法会通知系统去调用当前控制器的`preferredStatusBarStyle`方法，然后根据设置的方法来设置颜色。\n\n","slug":"轻松搞定状态栏颜色变化","published":1,"updated":"2018-08-31T09:41:18.198Z","_id":"cjlhoqwj8003bkj79xilmy7wh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>iOS系统的状态栏颜色通常有白色和黑色两种，对应的就是<code>UIStatusBarStyleLightContent</code>和<code>UIStatusBarStyleDefault</code>两种样式，改变状态栏的颜色就是通过设置不同的样式来实现的。</p>\n<p>iOS为我们提供了两种设置状态栏的方式：统一设置app所有控制器的状态栏颜色和单独设置某个控制器的状态栏颜色</p>\n<h2 id=\"统一设置app所有控制器的状态栏颜色\"><a href=\"#统一设置app所有控制器的状态栏颜色\" class=\"headerlink\" title=\"统一设置app所有控制器的状态栏颜色\"></a>统一设置app所有控制器的状态栏颜色</h2><p>首先，我们需要了解一下<code>info.plist</code>里的<code>View Controller-based status bar appearance</code>属性，如果将该属性设为YES，则控制器对状态栏的设置优先级最高，可以在控制器中对颜色进行单独修改，如果将该属性设为NO，则以启动图设置为准，即app内部所有控制器view上的状态栏都与启动图上的保持一致，当然我们还可以通过<code>UIApplication</code>来进行管理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];</div></pre></td></tr></table></figure>\n<h2 id=\"单独设置某个控制器的状态栏颜色\"><a href=\"#单独设置某个控制器的状态栏颜色\" class=\"headerlink\" title=\"单独设置某个控制器的状态栏颜色\"></a>单独设置某个控制器的状态栏颜色</h2><p>单独设置某个控制器的状态栏颜色首先需要将<code>View Controller-based status bar appearance</code>属性设为YES，然后在对应的控制器中加入如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</div><div class=\"line\">    return UIStatusBarStyleLightContent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里需要注意一点就是如果控制器在navigationController或tabBar中，通过自定义navigationController或tabBar重写如下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle &#123;</div><div class=\"line\">    return self.topViewController;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"如果随时更改状态栏颜色\"><a href=\"#如果随时更改状态栏颜色\" class=\"headerlink\" title=\"如果随时更改状态栏颜色\"></a>如果随时更改状态栏颜色</h2><p>有些特殊情况下，我们需要随时改变当前页面的状态栏颜色，这时就需要通过调用<code>setNeedsStatusBarAppearanceUpdate</code>方法，这个方法会通知系统去调用当前控制器的<code>preferredStatusBarStyle</code>方法，然后根据设置的方法来设置颜色。</p>\n","excerpt":"","more":"<p>iOS系统的状态栏颜色通常有白色和黑色两种，对应的就是<code>UIStatusBarStyleLightContent</code>和<code>UIStatusBarStyleDefault</code>两种样式，改变状态栏的颜色就是通过设置不同的样式来实现的。</p>\n<p>iOS为我们提供了两种设置状态栏的方式：统一设置app所有控制器的状态栏颜色和单独设置某个控制器的状态栏颜色</p>\n<h2 id=\"统一设置app所有控制器的状态栏颜色\"><a href=\"#统一设置app所有控制器的状态栏颜色\" class=\"headerlink\" title=\"统一设置app所有控制器的状态栏颜色\"></a>统一设置app所有控制器的状态栏颜色</h2><p>首先，我们需要了解一下<code>info.plist</code>里的<code>View Controller-based status bar appearance</code>属性，如果将该属性设为YES，则控制器对状态栏的设置优先级最高，可以在控制器中对颜色进行单独修改，如果将该属性设为NO，则以启动图设置为准，即app内部所有控制器view上的状态栏都与启动图上的保持一致，当然我们还可以通过<code>UIApplication</code>来进行管理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];</div></pre></td></tr></table></figure>\n<h2 id=\"单独设置某个控制器的状态栏颜色\"><a href=\"#单独设置某个控制器的状态栏颜色\" class=\"headerlink\" title=\"单独设置某个控制器的状态栏颜色\"></a>单独设置某个控制器的状态栏颜色</h2><p>单独设置某个控制器的状态栏颜色首先需要将<code>View Controller-based status bar appearance</code>属性设为YES，然后在对应的控制器中加入如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</div><div class=\"line\">    return UIStatusBarStyleLightContent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里需要注意一点就是如果控制器在navigationController或tabBar中，通过自定义navigationController或tabBar重写如下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle &#123;</div><div class=\"line\">    return self.topViewController;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"如果随时更改状态栏颜色\"><a href=\"#如果随时更改状态栏颜色\" class=\"headerlink\" title=\"如果随时更改状态栏颜色\"></a>如果随时更改状态栏颜色</h2><p>有些特殊情况下，我们需要随时改变当前页面的状态栏颜色，这时就需要通过调用<code>setNeedsStatusBarAppearanceUpdate</code>方法，这个方法会通知系统去调用当前控制器的<code>preferredStatusBarStyle</code>方法，然后根据设置的方法来设置颜色。</p>\n"},{"title":"自定义xopen命令打开工程","date":"2016-10-08T08:15:00.000Z","_content":"\n通常我们在终端中对代码进行版本控制或者使用CocoaPods命令安装完依赖库后，都需要手动去打开工程。对于追求快捷和逼格的我们来说怎样才能进一步提升我们的逼格呢？\n\n今天就跟大家分享一个通过ruby脚本来帮助我们在终端中直接打开工程的方法。\n\n如果大家足够细心的话应该能注意到CocoaPods管理的项目后缀是`projectname.xcworkspace`而普通工程的后缀是`projectname.xcodeproj`,下面我们就通过ruby脚本来判断后缀，帮助我们优先打开`projectname.xcworkspace`。\n\n       #!/usr/bin/env ruby\n \n       require 'shellwords'\n \n       proj = Dir['*.xcworkspace'].first\n       proj = Dir['*.xcodeproj'].first unless proj\n \n       if proj\n         puts \"Opening #{proj}\"\n         `open #{proj}`\n       else\n         puts \"No xcworkspace|xcproj file found\"\n       end\n       \n将以上内容命名为`xopen`保存，并将文件拷贝到`/usr/local/bin`目录下，添加权限：`chmod 777 xopen`\n\n执行完以上操作后你就可以方便的使用`xopen`命令来打开工程啦。","source":"_posts/自定义xopen命令打开工程.md","raw":"title: 自定义xopen命令打开工程\ntags:\n  - iOS技巧\n  - ''\ncategories:\n  - iOS\ndate: 2016-10-08 16:15:00\n---\n\n通常我们在终端中对代码进行版本控制或者使用CocoaPods命令安装完依赖库后，都需要手动去打开工程。对于追求快捷和逼格的我们来说怎样才能进一步提升我们的逼格呢？\n\n今天就跟大家分享一个通过ruby脚本来帮助我们在终端中直接打开工程的方法。\n\n如果大家足够细心的话应该能注意到CocoaPods管理的项目后缀是`projectname.xcworkspace`而普通工程的后缀是`projectname.xcodeproj`,下面我们就通过ruby脚本来判断后缀，帮助我们优先打开`projectname.xcworkspace`。\n\n       #!/usr/bin/env ruby\n \n       require 'shellwords'\n \n       proj = Dir['*.xcworkspace'].first\n       proj = Dir['*.xcodeproj'].first unless proj\n \n       if proj\n         puts \"Opening #{proj}\"\n         `open #{proj}`\n       else\n         puts \"No xcworkspace|xcproj file found\"\n       end\n       \n将以上内容命名为`xopen`保存，并将文件拷贝到`/usr/local/bin`目录下，添加权限：`chmod 777 xopen`\n\n执行完以上操作后你就可以方便的使用`xopen`命令来打开工程啦。","slug":"自定义xopen命令打开工程","published":1,"updated":"2018-08-31T09:54:16.813Z","_id":"cjlhoqwj9003ekj7974i1k1jz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>通常我们在终端中对代码进行版本控制或者使用CocoaPods命令安装完依赖库后，都需要手动去打开工程。对于追求快捷和逼格的我们来说怎样才能进一步提升我们的逼格呢？</p>\n<p>今天就跟大家分享一个通过ruby脚本来帮助我们在终端中直接打开工程的方法。</p>\n<p>如果大家足够细心的话应该能注意到CocoaPods管理的项目后缀是<code>projectname.xcworkspace</code>而普通工程的后缀是<code>projectname.xcodeproj</code>,下面我们就通过ruby脚本来判断后缀，帮助我们优先打开<code>projectname.xcworkspace</code>。</p>\n<pre><code>#!/usr/bin/env ruby\n\nrequire &apos;shellwords&apos;\n\nproj = Dir[&apos;*.xcworkspace&apos;].first\nproj = Dir[&apos;*.xcodeproj&apos;].first unless proj\n\nif proj\n  puts &quot;Opening #{proj}&quot;\n  `open #{proj}`\nelse\n  puts &quot;No xcworkspace|xcproj file found&quot;\nend\n</code></pre><p>将以上内容命名为<code>xopen</code>保存，并将文件拷贝到<code>/usr/local/bin</code>目录下，添加权限：<code>chmod 777 xopen</code></p>\n<p>执行完以上操作后你就可以方便的使用<code>xopen</code>命令来打开工程啦。</p>\n","excerpt":"","more":"<p>通常我们在终端中对代码进行版本控制或者使用CocoaPods命令安装完依赖库后，都需要手动去打开工程。对于追求快捷和逼格的我们来说怎样才能进一步提升我们的逼格呢？</p>\n<p>今天就跟大家分享一个通过ruby脚本来帮助我们在终端中直接打开工程的方法。</p>\n<p>如果大家足够细心的话应该能注意到CocoaPods管理的项目后缀是<code>projectname.xcworkspace</code>而普通工程的后缀是<code>projectname.xcodeproj</code>,下面我们就通过ruby脚本来判断后缀，帮助我们优先打开<code>projectname.xcworkspace</code>。</p>\n<pre><code>#!/usr/bin/env ruby\n\nrequire &apos;shellwords&apos;\n\nproj = Dir[&apos;*.xcworkspace&apos;].first\nproj = Dir[&apos;*.xcodeproj&apos;].first unless proj\n\nif proj\n  puts &quot;Opening #{proj}&quot;\n  `open #{proj}`\nelse\n  puts &quot;No xcworkspace|xcproj file found&quot;\nend\n</code></pre><p>将以上内容命名为<code>xopen</code>保存，并将文件拷贝到<code>/usr/local/bin</code>目录下，添加权限：<code>chmod 777 xopen</code></p>\n<p>执行完以上操作后你就可以方便的使用<code>xopen</code>命令来打开工程啦。</p>\n"},{"title":"自定义快捷代码片段","date":"2017-12-14T11:07:00.000Z","_content":"Xcode为我们提供了一种可以快速输入一段代码的快捷方式，这里对如何通过自定义快捷代码片段来提升开发效率进行一个总结\n\n## 如何创建自定义代码片段\n\n在Xcode的右下角有一个代码片段区域，如图所示：\n![QQ20171102-163351.png](http://upload-images.jianshu.io/upload_images/1479547-77d2438767fb5b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里面已经有了很多代码片段，这些代码片段是Xcode为我们提前准备的。\n我们先来看一看里面的结构，点开第一个代码片段`C Block typedef - Define a block as a type`，这个代码片段是我们通常用来给一个block声明一个别名的\n![QQ20171102-163706.png](http://upload-images.jianshu.io/upload_images/1479547-a8ef0cc59ef647fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如图所示的代码片段有很多很多，感兴趣的可以自己去看一看，接下来就是本文的重点，如何创建属于我们的代码片段呢？\n\n- 在编辑区写上你要添加的片段代码\n- 将代码选中拖拽到Code Snippets区域\n![QQ20171102-165121.png](http://upload-images.jianshu.io/upload_images/1479547-d2155adf5857e5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 在弹框里对代码片段进行编辑，将想要方便更换的内容以`<# #>`包裹，对应的内容就是可变内容啦\n![QQ20171102-170317.png](http://upload-images.jianshu.io/upload_images/1479547-0896076c1ab410bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 在`Completion Shortcut`一栏中可以填入快捷标记\n- 完成以上步骤后，我们在需要使用相关代码片段时只需要输入快捷标记就能选中啦\n![QQ20171102-170644.png](http://upload-images.jianshu.io/upload_images/1479547-9a97bed7868a1254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 常用代码片段\n\n腾讯QMUI Team开源了一个他们经常使用的代码片段，非常好用，大家可以直接去下载，存放在`~/Library/Developer/Xcode/UserData/CodeSnippets`目录下\n\n[qmui-ios-codesnippets](https://github.com/QMUI/QMUI_iOS_CodeSnippets)\n\n#### 快捷键汇总\n\n*NSObject*\n- `pa` - 定义一个 `assign` 的 property\n- `pc` - 定义一个 `copy` 的 property\n- `ps` - 定义一个 `strong` 的property\n- `psr` - 定义一个 `strong, readonly` 的property\n- `pw` - 定义一个 `weak` 的property\n- `propertySwizzleAssign` - 用 `swizzle` 的方式定义一个 `assign` 的property\n- `propertySwizzleCopy` - 用 `swizzle` 的方式定义一个 `copy` 的property\n- `propertySwizzleStrong` - 用 `swizzle` 的方式定义一个 `strong` 的property\n- `propertySwizzleWeak` - 用 `swizzle` 的方式定义一个 `weak` 的property\n- `sharedInstance` - 为当前类创建一个实现单例功能的 `sharedInstance` 方法\n- `replaceMethod` - 重写当前类的 `load` 方法并在其中用 `swizzle` 替换方法实现\n- `replaceMethod_QMUI` - QMUI 重写当前类的 `load` 方法并用 `ReplaceMethod()` 函数替换方法的实现\n\n\n*Block*\n- `blockArguments` - 声明一个用于方法参数的 block\n- `blockproperty` - 声明一个用于 property 的 block\n- `blocktypedef` - 用 `typedef` 定义一个 block\n- `blockvar` - 定义一个作为局部变量的 block\n\n\n*Method & Function*\n- `fnv` - 定义一个返回值为 `void` 的方法\n- `fnv:` - 定义一个返回值为 `void` 且带参数的方法\n- `fnblock` - 定义一个返回值类型为 block 的方法\n- `fnv_handleEvent` - 定义一个用于 `UIControl` 事件回调的方法\n- `fnv_longPress` - 定义一个用于 `UILongPressGestureRecognizer` 的回调方法（你就不用每次都去拼写那个很长的手势名字了）\n- `fnv_pan` - 定义一个用于 `UIPanGestureRecognizer` 的回调方法\n- `fnv_tap` - 定义一个用于 `UITapGestureRecognizer` 的回调方法\n\n\n*UIView*\n- `setFrame` - 为 `UIView` 设置 `frame`\n- `setFrame_QMUI` - QMUI 使用像素对齐的 `CGRectFlatMake()` 为 `UIView` 设置 `frame`\n- `setFrameX` - QMUI 使用 `CGRectSetX()` 修改 `UIView` 的 `frame.origin.x`\n- `setFrameY` - QMUI 使用 `CGRectSetY()` 修改 `UIView` 的 `frame.origin.y`\n- `setFrameXY` - QMUI 使用 `CGRectSetXY()` 修改 `UIView` 的 `frame.origin`\n- `sizeThatFits` - 为当前 view 创建 `sizeThatFits:` 方法\n- `layoutSubviews` - 展开 `layoutSubviews` 方法\n- `updateConstraints` - 展开 `updateConstraints` 方法\n- `getWidth` - 展开 `CGRectGetWidth()`\n- `getHeight` - 展开 `CGRectGetHeight()`\n- `getMinX` - 展开 `CGRectGetMinX()`\n- `getMinY` - 展开 `CGRectGetMinY()`\n- `addtarget` - 调用 `UIControl addTarget:action:forEvents:` 方法\n- `setImageForButton` - 为 `UIButton` 设置图片\n- `setTitleColorForButton` - 为 `UIButton` 设置文字颜色\n- `setTitleForButton` - 为 `UIButton` 设置文字\n\n*UITableView*\n- `initWithStyle` - 展开 `initWithStyle:` 方法\n- `initWithStyleForCell` - 展开 `UITableViewCell initWithStyle:reuseIdentifier:` 方法\n- `tableViewDelegate` - 展开常用的几个 `UITableViewDelegate` 方法\n- `numberOfSectionsInTableView` - 展开 `numberOfSectionsInTableView:`方法\n- `numberOfRowsInSection` - 展开 `tableView:numberOfRowsInSection:` 方法\n- `cellForRowAtIndexPath` - 展开 `tableView:cellForRowAtIndexPath:` 方法\n- `heightForRowAtIndexPath` - 展开 `tableView:heightForRowAtIndexPath:` 方法\n- `didSelectRowAtIndexPath` - 展开 `tableView:didSelectRowAtIndexPath:` 方法\n\n\n*UICollectionView*\n- `collectionViewDelegate` - 展开常用的几个`UICollectionViewDelegate` 方法\n- `numberOfSectionsInCollectionView` - 展开 `numberOfSectionsInCollectionView:`\n- `numberOfItemsInSection` - 展开 `collectionView:numberOfItemsInSection:`\n- `cellForItemAtIndexPath` - 展开 `collectionView:cellForItemAtIndexPath:`\n- `sizeForItemAtIndexPath` - 展开 `collectionView:layout:sizeForItemAtIndexPath:` 方法\n- `didSelectItemAtIndexPath` - 展开 `collectionView:didSelectItemAtIndexPath:` 方法\n- `didDeselectItemAtIndexPath` - 展开 `collectionView:didDeselectItemAtIndexPath:` 方法\n\n\n*UIViewController*\n- `loadView` - 展开 `loadView` 方法\n- `viewDidLoad` - 展开 `viewDidLoad` 方法\n- `viewWillAppear` - 展开 `viewWillAppear:` 方法\n- `viewDidAppear` - 展开 `viewDidAppear:` 方法\n- `viewWillDisappear` - 展开 `viewWillDisappear:` 方法\n- `viewDidDisappear` - 展开 `viewDidDisappear:` 方法\n- `viewDidLayoutSubviews` - 展开 `viewDidLayoutSubviews:` 方法\n- `updateViewConstraints` - 展开 `updateViewConstraints:` 方法\n- `addChildViewController` - 在当前 `UIViewController` 里添加 `childViewController`\n- `removeFromParentViewController` - 将 `childViewController` 从当前的 `UIViewController` 里移除\n- `initSubviews` - QMUI 展开 `initSubviews` 方法\n- `setNavigationItems` - QMUI 重写 `QMUICommonViewController` 里的 `setNavigationItemsIsInEditMode:animated:` 方法\n- `setToolbarItems` - QMUI 重写 `QMUICommonViewController` 里的 `setToolbarItemsIsInEditMode:animated:` 方法\n- `leftBarButtonItemImage` - QMUI 用 `QMUINavigationButton` 的方法创建一个用于 `navigationItem.leftBarButtonItem` 的 `UIBarButtonItem`\n- `rightBarButtonItemImage` - QMUI 用 `QMUINavigationButton` 的方法创建一个用于 `navigationItem.rightBarButtonItem` 的 `UIBarButtonItem`\n\n\n*Other*\n- `pragma` - 展开一个用于 Xcode 导航的 `#pragma mark -` 宏\n- `externRefInH` - 在 `*.h` 文件里声明一个 `extern const` 的指针\n- `externRefInM` - 在 `*.m` 文件里为一个 `extern const` 的指针赋值\n- `externValueInH` - 在 `*.h` 文件里声明一个 `extern const` 的值变量\n- `externValueInM` - 在 `*.m` 文件里为一个 `extern const` 的变量赋值\n- `static reference` - 定义一个 `static` 的指针\n- `static` - 定义一个 `static` 的值变量\n- `__weakSelf` - 定义一个 `weak` 的 `self` 指针\n- `__strongSelf` - 将 `weakSelf` 指针改为 `strong` 的 `self` 指针\n- `logCallStackSymbols` - 用 `NSLog` 打出当前的方法调用栈信息\n- `timeConsuming` - 展开一段用 `CACurrentMediaTime()` 来计算方法耗时的代码\n\n\n","source":"_posts/自定义快捷代码片段.md","raw":"title: 自定义快捷代码片段\ntags:\n  - iOS技巧\n  - ''\ncategories:\n  - iOS\ndate: 2017-12-14 19:07:00\n---\nXcode为我们提供了一种可以快速输入一段代码的快捷方式，这里对如何通过自定义快捷代码片段来提升开发效率进行一个总结\n\n## 如何创建自定义代码片段\n\n在Xcode的右下角有一个代码片段区域，如图所示：\n![QQ20171102-163351.png](http://upload-images.jianshu.io/upload_images/1479547-77d2438767fb5b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里面已经有了很多代码片段，这些代码片段是Xcode为我们提前准备的。\n我们先来看一看里面的结构，点开第一个代码片段`C Block typedef - Define a block as a type`，这个代码片段是我们通常用来给一个block声明一个别名的\n![QQ20171102-163706.png](http://upload-images.jianshu.io/upload_images/1479547-a8ef0cc59ef647fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如图所示的代码片段有很多很多，感兴趣的可以自己去看一看，接下来就是本文的重点，如何创建属于我们的代码片段呢？\n\n- 在编辑区写上你要添加的片段代码\n- 将代码选中拖拽到Code Snippets区域\n![QQ20171102-165121.png](http://upload-images.jianshu.io/upload_images/1479547-d2155adf5857e5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 在弹框里对代码片段进行编辑，将想要方便更换的内容以`<# #>`包裹，对应的内容就是可变内容啦\n![QQ20171102-170317.png](http://upload-images.jianshu.io/upload_images/1479547-0896076c1ab410bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 在`Completion Shortcut`一栏中可以填入快捷标记\n- 完成以上步骤后，我们在需要使用相关代码片段时只需要输入快捷标记就能选中啦\n![QQ20171102-170644.png](http://upload-images.jianshu.io/upload_images/1479547-9a97bed7868a1254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 常用代码片段\n\n腾讯QMUI Team开源了一个他们经常使用的代码片段，非常好用，大家可以直接去下载，存放在`~/Library/Developer/Xcode/UserData/CodeSnippets`目录下\n\n[qmui-ios-codesnippets](https://github.com/QMUI/QMUI_iOS_CodeSnippets)\n\n#### 快捷键汇总\n\n*NSObject*\n- `pa` - 定义一个 `assign` 的 property\n- `pc` - 定义一个 `copy` 的 property\n- `ps` - 定义一个 `strong` 的property\n- `psr` - 定义一个 `strong, readonly` 的property\n- `pw` - 定义一个 `weak` 的property\n- `propertySwizzleAssign` - 用 `swizzle` 的方式定义一个 `assign` 的property\n- `propertySwizzleCopy` - 用 `swizzle` 的方式定义一个 `copy` 的property\n- `propertySwizzleStrong` - 用 `swizzle` 的方式定义一个 `strong` 的property\n- `propertySwizzleWeak` - 用 `swizzle` 的方式定义一个 `weak` 的property\n- `sharedInstance` - 为当前类创建一个实现单例功能的 `sharedInstance` 方法\n- `replaceMethod` - 重写当前类的 `load` 方法并在其中用 `swizzle` 替换方法实现\n- `replaceMethod_QMUI` - QMUI 重写当前类的 `load` 方法并用 `ReplaceMethod()` 函数替换方法的实现\n\n\n*Block*\n- `blockArguments` - 声明一个用于方法参数的 block\n- `blockproperty` - 声明一个用于 property 的 block\n- `blocktypedef` - 用 `typedef` 定义一个 block\n- `blockvar` - 定义一个作为局部变量的 block\n\n\n*Method & Function*\n- `fnv` - 定义一个返回值为 `void` 的方法\n- `fnv:` - 定义一个返回值为 `void` 且带参数的方法\n- `fnblock` - 定义一个返回值类型为 block 的方法\n- `fnv_handleEvent` - 定义一个用于 `UIControl` 事件回调的方法\n- `fnv_longPress` - 定义一个用于 `UILongPressGestureRecognizer` 的回调方法（你就不用每次都去拼写那个很长的手势名字了）\n- `fnv_pan` - 定义一个用于 `UIPanGestureRecognizer` 的回调方法\n- `fnv_tap` - 定义一个用于 `UITapGestureRecognizer` 的回调方法\n\n\n*UIView*\n- `setFrame` - 为 `UIView` 设置 `frame`\n- `setFrame_QMUI` - QMUI 使用像素对齐的 `CGRectFlatMake()` 为 `UIView` 设置 `frame`\n- `setFrameX` - QMUI 使用 `CGRectSetX()` 修改 `UIView` 的 `frame.origin.x`\n- `setFrameY` - QMUI 使用 `CGRectSetY()` 修改 `UIView` 的 `frame.origin.y`\n- `setFrameXY` - QMUI 使用 `CGRectSetXY()` 修改 `UIView` 的 `frame.origin`\n- `sizeThatFits` - 为当前 view 创建 `sizeThatFits:` 方法\n- `layoutSubviews` - 展开 `layoutSubviews` 方法\n- `updateConstraints` - 展开 `updateConstraints` 方法\n- `getWidth` - 展开 `CGRectGetWidth()`\n- `getHeight` - 展开 `CGRectGetHeight()`\n- `getMinX` - 展开 `CGRectGetMinX()`\n- `getMinY` - 展开 `CGRectGetMinY()`\n- `addtarget` - 调用 `UIControl addTarget:action:forEvents:` 方法\n- `setImageForButton` - 为 `UIButton` 设置图片\n- `setTitleColorForButton` - 为 `UIButton` 设置文字颜色\n- `setTitleForButton` - 为 `UIButton` 设置文字\n\n*UITableView*\n- `initWithStyle` - 展开 `initWithStyle:` 方法\n- `initWithStyleForCell` - 展开 `UITableViewCell initWithStyle:reuseIdentifier:` 方法\n- `tableViewDelegate` - 展开常用的几个 `UITableViewDelegate` 方法\n- `numberOfSectionsInTableView` - 展开 `numberOfSectionsInTableView:`方法\n- `numberOfRowsInSection` - 展开 `tableView:numberOfRowsInSection:` 方法\n- `cellForRowAtIndexPath` - 展开 `tableView:cellForRowAtIndexPath:` 方法\n- `heightForRowAtIndexPath` - 展开 `tableView:heightForRowAtIndexPath:` 方法\n- `didSelectRowAtIndexPath` - 展开 `tableView:didSelectRowAtIndexPath:` 方法\n\n\n*UICollectionView*\n- `collectionViewDelegate` - 展开常用的几个`UICollectionViewDelegate` 方法\n- `numberOfSectionsInCollectionView` - 展开 `numberOfSectionsInCollectionView:`\n- `numberOfItemsInSection` - 展开 `collectionView:numberOfItemsInSection:`\n- `cellForItemAtIndexPath` - 展开 `collectionView:cellForItemAtIndexPath:`\n- `sizeForItemAtIndexPath` - 展开 `collectionView:layout:sizeForItemAtIndexPath:` 方法\n- `didSelectItemAtIndexPath` - 展开 `collectionView:didSelectItemAtIndexPath:` 方法\n- `didDeselectItemAtIndexPath` - 展开 `collectionView:didDeselectItemAtIndexPath:` 方法\n\n\n*UIViewController*\n- `loadView` - 展开 `loadView` 方法\n- `viewDidLoad` - 展开 `viewDidLoad` 方法\n- `viewWillAppear` - 展开 `viewWillAppear:` 方法\n- `viewDidAppear` - 展开 `viewDidAppear:` 方法\n- `viewWillDisappear` - 展开 `viewWillDisappear:` 方法\n- `viewDidDisappear` - 展开 `viewDidDisappear:` 方法\n- `viewDidLayoutSubviews` - 展开 `viewDidLayoutSubviews:` 方法\n- `updateViewConstraints` - 展开 `updateViewConstraints:` 方法\n- `addChildViewController` - 在当前 `UIViewController` 里添加 `childViewController`\n- `removeFromParentViewController` - 将 `childViewController` 从当前的 `UIViewController` 里移除\n- `initSubviews` - QMUI 展开 `initSubviews` 方法\n- `setNavigationItems` - QMUI 重写 `QMUICommonViewController` 里的 `setNavigationItemsIsInEditMode:animated:` 方法\n- `setToolbarItems` - QMUI 重写 `QMUICommonViewController` 里的 `setToolbarItemsIsInEditMode:animated:` 方法\n- `leftBarButtonItemImage` - QMUI 用 `QMUINavigationButton` 的方法创建一个用于 `navigationItem.leftBarButtonItem` 的 `UIBarButtonItem`\n- `rightBarButtonItemImage` - QMUI 用 `QMUINavigationButton` 的方法创建一个用于 `navigationItem.rightBarButtonItem` 的 `UIBarButtonItem`\n\n\n*Other*\n- `pragma` - 展开一个用于 Xcode 导航的 `#pragma mark -` 宏\n- `externRefInH` - 在 `*.h` 文件里声明一个 `extern const` 的指针\n- `externRefInM` - 在 `*.m` 文件里为一个 `extern const` 的指针赋值\n- `externValueInH` - 在 `*.h` 文件里声明一个 `extern const` 的值变量\n- `externValueInM` - 在 `*.m` 文件里为一个 `extern const` 的变量赋值\n- `static reference` - 定义一个 `static` 的指针\n- `static` - 定义一个 `static` 的值变量\n- `__weakSelf` - 定义一个 `weak` 的 `self` 指针\n- `__strongSelf` - 将 `weakSelf` 指针改为 `strong` 的 `self` 指针\n- `logCallStackSymbols` - 用 `NSLog` 打出当前的方法调用栈信息\n- `timeConsuming` - 展开一段用 `CACurrentMediaTime()` 来计算方法耗时的代码\n\n\n","slug":"自定义快捷代码片段","published":1,"updated":"2018-08-31T09:42:24.961Z","_id":"cjlhoqwja003gkj79i7o40tz0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Xcode为我们提供了一种可以快速输入一段代码的快捷方式，这里对如何通过自定义快捷代码片段来提升开发效率进行一个总结</p>\n<h2 id=\"如何创建自定义代码片段\"><a href=\"#如何创建自定义代码片段\" class=\"headerlink\" title=\"如何创建自定义代码片段\"></a>如何创建自定义代码片段</h2><p>在Xcode的右下角有一个代码片段区域，如图所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-77d2438767fb5b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-163351.png\"><br>这里面已经有了很多代码片段，这些代码片段是Xcode为我们提前准备的。<br>我们先来看一看里面的结构，点开第一个代码片段<code>C Block typedef - Define a block as a type</code>，这个代码片段是我们通常用来给一个block声明一个别名的<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-a8ef0cc59ef647fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-163706.png\"></p>\n<p>如图所示的代码片段有很多很多，感兴趣的可以自己去看一看，接下来就是本文的重点，如何创建属于我们的代码片段呢？</p>\n<ul>\n<li>在编辑区写上你要添加的片段代码</li>\n<li>将代码选中拖拽到Code Snippets区域<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-d2155adf5857e5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-165121.png\"></li>\n<li>在弹框里对代码片段进行编辑，将想要方便更换的内容以<code>&lt;# #&gt;</code>包裹，对应的内容就是可变内容啦<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-0896076c1ab410bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-170317.png\"></li>\n<li>在<code>Completion Shortcut</code>一栏中可以填入快捷标记</li>\n<li>完成以上步骤后，我们在需要使用相关代码片段时只需要输入快捷标记就能选中啦<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-9a97bed7868a1254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-170644.png\"></li>\n</ul>\n<h2 id=\"常用代码片段\"><a href=\"#常用代码片段\" class=\"headerlink\" title=\"常用代码片段\"></a>常用代码片段</h2><p>腾讯QMUI Team开源了一个他们经常使用的代码片段，非常好用，大家可以直接去下载，存放在<code>~/Library/Developer/Xcode/UserData/CodeSnippets</code>目录下</p>\n<p><a href=\"https://github.com/QMUI/QMUI_iOS_CodeSnippets\" target=\"_blank\" rel=\"external\">qmui-ios-codesnippets</a></p>\n<h4 id=\"快捷键汇总\"><a href=\"#快捷键汇总\" class=\"headerlink\" title=\"快捷键汇总\"></a>快捷键汇总</h4><p><em>NSObject</em></p>\n<ul>\n<li><code>pa</code> - 定义一个 <code>assign</code> 的 property</li>\n<li><code>pc</code> - 定义一个 <code>copy</code> 的 property</li>\n<li><code>ps</code> - 定义一个 <code>strong</code> 的property</li>\n<li><code>psr</code> - 定义一个 <code>strong, readonly</code> 的property</li>\n<li><code>pw</code> - 定义一个 <code>weak</code> 的property</li>\n<li><code>propertySwizzleAssign</code> - 用 <code>swizzle</code> 的方式定义一个 <code>assign</code> 的property</li>\n<li><code>propertySwizzleCopy</code> - 用 <code>swizzle</code> 的方式定义一个 <code>copy</code> 的property</li>\n<li><code>propertySwizzleStrong</code> - 用 <code>swizzle</code> 的方式定义一个 <code>strong</code> 的property</li>\n<li><code>propertySwizzleWeak</code> - 用 <code>swizzle</code> 的方式定义一个 <code>weak</code> 的property</li>\n<li><code>sharedInstance</code> - 为当前类创建一个实现单例功能的 <code>sharedInstance</code> 方法</li>\n<li><code>replaceMethod</code> - 重写当前类的 <code>load</code> 方法并在其中用 <code>swizzle</code> 替换方法实现</li>\n<li><code>replaceMethod_QMUI</code> - QMUI 重写当前类的 <code>load</code> 方法并用 <code>ReplaceMethod()</code> 函数替换方法的实现</li>\n</ul>\n<p><em>Block</em></p>\n<ul>\n<li><code>blockArguments</code> - 声明一个用于方法参数的 block</li>\n<li><code>blockproperty</code> - 声明一个用于 property 的 block</li>\n<li><code>blocktypedef</code> - 用 <code>typedef</code> 定义一个 block</li>\n<li><code>blockvar</code> - 定义一个作为局部变量的 block</li>\n</ul>\n<p><em>Method &amp; Function</em></p>\n<ul>\n<li><code>fnv</code> - 定义一个返回值为 <code>void</code> 的方法</li>\n<li><code>fnv:</code> - 定义一个返回值为 <code>void</code> 且带参数的方法</li>\n<li><code>fnblock</code> - 定义一个返回值类型为 block 的方法</li>\n<li><code>fnv_handleEvent</code> - 定义一个用于 <code>UIControl</code> 事件回调的方法</li>\n<li><code>fnv_longPress</code> - 定义一个用于 <code>UILongPressGestureRecognizer</code> 的回调方法（你就不用每次都去拼写那个很长的手势名字了）</li>\n<li><code>fnv_pan</code> - 定义一个用于 <code>UIPanGestureRecognizer</code> 的回调方法</li>\n<li><code>fnv_tap</code> - 定义一个用于 <code>UITapGestureRecognizer</code> 的回调方法</li>\n</ul>\n<p><em>UIView</em></p>\n<ul>\n<li><code>setFrame</code> - 为 <code>UIView</code> 设置 <code>frame</code></li>\n<li><code>setFrame_QMUI</code> - QMUI 使用像素对齐的 <code>CGRectFlatMake()</code> 为 <code>UIView</code> 设置 <code>frame</code></li>\n<li><code>setFrameX</code> - QMUI 使用 <code>CGRectSetX()</code> 修改 <code>UIView</code> 的 <code>frame.origin.x</code></li>\n<li><code>setFrameY</code> - QMUI 使用 <code>CGRectSetY()</code> 修改 <code>UIView</code> 的 <code>frame.origin.y</code></li>\n<li><code>setFrameXY</code> - QMUI 使用 <code>CGRectSetXY()</code> 修改 <code>UIView</code> 的 <code>frame.origin</code></li>\n<li><code>sizeThatFits</code> - 为当前 view 创建 <code>sizeThatFits:</code> 方法</li>\n<li><code>layoutSubviews</code> - 展开 <code>layoutSubviews</code> 方法</li>\n<li><code>updateConstraints</code> - 展开 <code>updateConstraints</code> 方法</li>\n<li><code>getWidth</code> - 展开 <code>CGRectGetWidth()</code></li>\n<li><code>getHeight</code> - 展开 <code>CGRectGetHeight()</code></li>\n<li><code>getMinX</code> - 展开 <code>CGRectGetMinX()</code></li>\n<li><code>getMinY</code> - 展开 <code>CGRectGetMinY()</code></li>\n<li><code>addtarget</code> - 调用 <code>UIControl addTarget:action:forEvents:</code> 方法</li>\n<li><code>setImageForButton</code> - 为 <code>UIButton</code> 设置图片</li>\n<li><code>setTitleColorForButton</code> - 为 <code>UIButton</code> 设置文字颜色</li>\n<li><code>setTitleForButton</code> - 为 <code>UIButton</code> 设置文字</li>\n</ul>\n<p><em>UITableView</em></p>\n<ul>\n<li><code>initWithStyle</code> - 展开 <code>initWithStyle:</code> 方法</li>\n<li><code>initWithStyleForCell</code> - 展开 <code>UITableViewCell initWithStyle:reuseIdentifier:</code> 方法</li>\n<li><code>tableViewDelegate</code> - 展开常用的几个 <code>UITableViewDelegate</code> 方法</li>\n<li><code>numberOfSectionsInTableView</code> - 展开 <code>numberOfSectionsInTableView:</code>方法</li>\n<li><code>numberOfRowsInSection</code> - 展开 <code>tableView:numberOfRowsInSection:</code> 方法</li>\n<li><code>cellForRowAtIndexPath</code> - 展开 <code>tableView:cellForRowAtIndexPath:</code> 方法</li>\n<li><code>heightForRowAtIndexPath</code> - 展开 <code>tableView:heightForRowAtIndexPath:</code> 方法</li>\n<li><code>didSelectRowAtIndexPath</code> - 展开 <code>tableView:didSelectRowAtIndexPath:</code> 方法</li>\n</ul>\n<p><em>UICollectionView</em></p>\n<ul>\n<li><code>collectionViewDelegate</code> - 展开常用的几个<code>UICollectionViewDelegate</code> 方法</li>\n<li><code>numberOfSectionsInCollectionView</code> - 展开 <code>numberOfSectionsInCollectionView:</code></li>\n<li><code>numberOfItemsInSection</code> - 展开 <code>collectionView:numberOfItemsInSection:</code></li>\n<li><code>cellForItemAtIndexPath</code> - 展开 <code>collectionView:cellForItemAtIndexPath:</code></li>\n<li><code>sizeForItemAtIndexPath</code> - 展开 <code>collectionView:layout:sizeForItemAtIndexPath:</code> 方法</li>\n<li><code>didSelectItemAtIndexPath</code> - 展开 <code>collectionView:didSelectItemAtIndexPath:</code> 方法</li>\n<li><code>didDeselectItemAtIndexPath</code> - 展开 <code>collectionView:didDeselectItemAtIndexPath:</code> 方法</li>\n</ul>\n<p><em>UIViewController</em></p>\n<ul>\n<li><code>loadView</code> - 展开 <code>loadView</code> 方法</li>\n<li><code>viewDidLoad</code> - 展开 <code>viewDidLoad</code> 方法</li>\n<li><code>viewWillAppear</code> - 展开 <code>viewWillAppear:</code> 方法</li>\n<li><code>viewDidAppear</code> - 展开 <code>viewDidAppear:</code> 方法</li>\n<li><code>viewWillDisappear</code> - 展开 <code>viewWillDisappear:</code> 方法</li>\n<li><code>viewDidDisappear</code> - 展开 <code>viewDidDisappear:</code> 方法</li>\n<li><code>viewDidLayoutSubviews</code> - 展开 <code>viewDidLayoutSubviews:</code> 方法</li>\n<li><code>updateViewConstraints</code> - 展开 <code>updateViewConstraints:</code> 方法</li>\n<li><code>addChildViewController</code> - 在当前 <code>UIViewController</code> 里添加 <code>childViewController</code></li>\n<li><code>removeFromParentViewController</code> - 将 <code>childViewController</code> 从当前的 <code>UIViewController</code> 里移除</li>\n<li><code>initSubviews</code> - QMUI 展开 <code>initSubviews</code> 方法</li>\n<li><code>setNavigationItems</code> - QMUI 重写 <code>QMUICommonViewController</code> 里的 <code>setNavigationItemsIsInEditMode:animated:</code> 方法</li>\n<li><code>setToolbarItems</code> - QMUI 重写 <code>QMUICommonViewController</code> 里的 <code>setToolbarItemsIsInEditMode:animated:</code> 方法</li>\n<li><code>leftBarButtonItemImage</code> - QMUI 用 <code>QMUINavigationButton</code> 的方法创建一个用于 <code>navigationItem.leftBarButtonItem</code> 的 <code>UIBarButtonItem</code></li>\n<li><code>rightBarButtonItemImage</code> - QMUI 用 <code>QMUINavigationButton</code> 的方法创建一个用于 <code>navigationItem.rightBarButtonItem</code> 的 <code>UIBarButtonItem</code></li>\n</ul>\n<p><em>Other</em></p>\n<ul>\n<li><code>pragma</code> - 展开一个用于 Xcode 导航的 <code>#pragma mark -</code> 宏</li>\n<li><code>externRefInH</code> - 在 <code>*.h</code> 文件里声明一个 <code>extern const</code> 的指针</li>\n<li><code>externRefInM</code> - 在 <code>*.m</code> 文件里为一个 <code>extern const</code> 的指针赋值</li>\n<li><code>externValueInH</code> - 在 <code>*.h</code> 文件里声明一个 <code>extern const</code> 的值变量</li>\n<li><code>externValueInM</code> - 在 <code>*.m</code> 文件里为一个 <code>extern const</code> 的变量赋值</li>\n<li><code>static reference</code> - 定义一个 <code>static</code> 的指针</li>\n<li><code>static</code> - 定义一个 <code>static</code> 的值变量</li>\n<li><code>__weakSelf</code> - 定义一个 <code>weak</code> 的 <code>self</code> 指针</li>\n<li><code>__strongSelf</code> - 将 <code>weakSelf</code> 指针改为 <code>strong</code> 的 <code>self</code> 指针</li>\n<li><code>logCallStackSymbols</code> - 用 <code>NSLog</code> 打出当前的方法调用栈信息</li>\n<li><code>timeConsuming</code> - 展开一段用 <code>CACurrentMediaTime()</code> 来计算方法耗时的代码</li>\n</ul>\n","excerpt":"","more":"<p>Xcode为我们提供了一种可以快速输入一段代码的快捷方式，这里对如何通过自定义快捷代码片段来提升开发效率进行一个总结</p>\n<h2 id=\"如何创建自定义代码片段\"><a href=\"#如何创建自定义代码片段\" class=\"headerlink\" title=\"如何创建自定义代码片段\"></a>如何创建自定义代码片段</h2><p>在Xcode的右下角有一个代码片段区域，如图所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-77d2438767fb5b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-163351.png\"><br>这里面已经有了很多代码片段，这些代码片段是Xcode为我们提前准备的。<br>我们先来看一看里面的结构，点开第一个代码片段<code>C Block typedef - Define a block as a type</code>，这个代码片段是我们通常用来给一个block声明一个别名的<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-a8ef0cc59ef647fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-163706.png\"></p>\n<p>如图所示的代码片段有很多很多，感兴趣的可以自己去看一看，接下来就是本文的重点，如何创建属于我们的代码片段呢？</p>\n<ul>\n<li>在编辑区写上你要添加的片段代码</li>\n<li>将代码选中拖拽到Code Snippets区域<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-d2155adf5857e5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-165121.png\"></li>\n<li>在弹框里对代码片段进行编辑，将想要方便更换的内容以<code>&lt;# #&gt;</code>包裹，对应的内容就是可变内容啦<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-0896076c1ab410bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-170317.png\"></li>\n<li>在<code>Completion Shortcut</code>一栏中可以填入快捷标记</li>\n<li>完成以上步骤后，我们在需要使用相关代码片段时只需要输入快捷标记就能选中啦<br><img src=\"http://upload-images.jianshu.io/upload_images/1479547-9a97bed7868a1254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"QQ20171102-170644.png\"></li>\n</ul>\n<h2 id=\"常用代码片段\"><a href=\"#常用代码片段\" class=\"headerlink\" title=\"常用代码片段\"></a>常用代码片段</h2><p>腾讯QMUI Team开源了一个他们经常使用的代码片段，非常好用，大家可以直接去下载，存放在<code>~/Library/Developer/Xcode/UserData/CodeSnippets</code>目录下</p>\n<p><a href=\"https://github.com/QMUI/QMUI_iOS_CodeSnippets\">qmui-ios-codesnippets</a></p>\n<h4 id=\"快捷键汇总\"><a href=\"#快捷键汇总\" class=\"headerlink\" title=\"快捷键汇总\"></a>快捷键汇总</h4><p><em>NSObject</em></p>\n<ul>\n<li><code>pa</code> - 定义一个 <code>assign</code> 的 property</li>\n<li><code>pc</code> - 定义一个 <code>copy</code> 的 property</li>\n<li><code>ps</code> - 定义一个 <code>strong</code> 的property</li>\n<li><code>psr</code> - 定义一个 <code>strong, readonly</code> 的property</li>\n<li><code>pw</code> - 定义一个 <code>weak</code> 的property</li>\n<li><code>propertySwizzleAssign</code> - 用 <code>swizzle</code> 的方式定义一个 <code>assign</code> 的property</li>\n<li><code>propertySwizzleCopy</code> - 用 <code>swizzle</code> 的方式定义一个 <code>copy</code> 的property</li>\n<li><code>propertySwizzleStrong</code> - 用 <code>swizzle</code> 的方式定义一个 <code>strong</code> 的property</li>\n<li><code>propertySwizzleWeak</code> - 用 <code>swizzle</code> 的方式定义一个 <code>weak</code> 的property</li>\n<li><code>sharedInstance</code> - 为当前类创建一个实现单例功能的 <code>sharedInstance</code> 方法</li>\n<li><code>replaceMethod</code> - 重写当前类的 <code>load</code> 方法并在其中用 <code>swizzle</code> 替换方法实现</li>\n<li><code>replaceMethod_QMUI</code> - QMUI 重写当前类的 <code>load</code> 方法并用 <code>ReplaceMethod()</code> 函数替换方法的实现</li>\n</ul>\n<p><em>Block</em></p>\n<ul>\n<li><code>blockArguments</code> - 声明一个用于方法参数的 block</li>\n<li><code>blockproperty</code> - 声明一个用于 property 的 block</li>\n<li><code>blocktypedef</code> - 用 <code>typedef</code> 定义一个 block</li>\n<li><code>blockvar</code> - 定义一个作为局部变量的 block</li>\n</ul>\n<p><em>Method &amp; Function</em></p>\n<ul>\n<li><code>fnv</code> - 定义一个返回值为 <code>void</code> 的方法</li>\n<li><code>fnv:</code> - 定义一个返回值为 <code>void</code> 且带参数的方法</li>\n<li><code>fnblock</code> - 定义一个返回值类型为 block 的方法</li>\n<li><code>fnv_handleEvent</code> - 定义一个用于 <code>UIControl</code> 事件回调的方法</li>\n<li><code>fnv_longPress</code> - 定义一个用于 <code>UILongPressGestureRecognizer</code> 的回调方法（你就不用每次都去拼写那个很长的手势名字了）</li>\n<li><code>fnv_pan</code> - 定义一个用于 <code>UIPanGestureRecognizer</code> 的回调方法</li>\n<li><code>fnv_tap</code> - 定义一个用于 <code>UITapGestureRecognizer</code> 的回调方法</li>\n</ul>\n<p><em>UIView</em></p>\n<ul>\n<li><code>setFrame</code> - 为 <code>UIView</code> 设置 <code>frame</code></li>\n<li><code>setFrame_QMUI</code> - QMUI 使用像素对齐的 <code>CGRectFlatMake()</code> 为 <code>UIView</code> 设置 <code>frame</code></li>\n<li><code>setFrameX</code> - QMUI 使用 <code>CGRectSetX()</code> 修改 <code>UIView</code> 的 <code>frame.origin.x</code></li>\n<li><code>setFrameY</code> - QMUI 使用 <code>CGRectSetY()</code> 修改 <code>UIView</code> 的 <code>frame.origin.y</code></li>\n<li><code>setFrameXY</code> - QMUI 使用 <code>CGRectSetXY()</code> 修改 <code>UIView</code> 的 <code>frame.origin</code></li>\n<li><code>sizeThatFits</code> - 为当前 view 创建 <code>sizeThatFits:</code> 方法</li>\n<li><code>layoutSubviews</code> - 展开 <code>layoutSubviews</code> 方法</li>\n<li><code>updateConstraints</code> - 展开 <code>updateConstraints</code> 方法</li>\n<li><code>getWidth</code> - 展开 <code>CGRectGetWidth()</code></li>\n<li><code>getHeight</code> - 展开 <code>CGRectGetHeight()</code></li>\n<li><code>getMinX</code> - 展开 <code>CGRectGetMinX()</code></li>\n<li><code>getMinY</code> - 展开 <code>CGRectGetMinY()</code></li>\n<li><code>addtarget</code> - 调用 <code>UIControl addTarget:action:forEvents:</code> 方法</li>\n<li><code>setImageForButton</code> - 为 <code>UIButton</code> 设置图片</li>\n<li><code>setTitleColorForButton</code> - 为 <code>UIButton</code> 设置文字颜色</li>\n<li><code>setTitleForButton</code> - 为 <code>UIButton</code> 设置文字</li>\n</ul>\n<p><em>UITableView</em></p>\n<ul>\n<li><code>initWithStyle</code> - 展开 <code>initWithStyle:</code> 方法</li>\n<li><code>initWithStyleForCell</code> - 展开 <code>UITableViewCell initWithStyle:reuseIdentifier:</code> 方法</li>\n<li><code>tableViewDelegate</code> - 展开常用的几个 <code>UITableViewDelegate</code> 方法</li>\n<li><code>numberOfSectionsInTableView</code> - 展开 <code>numberOfSectionsInTableView:</code>方法</li>\n<li><code>numberOfRowsInSection</code> - 展开 <code>tableView:numberOfRowsInSection:</code> 方法</li>\n<li><code>cellForRowAtIndexPath</code> - 展开 <code>tableView:cellForRowAtIndexPath:</code> 方法</li>\n<li><code>heightForRowAtIndexPath</code> - 展开 <code>tableView:heightForRowAtIndexPath:</code> 方法</li>\n<li><code>didSelectRowAtIndexPath</code> - 展开 <code>tableView:didSelectRowAtIndexPath:</code> 方法</li>\n</ul>\n<p><em>UICollectionView</em></p>\n<ul>\n<li><code>collectionViewDelegate</code> - 展开常用的几个<code>UICollectionViewDelegate</code> 方法</li>\n<li><code>numberOfSectionsInCollectionView</code> - 展开 <code>numberOfSectionsInCollectionView:</code></li>\n<li><code>numberOfItemsInSection</code> - 展开 <code>collectionView:numberOfItemsInSection:</code></li>\n<li><code>cellForItemAtIndexPath</code> - 展开 <code>collectionView:cellForItemAtIndexPath:</code></li>\n<li><code>sizeForItemAtIndexPath</code> - 展开 <code>collectionView:layout:sizeForItemAtIndexPath:</code> 方法</li>\n<li><code>didSelectItemAtIndexPath</code> - 展开 <code>collectionView:didSelectItemAtIndexPath:</code> 方法</li>\n<li><code>didDeselectItemAtIndexPath</code> - 展开 <code>collectionView:didDeselectItemAtIndexPath:</code> 方法</li>\n</ul>\n<p><em>UIViewController</em></p>\n<ul>\n<li><code>loadView</code> - 展开 <code>loadView</code> 方法</li>\n<li><code>viewDidLoad</code> - 展开 <code>viewDidLoad</code> 方法</li>\n<li><code>viewWillAppear</code> - 展开 <code>viewWillAppear:</code> 方法</li>\n<li><code>viewDidAppear</code> - 展开 <code>viewDidAppear:</code> 方法</li>\n<li><code>viewWillDisappear</code> - 展开 <code>viewWillDisappear:</code> 方法</li>\n<li><code>viewDidDisappear</code> - 展开 <code>viewDidDisappear:</code> 方法</li>\n<li><code>viewDidLayoutSubviews</code> - 展开 <code>viewDidLayoutSubviews:</code> 方法</li>\n<li><code>updateViewConstraints</code> - 展开 <code>updateViewConstraints:</code> 方法</li>\n<li><code>addChildViewController</code> - 在当前 <code>UIViewController</code> 里添加 <code>childViewController</code></li>\n<li><code>removeFromParentViewController</code> - 将 <code>childViewController</code> 从当前的 <code>UIViewController</code> 里移除</li>\n<li><code>initSubviews</code> - QMUI 展开 <code>initSubviews</code> 方法</li>\n<li><code>setNavigationItems</code> - QMUI 重写 <code>QMUICommonViewController</code> 里的 <code>setNavigationItemsIsInEditMode:animated:</code> 方法</li>\n<li><code>setToolbarItems</code> - QMUI 重写 <code>QMUICommonViewController</code> 里的 <code>setToolbarItemsIsInEditMode:animated:</code> 方法</li>\n<li><code>leftBarButtonItemImage</code> - QMUI 用 <code>QMUINavigationButton</code> 的方法创建一个用于 <code>navigationItem.leftBarButtonItem</code> 的 <code>UIBarButtonItem</code></li>\n<li><code>rightBarButtonItemImage</code> - QMUI 用 <code>QMUINavigationButton</code> 的方法创建一个用于 <code>navigationItem.rightBarButtonItem</code> 的 <code>UIBarButtonItem</code></li>\n</ul>\n<p><em>Other</em></p>\n<ul>\n<li><code>pragma</code> - 展开一个用于 Xcode 导航的 <code>#pragma mark -</code> 宏</li>\n<li><code>externRefInH</code> - 在 <code>*.h</code> 文件里声明一个 <code>extern const</code> 的指针</li>\n<li><code>externRefInM</code> - 在 <code>*.m</code> 文件里为一个 <code>extern const</code> 的指针赋值</li>\n<li><code>externValueInH</code> - 在 <code>*.h</code> 文件里声明一个 <code>extern const</code> 的值变量</li>\n<li><code>externValueInM</code> - 在 <code>*.m</code> 文件里为一个 <code>extern const</code> 的变量赋值</li>\n<li><code>static reference</code> - 定义一个 <code>static</code> 的指针</li>\n<li><code>static</code> - 定义一个 <code>static</code> 的值变量</li>\n<li><code>__weakSelf</code> - 定义一个 <code>weak</code> 的 <code>self</code> 指针</li>\n<li><code>__strongSelf</code> - 将 <code>weakSelf</code> 指针改为 <code>strong</code> 的 <code>self</code> 指针</li>\n<li><code>logCallStackSymbols</code> - 用 <code>NSLog</code> 打出当前的方法调用栈信息</li>\n<li><code>timeConsuming</code> - 展开一段用 <code>CACurrentMediaTime()</code> 来计算方法耗时的代码</li>\n</ul>\n"},{"title":"深入浅出Texture--高性能界面的解决方案","date":"2017-06-01T11:08:00.000Z","_content":"\n[Texture](https://github.com/texturegroup/texture/)是由Facebook开源的[AsyncDisplayKit](https://github.com/facebookarchive/AsyncDisplayKit)演变而来\n\n### 特性\nTexture的基础单元是一个个node，ASDisplayNode是基于CALayer的一层抽象。不同于UIView对象，ASDisplayNode是线程安全的，它不仅仅可以用于主线程而且可以在辅线程中使用。\n\n使用Texture可以让我们在辅线程中进行图片的解析、文本的适应、约束等等UI操作，从而能够保证主线程及时对用户的操作做出反应\n\n### 常用类\n- `ASViewController`: 基于`UIViewController`封装的子类，能够方便的为我们提供node的管理\n- `ASNavigationController`: 可用于替代`UINavigationController`，遵循`ASVisibility`协议\n- `ASTabBarController`: 可用于替代`UITabBarController`，遵循`ASVisiblity`协议\n- `ASCollectionNode`、`ASTableNode`:等同于`UICollectionView`、`UITableView`\n- `ASPagerNode`:基于`ASCollectionNode`封装的子类，能够像`UIPageViewController`一样给我们提供强大的滑动操作体验\n- `ASCellNode`:等同于`UITableViewCell`、`UICollectionViewCell`，需要强调的是它返回的是一个Block(ASCellNodeBlock)。\n- `ASScrollNode`: 代替`UIScrollView`\n- `ASEditableTextNode`: 代替`UITextView`\n- `ASTextNode`: 代替`UILabel`\n- `ASImageNode`: 代替`UIImage`\n- `ASNetworkImageNode`: 可以自动加载图片并进行内存管理，而且还支持逐步加载Jpeg和动态gif图片\n- `ASMultiplexImageNode`:\n- `ASVideoNode`: 代替`AVPlayerLayer`\n- `ASVideoPlayerNode`: 代替`UIMoviePlayer`\n- `ASControlNode`: 代替`UIControl`\n- `ASButtonNode`: 代替`UIButton`\n- `ASMapNode`: 代替`MKMapView`\n- `ASStackLayoutSpec`: 堆放布局规则\n- `ASOverlayLayoutSpec`: 覆盖布局规则\n- `ASRelativeLayoutSpec`: 相对布局规则\n- `ASInsetLayoutSpec`: 插入布局规则\n- `ASBackgroundLayoutSpec`: 背景布局规则\n- `ASCenterLayoutSpec`: 中心布局规则\n- `ASAbsoluteLayoutSpec`: 绝对布局规则\n- `ASRatioLayoutSpec`: 比例布局规则\n\n\n### 层级结构\n\n```\ngraph TB\nASDisplayNode-->ASTableNode\nASDisplayNode-->ASCollectionNode\nASDisplayNode-->ASCellNode\nASDisplayNode-->ASScrollNode\nASDisplayNode-->ASEditableTextNode\nASDisplayNode-->ASControlNode\nASCollectionNode-->ASPagerNode\nASControlNode-->ASButtonNode\nASControlNode-->ASTextNode\nASControlNode-->ASMapNode\nASControlNode-->ASImageNode\nASImageNode-->ASNetworkImageNode\nASImageNode-->ASMultiplexImageNode\nASNetworkImageNode-->ASVideoNode\n```\n\n### 批抓取进行无限滚动\n\n```\n// 将leadingScreensForBatching 设置为1.0表示当滚动到还剩下一个全屏时就开始抓取新的一批数据\nself.tableNode.view.leadingScreensForBatching = 1.0; \n```\n\n```\n- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode {\n    return YES;\n}\n```\n\n### ASDK的容器\n\n当在项目中替换使用AsyncDisplayKit的时候，应该把nodes节点，当做一个子节点添加到一个容器类里，这些容器类负责告诉所包含的节点，他们现在是什么状态，以便尽可能有效的加载数据和渲染，经常犯的一个错误是把node节点直接添加到一个现有的view中，这样做会导致节点在渲染的时候会闪烁一下。\n\nTexture为我们提供了以下这些节点容器：\n- `ASCollectionNode`\n- `ASPagerNode`\n- `ASTableNode`\n- `ASViewController`\n- `ASNavigationController`\n- `ASTabBarController`\n\n#### 使用节点容器的好处\n节点容器能够自动为它的节点们管理高效的预加载，这就意味着节点容器中所有的节点的尺寸约束、数据请求、图片解析、渲染都将是异步进行\n\n### 核心机制\n\nTexture模拟了Core Animation的机制，所有针对ASNode的修改和提交，总有些任务是必需放在主线程执行的，当这种任务出现的时候，ASNode就会把任务用`ASAsyncTransaction(Group)`封装并提交到一个全局的容器去。Texture在RunLoop中注册了一个Observer，监视的事件和CA一样，但是优先级比CA低。当RunLoop进入休眠前，CA处理完事件后，ASDK就会执行该loop内提交的所有任务\n\n利用这个机制，Texture可以在合适的机会把异步、并发的操作同步到主线程去，并且获得不错的性能\n\n### 用法\n\n1. 利用ASTableNode替代UITableView创建一个高性能的列表页面\n\n2. 利用ASLayoutSpec替代AutoLayout创建高效的页面约束\n\n\n### 疑问点\n- 为何使用`ASCellNode`不需要担心cell重用问题？\n\n### 参考地址\n\n[AsyncDisplaykit2.0 使用](http://www.bijishequ.com/detail/227995?p=)--主要讲解了LayoutSpec相关的知识\n\n\n","source":"_posts/深入浅出Texture-高性能界面的解决方案.md","raw":"title: 深入浅出Texture--高性能界面的解决方案\ntags:\n  - iOS进阶\ncategories:\n  - iOS\ndate: 2017-06-01 19:08:00\n---\n\n[Texture](https://github.com/texturegroup/texture/)是由Facebook开源的[AsyncDisplayKit](https://github.com/facebookarchive/AsyncDisplayKit)演变而来\n\n### 特性\nTexture的基础单元是一个个node，ASDisplayNode是基于CALayer的一层抽象。不同于UIView对象，ASDisplayNode是线程安全的，它不仅仅可以用于主线程而且可以在辅线程中使用。\n\n使用Texture可以让我们在辅线程中进行图片的解析、文本的适应、约束等等UI操作，从而能够保证主线程及时对用户的操作做出反应\n\n### 常用类\n- `ASViewController`: 基于`UIViewController`封装的子类，能够方便的为我们提供node的管理\n- `ASNavigationController`: 可用于替代`UINavigationController`，遵循`ASVisibility`协议\n- `ASTabBarController`: 可用于替代`UITabBarController`，遵循`ASVisiblity`协议\n- `ASCollectionNode`、`ASTableNode`:等同于`UICollectionView`、`UITableView`\n- `ASPagerNode`:基于`ASCollectionNode`封装的子类，能够像`UIPageViewController`一样给我们提供强大的滑动操作体验\n- `ASCellNode`:等同于`UITableViewCell`、`UICollectionViewCell`，需要强调的是它返回的是一个Block(ASCellNodeBlock)。\n- `ASScrollNode`: 代替`UIScrollView`\n- `ASEditableTextNode`: 代替`UITextView`\n- `ASTextNode`: 代替`UILabel`\n- `ASImageNode`: 代替`UIImage`\n- `ASNetworkImageNode`: 可以自动加载图片并进行内存管理，而且还支持逐步加载Jpeg和动态gif图片\n- `ASMultiplexImageNode`:\n- `ASVideoNode`: 代替`AVPlayerLayer`\n- `ASVideoPlayerNode`: 代替`UIMoviePlayer`\n- `ASControlNode`: 代替`UIControl`\n- `ASButtonNode`: 代替`UIButton`\n- `ASMapNode`: 代替`MKMapView`\n- `ASStackLayoutSpec`: 堆放布局规则\n- `ASOverlayLayoutSpec`: 覆盖布局规则\n- `ASRelativeLayoutSpec`: 相对布局规则\n- `ASInsetLayoutSpec`: 插入布局规则\n- `ASBackgroundLayoutSpec`: 背景布局规则\n- `ASCenterLayoutSpec`: 中心布局规则\n- `ASAbsoluteLayoutSpec`: 绝对布局规则\n- `ASRatioLayoutSpec`: 比例布局规则\n\n\n### 层级结构\n\n```\ngraph TB\nASDisplayNode-->ASTableNode\nASDisplayNode-->ASCollectionNode\nASDisplayNode-->ASCellNode\nASDisplayNode-->ASScrollNode\nASDisplayNode-->ASEditableTextNode\nASDisplayNode-->ASControlNode\nASCollectionNode-->ASPagerNode\nASControlNode-->ASButtonNode\nASControlNode-->ASTextNode\nASControlNode-->ASMapNode\nASControlNode-->ASImageNode\nASImageNode-->ASNetworkImageNode\nASImageNode-->ASMultiplexImageNode\nASNetworkImageNode-->ASVideoNode\n```\n\n### 批抓取进行无限滚动\n\n```\n// 将leadingScreensForBatching 设置为1.0表示当滚动到还剩下一个全屏时就开始抓取新的一批数据\nself.tableNode.view.leadingScreensForBatching = 1.0; \n```\n\n```\n- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode {\n    return YES;\n}\n```\n\n### ASDK的容器\n\n当在项目中替换使用AsyncDisplayKit的时候，应该把nodes节点，当做一个子节点添加到一个容器类里，这些容器类负责告诉所包含的节点，他们现在是什么状态，以便尽可能有效的加载数据和渲染，经常犯的一个错误是把node节点直接添加到一个现有的view中，这样做会导致节点在渲染的时候会闪烁一下。\n\nTexture为我们提供了以下这些节点容器：\n- `ASCollectionNode`\n- `ASPagerNode`\n- `ASTableNode`\n- `ASViewController`\n- `ASNavigationController`\n- `ASTabBarController`\n\n#### 使用节点容器的好处\n节点容器能够自动为它的节点们管理高效的预加载，这就意味着节点容器中所有的节点的尺寸约束、数据请求、图片解析、渲染都将是异步进行\n\n### 核心机制\n\nTexture模拟了Core Animation的机制，所有针对ASNode的修改和提交，总有些任务是必需放在主线程执行的，当这种任务出现的时候，ASNode就会把任务用`ASAsyncTransaction(Group)`封装并提交到一个全局的容器去。Texture在RunLoop中注册了一个Observer，监视的事件和CA一样，但是优先级比CA低。当RunLoop进入休眠前，CA处理完事件后，ASDK就会执行该loop内提交的所有任务\n\n利用这个机制，Texture可以在合适的机会把异步、并发的操作同步到主线程去，并且获得不错的性能\n\n### 用法\n\n1. 利用ASTableNode替代UITableView创建一个高性能的列表页面\n\n2. 利用ASLayoutSpec替代AutoLayout创建高效的页面约束\n\n\n### 疑问点\n- 为何使用`ASCellNode`不需要担心cell重用问题？\n\n### 参考地址\n\n[AsyncDisplaykit2.0 使用](http://www.bijishequ.com/detail/227995?p=)--主要讲解了LayoutSpec相关的知识\n\n\n","slug":"深入浅出Texture-高性能界面的解决方案","published":1,"updated":"2018-08-31T09:45:07.598Z","_id":"cjlhoqwjb003jkj79cb4pldbz","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://github.com/texturegroup/texture/\" target=\"_blank\" rel=\"external\">Texture</a>是由Facebook开源的<a href=\"https://github.com/facebookarchive/AsyncDisplayKit\" target=\"_blank\" rel=\"external\">AsyncDisplayKit</a>演变而来</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>Texture的基础单元是一个个node，ASDisplayNode是基于CALayer的一层抽象。不同于UIView对象，ASDisplayNode是线程安全的，它不仅仅可以用于主线程而且可以在辅线程中使用。</p>\n<p>使用Texture可以让我们在辅线程中进行图片的解析、文本的适应、约束等等UI操作，从而能够保证主线程及时对用户的操作做出反应</p>\n<h3 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h3><ul>\n<li><code>ASViewController</code>: 基于<code>UIViewController</code>封装的子类，能够方便的为我们提供node的管理</li>\n<li><code>ASNavigationController</code>: 可用于替代<code>UINavigationController</code>，遵循<code>ASVisibility</code>协议</li>\n<li><code>ASTabBarController</code>: 可用于替代<code>UITabBarController</code>，遵循<code>ASVisiblity</code>协议</li>\n<li><code>ASCollectionNode</code>、<code>ASTableNode</code>:等同于<code>UICollectionView</code>、<code>UITableView</code></li>\n<li><code>ASPagerNode</code>:基于<code>ASCollectionNode</code>封装的子类，能够像<code>UIPageViewController</code>一样给我们提供强大的滑动操作体验</li>\n<li><code>ASCellNode</code>:等同于<code>UITableViewCell</code>、<code>UICollectionViewCell</code>，需要强调的是它返回的是一个Block(ASCellNodeBlock)。</li>\n<li><code>ASScrollNode</code>: 代替<code>UIScrollView</code></li>\n<li><code>ASEditableTextNode</code>: 代替<code>UITextView</code></li>\n<li><code>ASTextNode</code>: 代替<code>UILabel</code></li>\n<li><code>ASImageNode</code>: 代替<code>UIImage</code></li>\n<li><code>ASNetworkImageNode</code>: 可以自动加载图片并进行内存管理，而且还支持逐步加载Jpeg和动态gif图片</li>\n<li><code>ASMultiplexImageNode</code>:</li>\n<li><code>ASVideoNode</code>: 代替<code>AVPlayerLayer</code></li>\n<li><code>ASVideoPlayerNode</code>: 代替<code>UIMoviePlayer</code></li>\n<li><code>ASControlNode</code>: 代替<code>UIControl</code></li>\n<li><code>ASButtonNode</code>: 代替<code>UIButton</code></li>\n<li><code>ASMapNode</code>: 代替<code>MKMapView</code></li>\n<li><code>ASStackLayoutSpec</code>: 堆放布局规则</li>\n<li><code>ASOverlayLayoutSpec</code>: 覆盖布局规则</li>\n<li><code>ASRelativeLayoutSpec</code>: 相对布局规则</li>\n<li><code>ASInsetLayoutSpec</code>: 插入布局规则</li>\n<li><code>ASBackgroundLayoutSpec</code>: 背景布局规则</li>\n<li><code>ASCenterLayoutSpec</code>: 中心布局规则</li>\n<li><code>ASAbsoluteLayoutSpec</code>: 绝对布局规则</li>\n<li><code>ASRatioLayoutSpec</code>: 比例布局规则</li>\n</ul>\n<h3 id=\"层级结构\"><a href=\"#层级结构\" class=\"headerlink\" title=\"层级结构\"></a>层级结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">graph TB</div><div class=\"line\">ASDisplayNode--&gt;ASTableNode</div><div class=\"line\">ASDisplayNode--&gt;ASCollectionNode</div><div class=\"line\">ASDisplayNode--&gt;ASCellNode</div><div class=\"line\">ASDisplayNode--&gt;ASScrollNode</div><div class=\"line\">ASDisplayNode--&gt;ASEditableTextNode</div><div class=\"line\">ASDisplayNode--&gt;ASControlNode</div><div class=\"line\">ASCollectionNode--&gt;ASPagerNode</div><div class=\"line\">ASControlNode--&gt;ASButtonNode</div><div class=\"line\">ASControlNode--&gt;ASTextNode</div><div class=\"line\">ASControlNode--&gt;ASMapNode</div><div class=\"line\">ASControlNode--&gt;ASImageNode</div><div class=\"line\">ASImageNode--&gt;ASNetworkImageNode</div><div class=\"line\">ASImageNode--&gt;ASMultiplexImageNode</div><div class=\"line\">ASNetworkImageNode--&gt;ASVideoNode</div></pre></td></tr></table></figure>\n<h3 id=\"批抓取进行无限滚动\"><a href=\"#批抓取进行无限滚动\" class=\"headerlink\" title=\"批抓取进行无限滚动\"></a>批抓取进行无限滚动</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将leadingScreensForBatching 设置为1.0表示当滚动到还剩下一个全屏时就开始抓取新的一批数据</div><div class=\"line\">self.tableNode.view.leadingScreensForBatching = 1.0;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ASDK的容器\"><a href=\"#ASDK的容器\" class=\"headerlink\" title=\"ASDK的容器\"></a>ASDK的容器</h3><p>当在项目中替换使用AsyncDisplayKit的时候，应该把nodes节点，当做一个子节点添加到一个容器类里，这些容器类负责告诉所包含的节点，他们现在是什么状态，以便尽可能有效的加载数据和渲染，经常犯的一个错误是把node节点直接添加到一个现有的view中，这样做会导致节点在渲染的时候会闪烁一下。</p>\n<p>Texture为我们提供了以下这些节点容器：</p>\n<ul>\n<li><code>ASCollectionNode</code></li>\n<li><code>ASPagerNode</code></li>\n<li><code>ASTableNode</code></li>\n<li><code>ASViewController</code></li>\n<li><code>ASNavigationController</code></li>\n<li><code>ASTabBarController</code></li>\n</ul>\n<h4 id=\"使用节点容器的好处\"><a href=\"#使用节点容器的好处\" class=\"headerlink\" title=\"使用节点容器的好处\"></a>使用节点容器的好处</h4><p>节点容器能够自动为它的节点们管理高效的预加载，这就意味着节点容器中所有的节点的尺寸约束、数据请求、图片解析、渲染都将是异步进行</p>\n<h3 id=\"核心机制\"><a href=\"#核心机制\" class=\"headerlink\" title=\"核心机制\"></a>核心机制</h3><p>Texture模拟了Core Animation的机制，所有针对ASNode的修改和提交，总有些任务是必需放在主线程执行的，当这种任务出现的时候，ASNode就会把任务用<code>ASAsyncTransaction(Group)</code>封装并提交到一个全局的容器去。Texture在RunLoop中注册了一个Observer，监视的事件和CA一样，但是优先级比CA低。当RunLoop进入休眠前，CA处理完事件后，ASDK就会执行该loop内提交的所有任务</p>\n<p>利用这个机制，Texture可以在合适的机会把异步、并发的操作同步到主线程去，并且获得不错的性能</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><ol>\n<li><p>利用ASTableNode替代UITableView创建一个高性能的列表页面</p>\n</li>\n<li><p>利用ASLayoutSpec替代AutoLayout创建高效的页面约束</p>\n</li>\n</ol>\n<h3 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h3><ul>\n<li>为何使用<code>ASCellNode</code>不需要担心cell重用问题？</li>\n</ul>\n<h3 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h3><p><a href=\"http://www.bijishequ.com/detail/227995?p=\" target=\"_blank\" rel=\"external\">AsyncDisplaykit2.0 使用</a>–主要讲解了LayoutSpec相关的知识</p>\n","excerpt":"","more":"<p><a href=\"https://github.com/texturegroup/texture/\">Texture</a>是由Facebook开源的<a href=\"https://github.com/facebookarchive/AsyncDisplayKit\">AsyncDisplayKit</a>演变而来</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>Texture的基础单元是一个个node，ASDisplayNode是基于CALayer的一层抽象。不同于UIView对象，ASDisplayNode是线程安全的，它不仅仅可以用于主线程而且可以在辅线程中使用。</p>\n<p>使用Texture可以让我们在辅线程中进行图片的解析、文本的适应、约束等等UI操作，从而能够保证主线程及时对用户的操作做出反应</p>\n<h3 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h3><ul>\n<li><code>ASViewController</code>: 基于<code>UIViewController</code>封装的子类，能够方便的为我们提供node的管理</li>\n<li><code>ASNavigationController</code>: 可用于替代<code>UINavigationController</code>，遵循<code>ASVisibility</code>协议</li>\n<li><code>ASTabBarController</code>: 可用于替代<code>UITabBarController</code>，遵循<code>ASVisiblity</code>协议</li>\n<li><code>ASCollectionNode</code>、<code>ASTableNode</code>:等同于<code>UICollectionView</code>、<code>UITableView</code></li>\n<li><code>ASPagerNode</code>:基于<code>ASCollectionNode</code>封装的子类，能够像<code>UIPageViewController</code>一样给我们提供强大的滑动操作体验</li>\n<li><code>ASCellNode</code>:等同于<code>UITableViewCell</code>、<code>UICollectionViewCell</code>，需要强调的是它返回的是一个Block(ASCellNodeBlock)。</li>\n<li><code>ASScrollNode</code>: 代替<code>UIScrollView</code></li>\n<li><code>ASEditableTextNode</code>: 代替<code>UITextView</code></li>\n<li><code>ASTextNode</code>: 代替<code>UILabel</code></li>\n<li><code>ASImageNode</code>: 代替<code>UIImage</code></li>\n<li><code>ASNetworkImageNode</code>: 可以自动加载图片并进行内存管理，而且还支持逐步加载Jpeg和动态gif图片</li>\n<li><code>ASMultiplexImageNode</code>:</li>\n<li><code>ASVideoNode</code>: 代替<code>AVPlayerLayer</code></li>\n<li><code>ASVideoPlayerNode</code>: 代替<code>UIMoviePlayer</code></li>\n<li><code>ASControlNode</code>: 代替<code>UIControl</code></li>\n<li><code>ASButtonNode</code>: 代替<code>UIButton</code></li>\n<li><code>ASMapNode</code>: 代替<code>MKMapView</code></li>\n<li><code>ASStackLayoutSpec</code>: 堆放布局规则</li>\n<li><code>ASOverlayLayoutSpec</code>: 覆盖布局规则</li>\n<li><code>ASRelativeLayoutSpec</code>: 相对布局规则</li>\n<li><code>ASInsetLayoutSpec</code>: 插入布局规则</li>\n<li><code>ASBackgroundLayoutSpec</code>: 背景布局规则</li>\n<li><code>ASCenterLayoutSpec</code>: 中心布局规则</li>\n<li><code>ASAbsoluteLayoutSpec</code>: 绝对布局规则</li>\n<li><code>ASRatioLayoutSpec</code>: 比例布局规则</li>\n</ul>\n<h3 id=\"层级结构\"><a href=\"#层级结构\" class=\"headerlink\" title=\"层级结构\"></a>层级结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">graph TB</div><div class=\"line\">ASDisplayNode--&gt;ASTableNode</div><div class=\"line\">ASDisplayNode--&gt;ASCollectionNode</div><div class=\"line\">ASDisplayNode--&gt;ASCellNode</div><div class=\"line\">ASDisplayNode--&gt;ASScrollNode</div><div class=\"line\">ASDisplayNode--&gt;ASEditableTextNode</div><div class=\"line\">ASDisplayNode--&gt;ASControlNode</div><div class=\"line\">ASCollectionNode--&gt;ASPagerNode</div><div class=\"line\">ASControlNode--&gt;ASButtonNode</div><div class=\"line\">ASControlNode--&gt;ASTextNode</div><div class=\"line\">ASControlNode--&gt;ASMapNode</div><div class=\"line\">ASControlNode--&gt;ASImageNode</div><div class=\"line\">ASImageNode--&gt;ASNetworkImageNode</div><div class=\"line\">ASImageNode--&gt;ASMultiplexImageNode</div><div class=\"line\">ASNetworkImageNode--&gt;ASVideoNode</div></pre></td></tr></table></figure>\n<h3 id=\"批抓取进行无限滚动\"><a href=\"#批抓取进行无限滚动\" class=\"headerlink\" title=\"批抓取进行无限滚动\"></a>批抓取进行无限滚动</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将leadingScreensForBatching 设置为1.0表示当滚动到还剩下一个全屏时就开始抓取新的一批数据</div><div class=\"line\">self.tableNode.view.leadingScreensForBatching = 1.0;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ASDK的容器\"><a href=\"#ASDK的容器\" class=\"headerlink\" title=\"ASDK的容器\"></a>ASDK的容器</h3><p>当在项目中替换使用AsyncDisplayKit的时候，应该把nodes节点，当做一个子节点添加到一个容器类里，这些容器类负责告诉所包含的节点，他们现在是什么状态，以便尽可能有效的加载数据和渲染，经常犯的一个错误是把node节点直接添加到一个现有的view中，这样做会导致节点在渲染的时候会闪烁一下。</p>\n<p>Texture为我们提供了以下这些节点容器：</p>\n<ul>\n<li><code>ASCollectionNode</code></li>\n<li><code>ASPagerNode</code></li>\n<li><code>ASTableNode</code></li>\n<li><code>ASViewController</code></li>\n<li><code>ASNavigationController</code></li>\n<li><code>ASTabBarController</code></li>\n</ul>\n<h4 id=\"使用节点容器的好处\"><a href=\"#使用节点容器的好处\" class=\"headerlink\" title=\"使用节点容器的好处\"></a>使用节点容器的好处</h4><p>节点容器能够自动为它的节点们管理高效的预加载，这就意味着节点容器中所有的节点的尺寸约束、数据请求、图片解析、渲染都将是异步进行</p>\n<h3 id=\"核心机制\"><a href=\"#核心机制\" class=\"headerlink\" title=\"核心机制\"></a>核心机制</h3><p>Texture模拟了Core Animation的机制，所有针对ASNode的修改和提交，总有些任务是必需放在主线程执行的，当这种任务出现的时候，ASNode就会把任务用<code>ASAsyncTransaction(Group)</code>封装并提交到一个全局的容器去。Texture在RunLoop中注册了一个Observer，监视的事件和CA一样，但是优先级比CA低。当RunLoop进入休眠前，CA处理完事件后，ASDK就会执行该loop内提交的所有任务</p>\n<p>利用这个机制，Texture可以在合适的机会把异步、并发的操作同步到主线程去，并且获得不错的性能</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><ol>\n<li><p>利用ASTableNode替代UITableView创建一个高性能的列表页面</p>\n</li>\n<li><p>利用ASLayoutSpec替代AutoLayout创建高效的页面约束</p>\n</li>\n</ol>\n<h3 id=\"疑问点\"><a href=\"#疑问点\" class=\"headerlink\" title=\"疑问点\"></a>疑问点</h3><ul>\n<li>为何使用<code>ASCellNode</code>不需要担心cell重用问题？</li>\n</ul>\n<h3 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h3><p><a href=\"http://www.bijishequ.com/detail/227995?p=\">AsyncDisplaykit2.0 使用</a>–主要讲解了LayoutSpec相关的知识</p>\n"},{"title":"自定义UIPageControl","date":"2017-04-11T03:46:00.000Z","_content":"\n近期项目中需要给UIPageControl自定义图片，为了方便使用也为了方便大家，建了一个轮子[ZYPageControl](https://github.com/luzhiyongGit/ZYPageControl)\n\n### 实现思路\n1. 继承至UIView创建一个ZYPageControl\n2. 为ZYPageControl类添加`currentPage`、`numberOfPages`等PageControl控件常用的属性\n3. 添加设置图片的方法\n4. 在`- (void)layoutSubviews`方法里 绘制pageControl\n\n### 支持功能\n- 设置PageControl的默认图和高亮图\n- 灵活设置PageControl间距\n- 灵活设置PageControl的大小\n- 灵活设置PageControl的位置\n\n### 使用方法\n#### 手动集成\n1. 下载ZYPageControl的代码\n2. 将ZYPageControl类添加到项目中\n3. 与UIPageControl用法一样，创建一个ZYPageControl对象并添加到View上\n4. 设置你想要的图片作为默认图\n5. 设置你想要的PageControl间距\n\n#### Pod集成\n等待发布支持~\n\n\n\n","source":"_posts/自定义UIPageControl.md","raw":"title: 自定义UIPageControl\ntags:\n  - iOS进阶\n  - ''\ncategories:\n  - iOS\ndate: 2017-04-11 11:46:00\n---\n\n近期项目中需要给UIPageControl自定义图片，为了方便使用也为了方便大家，建了一个轮子[ZYPageControl](https://github.com/luzhiyongGit/ZYPageControl)\n\n### 实现思路\n1. 继承至UIView创建一个ZYPageControl\n2. 为ZYPageControl类添加`currentPage`、`numberOfPages`等PageControl控件常用的属性\n3. 添加设置图片的方法\n4. 在`- (void)layoutSubviews`方法里 绘制pageControl\n\n### 支持功能\n- 设置PageControl的默认图和高亮图\n- 灵活设置PageControl间距\n- 灵活设置PageControl的大小\n- 灵活设置PageControl的位置\n\n### 使用方法\n#### 手动集成\n1. 下载ZYPageControl的代码\n2. 将ZYPageControl类添加到项目中\n3. 与UIPageControl用法一样，创建一个ZYPageControl对象并添加到View上\n4. 设置你想要的图片作为默认图\n5. 设置你想要的PageControl间距\n\n#### Pod集成\n等待发布支持~\n\n\n\n","slug":"自定义UIPageControl","published":1,"updated":"2018-08-31T09:45:27.242Z","_id":"cjlhoqwjc003mkj796xj59gut","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近期项目中需要给UIPageControl自定义图片，为了方便使用也为了方便大家，建了一个轮子<a href=\"https://github.com/luzhiyongGit/ZYPageControl\" target=\"_blank\" rel=\"external\">ZYPageControl</a></p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><ol>\n<li>继承至UIView创建一个ZYPageControl</li>\n<li>为ZYPageControl类添加<code>currentPage</code>、<code>numberOfPages</code>等PageControl控件常用的属性</li>\n<li>添加设置图片的方法</li>\n<li>在<code>- (void)layoutSubviews</code>方法里 绘制pageControl</li>\n</ol>\n<h3 id=\"支持功能\"><a href=\"#支持功能\" class=\"headerlink\" title=\"支持功能\"></a>支持功能</h3><ul>\n<li>设置PageControl的默认图和高亮图</li>\n<li>灵活设置PageControl间距</li>\n<li>灵活设置PageControl的大小</li>\n<li>灵活设置PageControl的位置</li>\n</ul>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"手动集成\"><a href=\"#手动集成\" class=\"headerlink\" title=\"手动集成\"></a>手动集成</h4><ol>\n<li>下载ZYPageControl的代码</li>\n<li>将ZYPageControl类添加到项目中</li>\n<li>与UIPageControl用法一样，创建一个ZYPageControl对象并添加到View上</li>\n<li>设置你想要的图片作为默认图</li>\n<li>设置你想要的PageControl间距</li>\n</ol>\n<h4 id=\"Pod集成\"><a href=\"#Pod集成\" class=\"headerlink\" title=\"Pod集成\"></a>Pod集成</h4><p>等待发布支持~</p>\n","excerpt":"","more":"<p>近期项目中需要给UIPageControl自定义图片，为了方便使用也为了方便大家，建了一个轮子<a href=\"https://github.com/luzhiyongGit/ZYPageControl\">ZYPageControl</a></p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><ol>\n<li>继承至UIView创建一个ZYPageControl</li>\n<li>为ZYPageControl类添加<code>currentPage</code>、<code>numberOfPages</code>等PageControl控件常用的属性</li>\n<li>添加设置图片的方法</li>\n<li>在<code>- (void)layoutSubviews</code>方法里 绘制pageControl</li>\n</ol>\n<h3 id=\"支持功能\"><a href=\"#支持功能\" class=\"headerlink\" title=\"支持功能\"></a>支持功能</h3><ul>\n<li>设置PageControl的默认图和高亮图</li>\n<li>灵活设置PageControl间距</li>\n<li>灵活设置PageControl的大小</li>\n<li>灵活设置PageControl的位置</li>\n</ul>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"手动集成\"><a href=\"#手动集成\" class=\"headerlink\" title=\"手动集成\"></a>手动集成</h4><ol>\n<li>下载ZYPageControl的代码</li>\n<li>将ZYPageControl类添加到项目中</li>\n<li>与UIPageControl用法一样，创建一个ZYPageControl对象并添加到View上</li>\n<li>设置你想要的图片作为默认图</li>\n<li>设置你想要的PageControl间距</li>\n</ol>\n<h4 id=\"Pod集成\"><a href=\"#Pod集成\" class=\"headerlink\" title=\"Pod集成\"></a>Pod集成</h4><p>等待发布支持~</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjlhoqwh70000kj79picqjd8l","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwho000ekj79zfypbvgg"},{"post_id":"cjlhoqwhb0002kj79cjshi6t6","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwht000kkj79kwdp0850"},{"post_id":"cjlhoqwhp000fkj79xgwza4py","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwhv000okj79670s547q"},{"post_id":"cjlhoqwhg0006kj79942cg72h","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwhw000rkj79c1nb1d0u"},{"post_id":"cjlhoqwhj0008kj795hy6ixb5","category_id":"cjlhoqwhu000mkj797646sgzv","_id":"cjlhoqwhz000ykj791t3ol3i7"},{"post_id":"cjlhoqwhw000skj79wg6y0rmj","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwi00013kj79y5r6xywy"},{"post_id":"cjlhoqwi20019kj795v72adjt","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwi6001gkj79tzn05ywo"},{"post_id":"cjlhoqwht000lkj79h7ui4jj4","category_id":"cjlhoqwi20017kj79z1s0vwqk","_id":"cjlhoqwi7001jkj79h86uz0jo"},{"post_id":"cjlhoqwi5001dkj79jn5rr9wg","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwi9001okj798mhgw01m"},{"post_id":"cjlhoqwi7001ikj793z75znx6","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwil001rkj79pgkhxt5p"},{"post_id":"cjlhoqwi8001lkj79a0036q8i","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwio001ykj79q60gddin"},{"post_id":"cjlhoqwi10015kj79xvnvl0bs","category_id":"cjlhoqwi20017kj79z1s0vwqk","_id":"cjlhoqwip0022kj79fm8771be"},{"post_id":"cjlhoqwio0020kj79t30ce8sb","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwit0028kj79dqjumuut"},{"post_id":"cjlhoqwiq0025kj79g0syc31m","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwiv002ckj791edgw0r6"},{"post_id":"cjlhoqwir0027kj795dg18xee","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwiw002fkj79sj6abvrq"},{"post_id":"cjlhoqwj3002xkj79z50567z3","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwj60033kj79phk4f900"},{"post_id":"cjlhoqwj50032kj793fn9z0u1","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwj80039kj79ecwvsww2"},{"post_id":"cjlhoqwj9003ekj7974i1k1jz","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwjc003kkj79ngmlzgmk"},{"post_id":"cjlhoqwjb003jkj79cb4pldbz","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwje003pkj796g4z98o7"},{"post_id":"cjlhoqwjc003mkj796xj59gut","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhoqwjf003rkj796qxcq683"},{"post_id":"cjlhoqwit002bkj7976aqcwvs","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhsxaba0044kj7922p2n75i"},{"post_id":"cjlhoqwj4002zkj796jjqb8hi","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhsy8cz0047kj7908xcqqm9"},{"post_id":"cjlhoqwil001tkj79qhf0uhew","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhsyr3w004akj79i9mic3iv"},{"post_id":"cjlhoqwj8003bkj79xilmy7wh","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhsz3u5004ckj79uk1zkpsz"},{"post_id":"cjlhoqwiy002lkj79qdz7ipe4","category_id":"cjlht09aw004dkj79s4th872p","_id":"cjlht09az004ekj79lh4a10x5"},{"post_id":"cjlhoqwi9001qkj790v6p1vo9","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht0lrs004gkj79yjykkp27"},{"post_id":"cjlhoqwi00012kj790mkj9wrm","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht1aao004ikj7954c1il79"},{"post_id":"cjlhoqwi3001bkj79qhx9n4hi","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht1lsj004kkj7998l9qbud"},{"post_id":"cjlhoqwhs000jkj79wc53ibf2","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht2d4w004mkj79s7uc8tf6"},{"post_id":"cjlhoqwj2002tkj79099qu2rk","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht30lm004nkj79ko1om7v5"},{"post_id":"cjlhoqwja003gkj79i7o40tz0","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht4tlq004pkj79lymcd2y3"},{"post_id":"cjlhoqwhy000vkj79m85k45di","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlht5ic9004skj79coyoyhmd"},{"post_id":"cjlhoqwj1002rkj79gwy5i3gx","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhta2ui005akj794r703uz2"},{"post_id":"cjlhoqwhv000qkj79n7ztt8u1","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhtd1f1005hkj795flbjv1q"},{"post_id":"cjlhoqwhv000qkj79n7ztt8u1","category_id":"cjlhtd1ez005ekj796etnhon7","_id":"cjlhtd1f1005ikj79qehdkqw5"},{"post_id":"cjlhoqwiv002ekj79vdjzdnx7","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhtf6su005pkj79m1ev1rd8"},{"post_id":"cjlhoqwiz002nkj79ka96zc0i","category_id":"cjlht09aw004dkj79s4th872p","_id":"cjlhtfvjd005rkj79c4euyzwh"},{"post_id":"cjlhoqwhn000dkj793xue9kv0","category_id":"cjlht09aw004dkj79s4th872p","_id":"cjlhth2ur005skj79sg60ativ"},{"post_id":"cjlhoqwiw002hkj79qbzkvcnv","category_id":"cjlht09aw004dkj79s4th872p","_id":"cjlhthhy7005ukj79q7uv6kzd"},{"post_id":"cjlhoqwin001xkj79nh7dqh5f","category_id":"cjlht09aw004dkj79s4th872p","_id":"cjlhthyxq005vkj79hq1ncj96"},{"post_id":"cjlhoqwj60035kj79zfgpg6qm","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhtjki10061kj792uzyxf52"},{"post_id":"cjlhoqwhk0009kj79tww0y47x","category_id":"cjlht09aw004dkj79s4th872p","_id":"cjlhtjwxc0063kj79qsp0eakz"},{"post_id":"cjlhoqwj70038kj79xxgw5dcp","category_id":"cjlhoqwhd0004kj79xfgubvoc","_id":"cjlhtmv000068kj79ni96o2oo"}],"PostTag":[{"post_id":"cjlhoqwhj0008kj795hy6ixb5","tag_id":"cjlhoqwhu000nkj7930p9pu2o","_id":"cjlhoqwhy000wkj79ss2smb32"},{"post_id":"cjlhoqwhn000dkj793xue9kv0","tag_id":"cjlhoqwi00011kj79bip493h7","_id":"cjlhoqwi3001akj79tplp1qf7"},{"post_id":"cjlhoqwhp000fkj79xgwza4py","tag_id":"cjlhoqwi20018kj7958pmlrha","_id":"cjlhoqwi6001hkj79yv12srhw"},{"post_id":"cjlhoqwi20019kj795v72adjt","tag_id":"cjlhoqwj2002ukj79eghnqrei","_id":"cjlhoqwj8003akj79jiyfot7s"},{"post_id":"cjlhoqwiw002hkj79qbzkvcnv","tag_id":"cjlhoqwjb003hkj792jl1wbym","_id":"cjlhoqwji003zkj79w3obcdrh"},{"post_id":"cjlhoqwiz002nkj79ka96zc0i","tag_id":"cjlhoqwjb003hkj792jl1wbym","_id":"cjlhoqwjj0041kj79y1r3zn3x"},{"post_id":"cjlhoqwjb003jkj79cb4pldbz","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhoqwjj0042kj79wf7jrph8"},{"post_id":"cjlhoqwi9001qkj790v6p1vo9","tag_id":"cjlhsy8cx0046kj79qk2mrwab","_id":"cjlht0lrs004fkj79vq9wjzux"},{"post_id":"cjlhoqwhy000vkj79m85k45di","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlht5ic9004rkj79o8mdh2t3"},{"post_id":"cjlhoqwit002bkj7976aqcwvs","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht5o5a004ukj79urdwmb3j"},{"post_id":"cjlhoqwj4002zkj796jjqb8hi","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht5y44004vkj79ubrdvwjq"},{"post_id":"cjlhoqwil001tkj79qhf0uhew","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht66yh004wkj79psne7rrc"},{"post_id":"cjlhoqwj8003bkj79xilmy7wh","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht6dir004xkj793ighouye"},{"post_id":"cjlhoqwi00012kj790mkj9wrm","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlht6yrb004ykj79aurw37c7"},{"post_id":"cjlhoqwi3001bkj79qhx9n4hi","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht75z1004zkj791ulyfcty"},{"post_id":"cjlhoqwhs000jkj79wc53ibf2","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht7bt80050kj79v0fd252f"},{"post_id":"cjlhoqwj2002tkj79099qu2rk","tag_id":"cjlht7ljn0051kj79u01q7eie","_id":"cjlht7ljn0052kj79mod5qgcd"},{"post_id":"cjlhoqwja003gkj79i7o40tz0","tag_id":"cjlht7ljn0051kj79u01q7eie","_id":"cjlht7t1c0053kj79ztasscgk"},{"post_id":"cjlhoqwhp000fkj79xgwza4py","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlht8plo0055kj7980tpxntu"},{"post_id":"cjlhoqwhp000fkj79xgwza4py","tag_id":"cjlht8pln0054kj79761ha0bt","_id":"cjlht8plo0056kj79e4zuh1xd"},{"post_id":"cjlhoqwio0020kj79t30ce8sb","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlht946n0057kj79znpby499"},{"post_id":"cjlhoqwi20019kj795v72adjt","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlht9qvf0058kj79yr8bl71v"},{"post_id":"cjlhoqwj1002rkj79gwy5i3gx","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhta2uh0059kj79nwreiym8"},{"post_id":"cjlhoqwhg0006kj79942cg72h","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtb0ml005bkj7926aolrc0"},{"post_id":"cjlhoqwjc003mkj796xj59gut","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhtbpoo005ckj799pacclpe"},{"post_id":"cjlhoqwhv000qkj79n7ztt8u1","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtd1f1005fkj79b7dl9vgl"},{"post_id":"cjlhoqwhv000qkj79n7ztt8u1","tag_id":"cjlhtd1ez005dkj7921kgvi4f","_id":"cjlhtd1f1005gkj79z5uix1hz"},{"post_id":"cjlhoqwiq0025kj79g0syc31m","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhtdmxg005jkj79ur0g342y"},{"post_id":"cjlhoqwi7001ikj793z75znx6","tag_id":"cjlht7ljn0051kj79u01q7eie","_id":"cjlhte7gn005lkj79b2edg1jm"},{"post_id":"cjlhoqwhw000skj79wg6y0rmj","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtehud005mkj799skvp60o"},{"post_id":"cjlhoqwh70000kj79picqjd8l","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtev41005nkj79kmjtpphi"},{"post_id":"cjlhoqwiv002ekj79vdjzdnx7","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhtf6st005okj79o4hch9gp"},{"post_id":"cjlhoqwir0027kj795dg18xee","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtfgs8005qkj7983jlht2p"},{"post_id":"cjlhoqwj3002xkj79z50567z3","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhtha02005tkj79b9soh2qc"},{"post_id":"cjlhoqwj50032kj793fn9z0u1","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhti9mx005wkj795wwvx8rp"},{"post_id":"cjlhoqwhb0002kj79cjshi6t6","tag_id":"cjlht7ljn0051kj79u01q7eie","_id":"cjlhtiu3q005ykj790ak80l85"},{"post_id":"cjlhoqwi5001dkj79jn5rr9wg","tag_id":"cjlhoqwjh003wkj79f4mdlthd","_id":"cjlhtj7zd005zkj79a5polk1b"},{"post_id":"cjlhoqwj60035kj79zfgpg6qm","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtjki00060kj79tp1epygx"},{"post_id":"cjlhoqwhk0009kj79tww0y47x","tag_id":"cjlhoqwjb003hkj792jl1wbym","_id":"cjlhtjwxc0062kj79c5l2u5ad"},{"post_id":"cjlhoqwi8001lkj79a0036q8i","tag_id":"cjlht5o57004tkj79vmdsdrpm","_id":"cjlhtlxuj0064kj79kld9yo1i"},{"post_id":"cjlhoqwht000lkj79h7ui4jj4","tag_id":"cjlhtmh0y0065kj79s1kdgh6s","_id":"cjlhtmh100066kj79a9c2ioq8"},{"post_id":"cjlhoqwj70038kj79xxgw5dcp","tag_id":"cjlht7ljn0051kj79u01q7eie","_id":"cjlhtmuzy0067kj79f3zacco1"},{"post_id":"cjlhoqwj9003ekj7974i1k1jz","tag_id":"cjlht7ljn0051kj79u01q7eie","_id":"cjlhtn2ax0069kj79i0n15ign"}],"Tag":[{"name":"iOS小积累","_id":"cjlhoqwhg0005kj79ne98rjcl"},{"name":"Bootstrap","_id":"cjlhoqwhu000nkj7930p9pu2o"},{"name":"Hexo","_id":"cjlhoqwhx000ukj79fvx7qmug"},{"name":"Markdown","_id":"cjlhoqwi00011kj79bip493h7"},{"name":"epub","_id":"cjlhoqwi20018kj7958pmlrha"},{"name":"iOS","_id":"cjlhoqwi6001fkj79givhkufk"},{"name":"ReactNative","_id":"cjlhoqwi8001nkj7933aib794"},{"name":"Secret","_id":"cjlhoqwin001ukj79az6ojtao"},{"name":"Java","_id":"cjlhoqwit0029kj79vpmorqwh"},{"name":"Swift","_id":"cjlhoqwj2002ukj79eghnqrei"},{"name":"Git入门","_id":"cjlhoqwj70036kj797mw44r65"},{"name":"iOS11","_id":"cjlhoqwj9003ckj79l9oi9b9s"},{"name":"博客","_id":"cjlhoqwjb003hkj792jl1wbym"},{"name":"小积累","_id":"cjlhoqwjd003okj79mnaixsgi"},{"name":"iOS进阶","_id":"cjlhoqwjh003wkj79f4mdlthd"},{"name":"iOS基础知识","_id":"cjlhsxab90043kj79iam9hy6z"},{"name":"iOS技术方案","_id":"cjlhsy8cx0046kj79qk2mrwab"},{"name":"iOS方案","_id":"cjlht4tlq004okj79ob3hmsuh"},{"name":"iOS基础","_id":"cjlht5o57004tkj79vmdsdrpm"},{"name":"iOS技巧","_id":"cjlht7ljn0051kj79u01q7eie"},{"name":"reader","_id":"cjlht8pln0054kj79761ha0bt"},{"name":"加密","_id":"cjlhtd1ez005dkj7921kgvi4f"},{"name":"RN","_id":"cjlhtmh0y0065kj79s1kdgh6s"}]}}