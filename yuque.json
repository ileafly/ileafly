[
  {
    "id": 1887511,
    "slug": "gltpit",
    "title": "弄透Block",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 4,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-06-12T08:41:25.935Z",
      "updated_at": "2019-06-12T08:41:25.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-05-25T14:37:46.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: iOS<br />tags: [原理]\n\n---\n\n\n本文重点：\n\n- Block是什么？\n- 总结Block的使用场景\n- 为什么Block属性需要用copy修饰？\n- __block修饰后为何就可以修改？\n- Block循环引用是怎么产生的？\n\n\n<a name=\"d9d97201\"></a>\n# Block是什么？\n\n> Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数\n\n\n1. 匿名函数\n\n匿名函数是指不带函数名称的函数\n\n2. 带有自动变量\n\n这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态\n\n```objectivec\nint val = 10;\nvoid (^blk)(void) = ^{\n  printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝\n```\n\n3. 为了解决block不能修改自动变量的值，可以使用 `__block` 修饰\n\n```objectivec\n__block int val = 10;\nvoid (^blk)(void) = ^{\n printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是2\n```\n\n\n<a name=\"e3d6ac67\"></a>\n# Block的使用场景\n\n1. 声明Block属性 利用Block属性响应事件或传递数据\n\n> UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调\n> Block回调的思路：\n> 声明一个Block属性，注意这里要用copy。\n> 利用Block属性进行回调\n\n\n2. 方法参数为Block 利用Block实现回调\n\n> 以 `[UIView animateWithDuration:animations:]` 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递\n\n\n3. 链式语法\n\n> 链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用\n\n\n```objectivec\n//  CaculateMaker.h\n//  ChainBlockTestApp\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface CaculateMaker : NSObject\n\n@property (nonatomic, assign) CGFloat result;\n\n/*\n* 返回类型 CaculateMaker\n* 传入参数 CGFloat num\n*/\n- (CaculateMaker *(^)(CGFloat num))add;\n\n@end\n\n\n//  CaculateMaker.m\n//  ChainBlockTestApp\n\n\n#import \"CaculateMaker.h\"\n\n@implementation CaculateMaker\n\n- (CaculateMaker *(^)(CGFloat num))add;{\n    return ^CaculateMaker *(CGFloat num){\n        _result += num;\n        return self;\n    };\n}\n\n@end\n\n// 使用\nCaculateMaker *maker = [[CaculateMaker alloc] init];\nmaker.add(20).add(30);\n```\n\n\n<a name=\"fd60c885\"></a>\n# 为什么Block属性需要用copy修饰？\n\n**因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。**<br />**<br />为何会有这种现象出现？\n\nBlock在内存中的位置分为三种类型：\n\n- **NSGlobalBlock** 是位于全局区的block，它是设置在程序的数据区中。\n- **NSStackBlock** 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。\n- **NSMallocBlock** 是位于堆区，在变量作用域结束时不受影响。\n\n这三种类型对应以下三种情况：\n\n1. Block中没有截获自动变量时Block类型是**NSGlobalBlock**\n1. Block中截获自动变量时Block类型是**NSStackBlock**\n1. 堆中的Block无法直接创建，当对**NSStackBlock**类型的Block进行copy时，会将Block放到堆中，Block类型变为**NSMallocBlock**\n\n当Block类型是**NSStackBlock**时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。\n\n```objectivec\n- (void)click:(id)sender {\n        TestClass *test = [[TestClass alloc] init];\n        \n        __block int a = 1;\n        // 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.weakBlock = ^() {\n            NSLog(@\"ok\");\n            a = 2;\n        };\n        \n        // block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.assignBlock = ^() {\n            NSLog(@\"ok\");\n            a = 3;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.copyBlock = ^() {\n            NSLog(@\"ok\");\n            a = 4;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.strongBlock = ^() {\n            NSLog(@\"ok\");\n            a = 5;\n        };\n        \n        NSLog(@\"copy property: %@\", test.copyBlock);\n        NSLog(@\"assign property: %@\", test.assignBlock);\n        NSLog(@\"weak property: %@\", test.weakBlock);\n        NSLog(@\"strong property: %@\", test.strongBlock);\n        \n        \n        [test start];\n    }\n```\n\n\n<a name=\"7a61fc63\"></a>\n# __block修饰后为何就可以修改局部变量？\n\n首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br />因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。\n\n加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br />定义一个 `__block int a = 10;`  会变成 `__Block_byref_a_0 *a;` <br />`__Block_byref_a_0` 的结构体如下所示：\n\n```objectivec\nstruct __Block_byref_a_0 {\n void *__isa;\n __Block_byref_a_0 *__forwarding; // forwarding指针\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n int a; // 原变量同类型变量\n};\n```\n\n结构体中有一个**forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量->forwarding->原变量同类型变量**\n\n如果在block中直接修改变量的值，实质的过程是新变量->__forwarding->原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。\n\n这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收\n\n总结：<br />**block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。**\n\n\n<a name=\"0eccb7a1\"></a>\n# Block的循环引用是怎么产生的？\n\n我们先看一段block导致循环引用的代码：\n\n```objectivec\nTestClass *test = [[TestClass alloc] init]; \n\ntest.copyBlock = ^() {\n    NSLog(@\"ok: %d\", test.result);\n};\n```\n\n当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br />test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。\n\n并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：\n\n```objectivec\n// self-->requestModel-->block-->self \n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// 虽然存在引用环，但是通过主动释放requestModel打破了循环\n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n    self.requestModel = nil;\n}];\n\n// t-->block-->self 不存在循环引用\nTest *t = [[Test alloc] init];\n\n[t requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// AFNetworking-->block-->self 不存在循环引用\n[AFNetworking requestData:^(NSData *data) {\n    self.name = @\"lealfy\";\n}];\n```\n\n",
    "body_draft": "",
    "body_html": "<p><span>categories: iOS</span></p><p><span>tags: [原理]</span></p><hr /><p><br /></p><p>本文重点：</p><ul><li>Block是什么？</li><li>总结Block的使用场景</li><li>为什么Block属性需要用copy修饰？</li><li>__block修饰后为何就可以修改？</li><li>Block循环引用是怎么产生的？</li></ul><p><br /></p><p><br /></p><h1 id=\"d9d97201\">Block是什么？</h1><p><br /></p><blockquote><p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p></blockquote><p><br /></p><ol start=\"1\"><li>匿名函数</li></ol><p><br /></p><p>匿名函数是指不带函数名称的函数</p><p><br /></p><ol start=\"2\"><li>带有自动变量</li></ol><p><br /></p><p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p><p><br /></p><pre data-lang=\"objectivec\"><code>int val = 10;\nvoid (^blk)(void) = ^{\n  printf(&quot;val=%d\\n&quot;, val);\n};\nval = 2;\nblk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝</code></pre><p><br /></p><ol start=\"3\"><li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li></ol><p><br /></p><pre data-lang=\"objectivec\"><code>__block int val = 10;\nvoid (^blk)(void) = ^{\n printf(&quot;val=%d\\n&quot;, val);\n};\nval = 2;\nblk(); // 这里输出的值是2</code></pre><p><br /></p><p><br /></p><h1 id=\"e3d6ac67\">Block的使用场景</h1><p><br /></p><ol start=\"1\"><li>声明Block属性 利用Block属性响应事件或传递数据</li></ol><p><br /></p><blockquote><p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调</p><p>Block回调的思路：</p><p>声明一个Block属性，注意这里要用copy。</p><p>利用Block属性进行回调</p></blockquote><p><br /></p><ol start=\"2\"><li>方法参数为Block 利用Block实现回调</li></ol><p><br /></p><blockquote><p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p></blockquote><p><br /></p><ol start=\"3\"><li>链式语法</li></ol><p><br /></p><blockquote><p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p></blockquote><p><br /></p><pre data-lang=\"objectivec\"><code>//  CaculateMaker.h\n//  ChainBlockTestApp\n\n#import &lt;Foundation/Foundation.h&gt;\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface CaculateMaker : NSObject\n\n@property (nonatomic, assign) CGFloat result;\n\n/*\n* 返回类型 CaculateMaker\n* 传入参数 CGFloat num\n*/\n- (CaculateMaker *(^)(CGFloat num))add;\n\n@end\n\n\n//  CaculateMaker.m\n//  ChainBlockTestApp\n\n\n#import &quot;CaculateMaker.h&quot;\n\n@implementation CaculateMaker\n\n- (CaculateMaker *(^)(CGFloat num))add;{\n    return ^CaculateMaker *(CGFloat num){\n        _result += num;\n        return self;\n    };\n}\n\n@end\n\n// 使用\nCaculateMaker *maker = [[CaculateMaker alloc] init];\nmaker.add(20).add(30);</code></pre><p><br /></p><p><br /></p><h1 id=\"fd60c885\">为什么Block属性需要用copy修饰？</h1><p><br /></p><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong></p><p>**</p><p>为何会有这种现象出现？</p><p><br /></p><p>Block在内存中的位置分为三种类型：</p><p><br /></p><ul><li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li><li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li><li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li></ul><p><br /></p><p>这三种类型对应以下三种情况：</p><p><br /></p><ol start=\"1\"><li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li><li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li><li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li></ol><p><br /></p><p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p><p><br /></p><pre data-lang=\"objectivec\"><code>- (void)click:(id)sender {\n        TestClass *test = [[TestClass alloc] init];\n        \n        __block int a = 1;\n        // 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.weakBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 2;\n        };\n        \n        // block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.assignBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 3;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.copyBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 4;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.strongBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 5;\n        };\n        \n        NSLog(@&quot;copy property: %@&quot;, test.copyBlock);\n        NSLog(@&quot;assign property: %@&quot;, test.assignBlock);\n        NSLog(@&quot;weak property: %@&quot;, test.weakBlock);\n        NSLog(@&quot;strong property: %@&quot;, test.strongBlock);\n        \n        \n        [test start];\n    }</code></pre><p><br /></p><p><br /></p><h1 id=\"7a61fc63\">__block修饰后为何就可以修改局部变量？</h1><p><br /></p><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？</p><p>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p><p><br /></p><p>加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：</p><p>定义一个 <code>__block int a = 10;</code>  会变成 <code>__Block_byref_a_0 *a;</code> </p><p><code>__Block_byref_a_0</code> 的结构体如下所示：</p><p><br /></p><pre data-lang=\"objectivec\"><code>struct __Block_byref_a_0 {\n void *__isa;\n __Block_byref_a_0 *__forwarding; // forwarding指针\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n int a; // 原变量同类型变量\n};</code></pre><p><br /></p><p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p><p><br /></p><p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p><p><br /></p><p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p><p><br /></p><p>总结：</p><p><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。</strong><strong>无论在block内外，都是通过forwarding来访问的</strong><strong>。</strong></p><p><br /></p><p><br /></p><h1 id=\"0eccb7a1\">Block的循环引用是怎么产生的？</h1><p><br /></p><p>我们先看一段block导致循环引用的代码：</p><p><br /></p><pre data-lang=\"objectivec\"><code>TestClass *test = [[TestClass alloc] init]; \n\ntest.copyBlock = ^() {\n    NSLog(@&quot;ok: %d&quot;, test.result);\n};</code></pre><p><br /></p><p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。</p><p>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p><p><br /></p><p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p><p><br /></p><pre data-lang=\"objectivec\"><code>// self--&gt;requestModel--&gt;block--&gt;self \n[self.requestModel requestData:^(NSData *data) {\n    self.name = @&quot;leafly&quot;;\n}];\n\n// 虽然存在引用环，但是通过主动释放requestModel打破了循环\n[self.requestModel requestData:^(NSData *data) {\n    self.name = @&quot;leafly&quot;;\n    self.requestModel = nil;\n}];\n\n// t--&gt;block--&gt;self 不存在循环引用\nTest *t = [[Test alloc] init];\n\n[t requestData:^(NSData *data) {\n    self.name = @&quot;leafly&quot;;\n}];\n\n// AFNetworking--&gt;block--&gt;self 不存在循环引用\n[AFNetworking requestData:^(NSData *data) {\n    self.name = @&quot;lealfy&quot;;\n}];</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><p><span>categories: iOS</span></p><p><span>tags: [原理<cursor />]</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22zW4A2%22%7D\"></card><p><br /></p><p>本文重点：</p><ul><li>Block是什么？</li><li>总结Block的使用场景</li><li>为什么Block属性需要用copy修饰？</li><li>__block修饰后为何就可以修改？</li><li>Block循环引用是怎么产生的？</li></ul><p><br /></p><p><br /></p><h1 id=\"d9d97201\">Block是什么？</h1><p><br /></p><blockquote><p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p></blockquote><p><br /></p><ol start=\"1\"><li>匿名函数</li></ol><p><br /></p><p>匿名函数是指不带函数名称的函数</p><p><br /></p><ol start=\"2\"><li>带有自动变量</li></ol><p><br /></p><p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22fc149395%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22int%20val%20%3D%2010%3B%5Cnvoid%20(%5Eblk)(void)%20%3D%20%5E%7B%5Cn%20%20printf(%5C%22val%3D%25d%5C%5Cn%5C%22%2C%20val)%3B%5Cn%7D%3B%5Cnval%20%3D%202%3B%5Cnblk()%3B%20%2F%2F%20%E8%BF%99%E9%87%8C%E8%BE%93%E5%87%BA%E7%9A%84%E5%80%BC%E6%98%AF10%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF2%EF%BC%8C%E5%9B%A0%E4%B8%BAblock%E5%9C%A8%E5%AE%9E%E7%8E%B0%E6%97%B6%E5%B0%B1%E4%BC%9A%E5%AF%B9%E5%AE%83%E6%89%80%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A0%88%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%8F%AA%E8%AF%BB%E6%8B%B7%E8%B4%9D%22%7D\"></card><p><br /></p><ol start=\"3\"><li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li></ol><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224e5a1ee6%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22__block%20int%20val%20%3D%2010%3B%5Cnvoid%20(%5Eblk)(void)%20%3D%20%5E%7B%5Cn%20printf(%5C%22val%3D%25d%5C%5Cn%5C%22%2C%20val)%3B%5Cn%7D%3B%5Cnval%20%3D%202%3B%5Cnblk()%3B%20%2F%2F%20%E8%BF%99%E9%87%8C%E8%BE%93%E5%87%BA%E7%9A%84%E5%80%BC%E6%98%AF2%22%7D\"></card><p><br /></p><p><br /></p><h1 id=\"e3d6ac67\">Block的使用场景</h1><p><br /></p><ol start=\"1\"><li>声明Block属性 利用Block属性响应事件或传递数据</li></ol><p><br /></p><blockquote><p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调</p><p>Block回调的思路：</p><p>声明一个Block属性，注意这里要用copy。</p><p>利用Block属性进行回调</p></blockquote><p><br /></p><ol start=\"2\"><li>方法参数为Block 利用Block实现回调</li></ol><p><br /></p><blockquote><p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p></blockquote><p><br /></p><ol start=\"3\"><li>链式语法</li></ol><p><br /></p><blockquote><p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2246df164d%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22%2F%2F%20%20CaculateMaker.h%5Cn%2F%2F%20%20ChainBlockTestApp%5Cn%5Cn%23import%20%3CFoundation%2FFoundation.h%3E%5Cn%23import%20%3CUIKit%2FUIKit.h%3E%5Cn%5Cn%40interface%20CaculateMaker%20%3A%20NSObject%5Cn%5Cn%40property%20(nonatomic%2C%20assign)%20CGFloat%20result%3B%5Cn%5Cn%2F*%5Cn*%20%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%20CaculateMaker%5Cn*%20%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%20CGFloat%20num%5Cn*%2F%5Cn-%20(CaculateMaker%20*(%5E)(CGFloat%20num))add%3B%5Cn%5Cn%40end%5Cn%5Cn%5Cn%2F%2F%20%20CaculateMaker.m%5Cn%2F%2F%20%20ChainBlockTestApp%5Cn%5Cn%5Cn%23import%20%5C%22CaculateMaker.h%5C%22%5Cn%5Cn%40implementation%20CaculateMaker%5Cn%5Cn-%20(CaculateMaker%20*(%5E)(CGFloat%20num))add%3B%7B%5Cn%20%20%20%20return%20%5ECaculateMaker%20*(CGFloat%20num)%7B%5Cn%20%20%20%20%20%20%20%20_result%20%2B%3D%20num%3B%5Cn%20%20%20%20%20%20%20%20return%20self%3B%5Cn%20%20%20%20%7D%3B%5Cn%7D%5Cn%5Cn%40end%5Cn%5Cn%2F%2F%20%E4%BD%BF%E7%94%A8%5CnCaculateMaker%20*maker%20%3D%20%5B%5BCaculateMaker%20alloc%5D%20init%5D%3B%5Cnmaker.add(20).add(30)%3B%22%7D\"></card><p><br /></p><p><br /></p><h1 id=\"fd60c885\">为什么Block属性需要用copy修饰？</h1><p><br /></p><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong></p><p>**</p><p>为何会有这种现象出现？</p><p><br /></p><p>Block在内存中的位置分为三种类型：</p><p><br /></p><ul><li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li><li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li><li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li></ul><p><br /></p><p>这三种类型对应以下三种情况：</p><p><br /></p><ol start=\"1\"><li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li><li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li><li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li></ol><p><br /></p><p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224bf6dc5b%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22-%20(void)click%3A(id)sender%20%7B%5Cn%20%20%20%20%20%20%20%20TestClass%20*test%20%3D%20%5B%5BTestClass%20alloc%5D%20init%5D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20__block%20int%20a%20%3D%201%3B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8Cblock%E7%B1%BB%E5%9E%8B%E6%98%AF__NSStackBlock__%20%20%E5%BD%93TestClass%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E6%97%B6%E5%BF%85%E5%B4%A9%20EXC_BAD_ACCESS%5Cn%20%20%20%20%20%20%20%20test.weakBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%202%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20block%E7%B1%BB%E5%9E%8B%E6%98%AF__NSStackBlock__%20%20%E5%BD%93TestClass%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E6%97%B6%E5%BF%85%E5%B4%A9%20EXC_BAD_ACCESS%5Cn%20%20%20%20%20%20%20%20test.assignBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%203%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20block%E7%B1%BB%E5%9E%8B%E6%98%AF__MallocBlock__%20%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%5Cn%20%20%20%20%20%20%20%20test.copyBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%204%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20block%E7%B1%BB%E5%9E%8B%E6%98%AF__MallocBlock__%20%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%5Cn%20%20%20%20%20%20%20%20test.strongBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%205%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22copy%20property%3A%20%25%40%5C%22%2C%20test.copyBlock)%3B%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22assign%20property%3A%20%25%40%5C%22%2C%20test.assignBlock)%3B%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22weak%20property%3A%20%25%40%5C%22%2C%20test.weakBlock)%3B%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22strong%20property%3A%20%25%40%5C%22%2C%20test.strongBlock)%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%5Btest%20start%5D%3B%5Cn%20%20%20%20%7D%22%7D\"></card><p><br /></p><p><br /></p><h1 id=\"7a61fc63\">__block修饰后为何就可以修改局部变量？</h1><p><br /></p><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？</p><p>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p><p><br /></p><p>加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：</p><p>定义一个 <code>__block int a = 10;</code>  会变成 <code>__Block_byref_a_0 *a;</code> </p><p><code>__Block_byref_a_0</code> 的结构体如下所示：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%226ddb7a54%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22struct%20__Block_byref_a_0%20%7B%5Cn%20void%20*__isa%3B%5Cn%20__Block_byref_a_0%20*__forwarding%3B%20%2F%2F%20forwarding%E6%8C%87%E9%92%88%5Cn%20int%20__flags%3B%5Cn%20int%20__size%3B%5Cn%20void%20(*__Block_byref_id_object_copy)(void*%2C%20void*)%3B%5Cn%20void%20(*__Block_byref_id_object_dispose)(void*)%3B%5Cn%20int%20a%3B%20%2F%2F%20%E5%8E%9F%E5%8F%98%E9%87%8F%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%5Cn%7D%3B%22%7D\"></card><p><br /></p><p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p><p><br /></p><p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p><p><br /></p><p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p><p><br /></p><p>总结：</p><p><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。</strong><strong>无论在block内外，都是通过forwarding来访问的</strong><strong>。</strong></p><p><br /></p><p><br /></p><h1 id=\"0eccb7a1\">Block的循环引用是怎么产生的？</h1><p><br /></p><p>我们先看一段block导致循环引用的代码：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%229d701249%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22TestClass%20*test%20%3D%20%5B%5BTestClass%20alloc%5D%20init%5D%3B%20%5Cn%5Cntest.copyBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20NSLog(%40%5C%22ok%3A%20%25d%5C%22%2C%20test.result)%3B%5Cn%7D%3B%22%7D\"></card><p><br /></p><p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。</p><p>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p><p><br /></p><p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22dde6e65b%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22%2F%2F%20self--%3ErequestModel--%3Eblock--%3Eself%20%5Cn%5Bself.requestModel%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22leafly%5C%22%3B%5Cn%7D%5D%3B%5Cn%5Cn%2F%2F%20%E8%99%BD%E7%84%B6%E5%AD%98%E5%9C%A8%E5%BC%95%E7%94%A8%E7%8E%AF%EF%BC%8C%E4%BD%86%E6%98%AF%E9%80%9A%E8%BF%87%E4%B8%BB%E5%8A%A8%E9%87%8A%E6%94%BErequestModel%E6%89%93%E7%A0%B4%E4%BA%86%E5%BE%AA%E7%8E%AF%5Cn%5Bself.requestModel%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22leafly%5C%22%3B%5Cn%20%20%20%20self.requestModel%20%3D%20nil%3B%5Cn%7D%5D%3B%5Cn%5Cn%2F%2F%20t--%3Eblock--%3Eself%20%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%5CnTest%20*t%20%3D%20%5B%5BTest%20alloc%5D%20init%5D%3B%5Cn%5Cn%5Bt%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22leafly%5C%22%3B%5Cn%7D%5D%3B%5Cn%5Cn%2F%2F%20AFNetworking--%3Eblock--%3Eself%20%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%5Cn%5BAFNetworking%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22lealfy%5C%22%3B%5Cn%7D%5D%3B%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-12T08:40:50.000Z",
    "deleted_at": null,
    "created_at": "2019-06-11T02:18:48.000Z",
    "updated_at": "2019-06-12T08:40:50.000Z",
    "published_at": "2019-06-12T08:40:50.000Z",
    "first_published_at": "2019-06-11T02:19:19.000Z",
    "word_count": 1880,
    "cover": null,
    "description": "categories: iOStags: [原理]本文重点：Block是什么？总结Block的使用场景为什么Block属性需要用copy修饰？__block修饰后为何就可以修改？Block循环引用是怎么产生的？Block是什么？Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1887425,
    "slug": "ms0pw9",
    "title": "xopen快捷脚本",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-07-03T11:35:20.078Z",
      "updated_at": "2019-07-03T11:35:20.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-06-19T06:54:31.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-06-19T06:54:31.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: iOS<br />tags: [教程]\n\n---\n\n自定义xopen快捷脚本，在终端中快速打开项目<br />![xopen.gif](https://cdn.nlark.com/yuque/0/2019/gif/183307/1562028112900-78c7a90a-d135-43da-bda3-a8f633731c6d.gif#align=left&display=inline&height=410&name=xopen.gif&originHeight=410&originWidth=656&size=702849&status=done&width=656)\n<a name=\"dWZuy\"></a>\n#### 详细教程\n\n1. 创建 `xopen` 文件\n1. 编辑 `xopen` 内容\n\n```ruby\n#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts \"Opening  #{proj}\"\n   `open #{proj}`\nelse\n  puts \"No  xcworkspace|xcproj  file  found\"\nend\n```\n\n3. 将 `xopen` 文件移入 `/usr/local/bin` 目录下\n3. 添加权限 `chmod 777 xopen` \n3. 在终端中，cd到项目目录下，执行xopen\n",
    "body_draft": "",
    "body_html": "<p>categories: iOS</p><p>tags: [教程]</p><p><br /></p><hr /><p>自定义xopen快捷脚本，在终端中快速打开项目</p><p><img alt=\"xopen.gif\" title=\"xopen.gif\" src=\"https://cdn.nlark.com/yuque/0/2019/gif/183307/1562028112900-78c7a90a-d135-43da-bda3-a8f633731c6d.gif#align=left&amp;display=inline&amp;height=410&amp;name=xopen.gif&amp;originHeight=410&amp;originWidth=656&amp;size=702849&amp;status=done&amp;width=656\" style=\"max-width: 600px; width: 656px;\" /></p><h4 id=\"dWZuy\">详细教程</h4><ol start=\"1\"><li>创建 <code>xopen</code> 文件</li><li>编辑 <code>xopen</code> 内容</li><p><br /></p></ol><pre data-lang=\"ruby\"><code>#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts &quot;Opening  #{proj}&quot;\n   `open #{proj}`\nelse\n  puts &quot;No  xcworkspace|xcproj  file  found&quot;\nend</code></pre><p><br /></p><ol start=\"3\"><li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下</li><li>添加权限 <code>chmod 777 xopen</code> </li><li>在终端中，cd到项目目录下，执行xopen</li></ol>",
    "body_lake": "<!doctype lake><p>categories: iOS</p><p>tags: [教程]</p><p><br /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22uNSGD%22%7D\"></card><p>自定义xopen快捷脚本，在终端中快速打开项目</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fgif%2F183307%2F1562028112900-78c7a90a-d135-43da-bda3-a8f633731c6d.gif%22%2C%22originWidth%22%3A656%2C%22originHeight%22%3A410%2C%22name%22%3A%22xopen.gif%22%2C%22size%22%3A702849%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A656%2C%22height%22%3A410%7D\"></card><cursor /></p><h4 id=\"dWZuy\">详细教程</h4><ol start=\"1\"><li>创建 <code>xopen</code> 文件</li><li>编辑 <code>xopen</code> 内容</li><p><br /></p></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22%23!%2Fusr%2Fbin%2Fenv%20ruby%5Cnrequire%20'shellwords'%5Cn%5Cnproj%20%3D%20Dir%5B'*.xcworkspace'%5D.first%5Cnproj%20%3D%20Dir%5B'*.xcodeproj'%5D.first%20unless%20proj%5Cn%5Cnif%20proj%5Cn%20%20%20puts%20%5C%22Opening%20%20%23%7Bproj%7D%5C%22%5Cn%20%20%20%60open%20%23%7Bproj%7D%60%5Cnelse%5Cn%20%20puts%20%5C%22No%20%20xcworkspace%7Cxcproj%20%20file%20%20found%5C%22%5Cnend%22%2C%22id%22%3A%22LzAlp%22%7D\"></card><p><br /></p><ol start=\"3\"><li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下</li><li>添加权限 <code>chmod 777 xopen</code> </li><li>在终端中，cd到项目目录下，执行xopen</li></ol>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-02T00:42:18.000Z",
    "deleted_at": null,
    "created_at": "2019-06-11T02:10:16.000Z",
    "updated_at": "2019-07-02T00:42:18.000Z",
    "published_at": "2019-07-02T00:42:18.000Z",
    "first_published_at": "2019-06-11T02:17:45.000Z",
    "word_count": 108,
    "cover": null,
    "description": "categories: iOStags: [教程]自定义xopen快捷脚本，在终端中快速打开项目详细教程创建 xopen 文件编辑 xopen 内容#!/usr/bin/env ruby require 'shellwords'  proj = Dir['*.xcworkspace'].fir...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 959531,
    "slug": "nhbulg",
    "title": "Github+Hexo搭建个人博客详细教程",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-07-03T11:45:22.078Z",
      "updated_at": "2019-07-03T11:45:22.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-06-19T06:54:31.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-06-19T06:54:31.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Hexo<br />tags: [教程]\n\n---\n\n<a name=\"sl6tws\"></a>\n#### [](#sl6tws)安装Node.js\n\n1. 安装nvm\n\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n\n2. 安装node\n\n```powershell\n$ nvm install node\n```\n\n3. 验证node是否安装成功\n\n```powershell\n$  node -v\n$  v8.12.0\n```\n<a name=\"t8a8gr\"></a>\n#### [](#t8a8gr)安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n<a name=\"ua2lyy\"></a>\n#### [](#ua2lyy)Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n<a name=\"oefdft\"></a>\n#### [](#oefdft)配置_config.yml\n```\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n<a name=\"s6t5gs\"></a>\n#### [](#s6t5gs)编写博客\n```\n$ hexo new post '文章标题'\n```\n在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n<a name=\"ybauhr\"></a>\n#### [](#ybauhr)推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n<a name=\"padgfi\"></a>\n#### [](#padgfi)多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n\n1. 新建分支 hexo\n\n2. 在设置里将hexo设置为默认分支\n\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n\n<a name=\"xhgmdd\"></a>\n#### [](#xhgmdd)绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n\n1. 购买域名\n\n\n     一般去阿里云购买，具体流程网上很多，就不再细说\n\n2. 配置DNS地址\n\n\n     在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n\n3. 配置hexo文件\n\n\n     在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n\n4. 发布到github\n\n\n我的博客地址是[http://blog.ileafly.com](http://blog.ileafly.com)\n<a name=\"yst3oh\"></a>\n#### [](#yst3oh)绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n<a name=\"qvkuep\"></a>\n#### [](#qvkuep)自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。<br />我比较喜欢的主题是[maupassant](https://github.com/tufu9441/maupassant-hexo)，这里就以[maupassant](https://github.com/tufu9441/maupassant-hexo)为例简述一下集成的流程。\n```shell\n# 安装\n$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant\n$ npm install hexo-renderer-pug --save\n$ npm install hexo-renderer-sass --save\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `maupassant`\n# 更多的配置信息可以参考ReadMe\n```\n<a name=\"ctisce\"></a>\n#### [](#ctisce)集成评论\nGittalk是基于Github issues开发的评论系统，每一篇文章对应一个issues，issues里面的评论对应文章的评论，这样对于利用GitHub搭建的博客来说简直是完美的搭配。\n\n1. 创建一个OAuth Application\n- 访问 [https://github.com/settings/applications/new](https://github.com/settings/applications/new)\n- 随意填写一个Application Name\n- 在Homepage URL一栏填入博客的地址：https://ileafly.github.io\n- 在Authorization callback URL一栏同样填入博客的地址：https://ileafly.github.io\n- 创建应用，得到 `Client ID` 和 `Client Secret` \n2. 修改主题配置，填入 `Client ID` 和 `Client Secret` \n\n```ruby\ngittalk:\n  enable: true ## If you want to use Gitment comment system please set the value to true.\n  owner: ileafly ## Your GitHub ID, e.g. username\n  repo: ileafly.github.io ## The repository to store your comments, make sure you're the repo's owner, e.g. imsun.github.io\n  client_id: ## GitHub client ID, e.g. 75752dafe7907a897619\n  client_secret: ## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50\n  admin: ileafly\n```\n\n\n",
    "body_draft": "tags: [Hexo]\r\ncategories: 教程\n\n---\n\n#### <a name=\"sl6tws\"></a>安装Node.js\n1. 安装nvm\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n2. 安装node\n```powershell\n$ nvm install node\n```\n3. 验证node是否安装成功\n```powershell\n$  node -v\n$  v8.12.0\n```\n#### <a name=\"t8a8gr\"></a>安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n#### <a name=\"ua2lyy\"></a>Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n#### <a name=\"oefdft\"></a>配置\\_config.yml\n```plain\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n#### <a name=\"s6t5gs\"></a>编写博客\n```plain\n$ hexo new post '文章标题'\n```\n在source/\\_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n#### <a name=\"ybauhr\"></a>推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n#### <a name=\"padgfi\"></a>多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n1. 新建分支 hexo\n2. 在设置里将hexo设置为默认分支\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n#### <a name=\"xhgmdd\"></a>绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n1. 购买域名\n      一般去阿里云购买，具体流程网上很多，就不再细说\n2. 配置DNS地址\n      在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n3. 配置hexo文件\n      在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n4. 发布到github\n我的博客地址是[http://www.ileafly.com](http://www.ileafly.com)\n#### <a name=\"yst3oh\"></a>绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n#### <a name=\"qvkuep\"></a>自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。\n我比较喜欢的主题是[Anisina](https://github.com/haojen/hexo-theme-Anisina)和[cafe](https://github.com/giscafer/hexo-theme-cafe)，这里就以[cafe](https://github.com/giscafer/hexo-theme-cafe)为例简述一下集成的流程。\n```\n# 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml\n```\n#### <a name=\"ctisce\"></a>集成评论\n目前比较好用的评论是[LiveRe](https://www.livere.com)，注册并按照City版，获取uid。在\\_\\_config.yml作如下配置：\n```ruby\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'\n```\n\n\n",
    "body_html": "<p>categories: Hexo</p><p>tags: [教程]</p><hr /><h4 id=\"sl6tws\"><a href=\"#sl6tws\"></a>安装Node.js</h4><ol start=\"1\"><li><p>安装nvm</p></li></ol><pre data-lang=\"powershell\"><code>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</code></pre><ol start=\"2\"><li><p>安装node</p></li></ol><pre data-lang=\"powershell\"><code>$ nvm install node</code></pre><ol start=\"3\"><li><p>验证node是否安装成功</p></li></ol><pre data-lang=\"powershell\"><code>$  node -v\n$  v8.12.0</code></pre><h4 id=\"t8a8gr\"><a href=\"#t8a8gr\"></a>安装Hexo</h4><pre data-lang=\"powershell\"><code>$ npm install -g hexo</code></pre><p>安装完成后，进入一个文件夹，执行</p><pre data-lang=\"powershell\"><code>$ hexo init\n$ npm install hexo --save</code></pre><h4 id=\"ua2lyy\"><a href=\"#ua2lyy\"></a>Github创建个人仓库</h4><p>在Github上创建一个新仓库，并命名为  <code>你的github用户名.github.io</code></p><h4 id=\"oefdft\"><a href=\"#oefdft\"></a>配置_config.yml</h4><pre><code>deploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master</code></pre><h4 id=\"s6t5gs\"><a href=\"#s6t5gs\"></a>编写博客</h4><pre><code>$ hexo new post '文章标题'</code></pre><p>在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。</p><h4 id=\"ybauhr\"><a href=\"#ybauhr\"></a>推送站点</h4><pre data-lang=\"powershell\"><code>$ hexo g\n$ hexo d</code></pre><p>上传成功后，访问<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a></p><hr /><p>接下来再介绍一些进阶用法：</p><h4 id=\"padgfi\"><a href=\"#padgfi\"></a>多台电脑管理hexo博客</h4><p>利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。</p><ol start=\"1\"><li><p>新建分支 hexo</p></li></ol><ol start=\"2\"><li><p>在设置里将hexo设置为默认分支</p></li></ol><ol start=\"3\"><li><p>clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支</p></li></ol><ol start=\"4\"><li><p>新电脑需要重新安装hexo环境，安装完成后clone代码到本地</p></li></ol><h4 id=\"xhgmdd\"><a href=\"#xhgmdd\"></a>绑定个人域名</h4><p>拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程</p><ol start=\"1\"><li><p>购买域名</p></li></ol><p>     一般去阿里云购买，具体流程网上很多，就不再细说</p><ol start=\"2\"><li><p>配置DNS地址</p></li></ol><p>     在阿里云后台配置DNS信息，将<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a>的ip绑定到你想要绑定的域名上</p><ol start=\"3\"><li><p>配置hexo文件</p></li></ol><p>     在source目录下，新建文件，命名为<code>CNAME</code>，填入域名地址。</p><ol start=\"4\"><li><p>发布到github</p></li></ol><p>我的博客地址是<a href=\"http://blog.ileafly.com\" target=\"_blank\">http://blog.ileafly.com</a></p><h4 id=\"yst3oh\"><a href=\"#yst3oh\"></a>绑定语雀管理博客内容</h4><p>可以利用语雀管理博客内容，非常方便，详细流程可参考<a href=\"http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/\" target=\"_blank\">使用语雀管理博客</a>。</p><h4 id=\"qvkuep\"><a href=\"#qvkuep\"></a>自定义主题</h4><p>Hexo有非常非常多的主题，你可以在<a href=\"https://hexo.io/themes/index.html\" target=\"_blank\">Themes | Hexo</a>浏览这些主题，选择你喜欢的主题进行使用。</p><p>我比较喜欢的主题是<a href=\"https://github.com/tufu9441/maupassant-hexo\" target=\"_blank\">maupassant</a>，这里就以<a href=\"https://github.com/tufu9441/maupassant-hexo\" target=\"_blank\">maupassant</a>为例简述一下集成的流程。</p><pre data-lang=\"shell\"><code># 安装\n$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant\n$ npm install hexo-renderer-pug --save\n$ npm install hexo-renderer-sass --save\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `maupassant`\n# 更多的配置信息可以参考ReadMe</code></pre><h4 id=\"ctisce\"><a href=\"#ctisce\"></a>集成评论</h4><p>Gittalk是基于Github issues开发的评论系统，每一篇文章对应一个issues，issues里面的评论对应文章的评论，这样对于利用GitHub搭建的博客来说简直是完美的搭配。</p><ol start=\"1\"><li>创建一个OAuth Application</li></ol><ul><li>访问 <a href=\"https://github.com/settings/applications/new\" target=\"_blank\">https://github.com/settings/applications/new</a></li><li>随意填写一个Application Name</li><li>在Homepage URL一栏填入博客的地址：https://ileafly.github.io</li><li>在Authorization callback URL一栏同样填入博客的地址：<span>https://ileafly.github.io</span></li><li>创建应用，得到 <code>Client ID</code> 和 <code>Client Secret</code> </li></ul><ol start=\"2\"><li>修改主题配置，填入 <code>Client ID</code> 和 <code>Client Secret</code> </li><p><br /></p></ol><pre data-lang=\"ruby\"><code>gittalk:\n  enable: true ## If you want to use Gitment comment system please set the value to true.\n  owner: ileafly ## Your GitHub ID, e.g. username\n  repo: ileafly.github.io ## The repository to store your comments, make sure you're the repo's owner, e.g. imsun.github.io\n  client_id: ## GitHub client ID, e.g. 75752dafe7907a897619\n  client_secret: ## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50\n  admin: ileafly</code></pre><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>categories: Hexo</p><p>tags: [教程]</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22bYRHS%22%7D\"></card><h4 id=\"sl6tws\"><a href=\"#sl6tws\"></a>安装Node.js</h4><ol start=\"1\"><li><p>安装nvm</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22733bb5df%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20curl%20-o-%20https%3A%2F%2Fraw.githubusercontent.com%2Fcreationix%2Fnvm%2Fv0.30.2%2Finstall.sh%20%7C%20bash%22%7D\"></card><ol start=\"2\"><li><p>安装node</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%220f36d641%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%C2%A0nvm%20install%20node%22%7D\"></card><ol start=\"3\"><li><p>验证node是否安装成功</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b14a43b3%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20%C2%A0node%20-v%5Cn%24%20%20v8.12.0%22%7D\"></card><h4 id=\"t8a8gr\"><a href=\"#t8a8gr\"></a>安装Hexo</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b6bfcc9b%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20npm%20install%20-g%20hexo%22%7D\"></card><p>安装完成后，进入一个文件夹，执行</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a8df4e5e%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20hexo%20init%5Cn%24%20npm%20install%20hexo%20--save%22%7D\"></card><h4 id=\"ua2lyy\"><a href=\"#ua2lyy\"></a>Github创建个人仓库</h4><p>在Github上创建一个新仓库，并命名为  <code>你的github用户名.github.io</code></p><h4 id=\"oefdft\"><a href=\"#oefdft\"></a>配置_config.yml</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%229f6cd6e3%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%22deploy%3A%5Cn%20%20%20type%3A%20git%5Cn%20%20%20repository%3A%20https%3A%2F%2Fgithub.com%2Fusername%2Fusername.github.io%5Cn%20%20%20branch%3A%20master%22%7D\"></card><h4 id=\"s6t5gs\"><a href=\"#s6t5gs\"></a>编写博客</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%227a38eae7%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%22%24%20hexo%20new%20post%20'%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98'%22%7D\"></card><p>在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。</p><h4 id=\"ybauhr\"><a href=\"#ybauhr\"></a>推送站点</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22690feb80%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20hexo%20g%5Cn%24%20hexo%20d%22%7D\"></card><p>上传成功后，访问<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22Tk3SK%22%7D\"></card><p>接下来再介绍一些进阶用法：</p><h4 id=\"padgfi\"><a href=\"#padgfi\"></a>多台电脑管理hexo博客</h4><p>利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。</p><ol start=\"1\"><li><p>新建分支 hexo</p></li></ol><ol start=\"2\"><li><p>在设置里将hexo设置为默认分支</p></li></ol><ol start=\"3\"><li><p>clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支</p></li></ol><ol start=\"4\"><li><p>新电脑需要重新安装hexo环境，安装完成后clone代码到本地</p></li></ol><h4 id=\"xhgmdd\"><a href=\"#xhgmdd\"></a>绑定个人域名</h4><p>拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程</p><ol start=\"1\"><li><p>购买域名</p></li></ol><p>     一般去阿里云购买，具体流程网上很多，就不再细说</p><ol start=\"2\"><li><p>配置DNS地址</p></li></ol><p>     在阿里云后台配置DNS信息，将<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a>的ip绑定到你想要绑定的域名上</p><ol start=\"3\"><li><p>配置hexo文件</p></li></ol><p>     在source目录下，新建文件，命名为<code>CNAME</code>，填入域名地址。</p><ol start=\"4\"><li><p>发布到github</p></li></ol><p>我的博客地址是<a href=\"http://blog.ileafly.com\" target=\"_blank\">http://blog.ileafly.com</a></p><h4 id=\"yst3oh\"><a href=\"#yst3oh\"></a>绑定语雀管理博客内容</h4><p>可以利用语雀管理博客内容，非常方便，详细流程可参考<a href=\"http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/\" target=\"_blank\">使用语雀管理博客</a>。</p><h4 id=\"qvkuep\"><a href=\"#qvkuep\"></a>自定义主题</h4><p>Hexo有非常非常多的主题，你可以在<a href=\"https://hexo.io/themes/index.html\" target=\"_blank\">Themes | Hexo</a>浏览这些主题，选择你喜欢的主题进行使用。</p><p>我比较喜欢的主题是<a href=\"https://github.com/tufu9441/maupassant-hexo\" target=\"_blank\">maupassant</a>，这里就以<a href=\"https://github.com/tufu9441/maupassant-hexo\" target=\"_blank\">maupassant</a>为例简述一下集成的流程。</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%222ad5521a%22%2C%22code%22%3A%22%23%20%E5%AE%89%E8%A3%85%5Cn%24%20git%20clone%20https%3A%2F%2Fgithub.com%2Ftufu9441%2Fmaupassant-hexo.git%20themes%2Fmaupassant%5Cn%24%20npm%20install%20hexo-renderer-pug%20--save%5Cn%24%20npm%20install%20hexo-renderer-sass%20--save%5Cn%5Cn%23%20%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20%60_config.yml%60%20%E4%B8%BB%E9%A2%98%E5%B1%9E%E6%80%A7%20theme%20%E4%B8%BA%20%60maupassant%60%5Cn%23%20%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83ReadMe%22%2C%22mode%22%3A%22shell%22%7D\"></card><h4 id=\"ctisce\"><a href=\"#ctisce\"></a>集成评论</h4><p>Gittalk是基于Github issues开发的评论系统，每一篇文章对应一个issues，issues里面的评论对应文章的评论，这样对于利用GitHub搭建的博客来说简直是完美的搭配。</p><ol start=\"1\"><li>创建一个OAuth Application</li></ol><ul><li>访问 <a href=\"https://github.com/settings/applications/new\" target=\"_blank\">https://github.com/settings/applications/new</a></li><li>随意填写一个Application Name</li><li>在Homepage URL一栏填入博客的地址：https://ileafly.github.io</li><li>在Authorization callback URL一栏同样填入博客的地址：<span>https://ileafly.github.io</span></li><li>创建应用，得到 <code>Client ID</code> 和 <code>Client Secret</code> </li></ul><ol start=\"2\"><li>修改主题配置，填入 <code>Client ID</code> 和 <code>Client Secret</code> </li><p><br /></p></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22gittalk%3A%5Cn%20%20enable%3A%20true%20%23%23%20If%20you%20want%20to%20use%20Gitment%20comment%20system%20please%20set%20the%20value%20to%20true.%5Cn%20%20owner%3A%20ileafly%20%23%23%20Your%20GitHub%20ID%2C%20e.g.%20username%5Cn%20%20repo%3A%20ileafly.github.io%20%23%23%20The%20repository%20to%20store%20your%20comments%2C%20make%20sure%20you're%20the%20repo's%20owner%2C%20e.g.%20imsun.github.io%5Cn%20%20client_id%3A%20%23%23%20GitHub%20client%20ID%2C%20e.g.%2075752dafe7907a897619%5Cn%20%20client_secret%3A%20%23%23%20GitHub%20client%20secret%2C%20e.g.%20ec2fb9054972c891289640354993b662f4cccc50%5Cn%20%20admin%3A%20ileafly%22%2C%22id%22%3A%22jaXaK%22%7D\"></card><p><br /></p><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-03T11:45:22.000Z",
    "deleted_at": null,
    "created_at": "2018-11-10T01:14:00.000Z",
    "updated_at": "2019-07-03T11:45:22.000Z",
    "published_at": "2019-07-03T11:45:22.000Z",
    "first_published_at": null,
    "word_count": 868,
    "cover": null,
    "description": "categories: Hexotags: [教程]安装Node.js安装nvm$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash安装node$ nvm install no...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 959068,
    "slug": "momb9q",
    "title": "使用语雀管理博客",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 4,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-06-12T08:41:25.935Z",
      "updated_at": "2019-06-12T08:41:25.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-05-25T14:37:46.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Hexo<br />tags: [教程]\n\n---\n\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n<a name=\"x43bcd\"></a>\n#### [](#x43bcd)Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n<a name=\"wgwlfo\"></a>\n#### [](#wgwlfo)安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n\n1. 安装yuque-hexo\n\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n\n4. 同步文章\n\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n<a name=\"ol3liq\"></a>\n#### [](#ol3liq)如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n",
    "body_draft": "tags: [Hexo]\r\ncategories: 教程\n\n---\n\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n#### <a name=\"x43bcd\"></a>Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n#### <a name=\"wgwlfo\"></a>安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n1. 安装yuque-hexo\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n4. 同步文章\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n#### <a name=\"ol3liq\"></a>如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n",
    "body_html": "<p>categories: Hexo</p><p>tags: [教程]</p><hr /><p>之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用<a href=\"https://jaredforsyth.com/hexo-admin/\" target=\"_blank\">hexo-admin</a>，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客<a href=\"https://www.yuque.com/page/luan.ma/yuque2blog\" target=\"_blank\">静态博客使用语雀编辑器</a>，文中介绍了如何利用语雀管理博客，决定一试。</p><p><br /></p><h4 id=\"x43bcd\"><a href=\"#x43bcd\"></a>Hexo搭建博客</h4><p>首先需要先利用<a href=\"https://hexo.io/zh-cn/index.html\" target=\"_blank\">hexo</a>搭建博客，具体的搭建流程可以参考<a href=\"http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/\" target=\"_blank\">Github+Hexo搭建个人博客详细教程</a></p><p><br /></p><h4 id=\"wgwlfo\"><a href=\"#wgwlfo\"></a>安装语雀插件</h4><p><a href=\"https://github.com/x-cold/yuque-hexo/\" target=\"_blank\">yuque-hexo</a>是一个Node.js环境下的语雀下载器。</p><ol start=\"1\"><li><p>安装yuque-hexo</p></li></ol><ol start=\"2\"><li><p>注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的<a href=\"https://www.yuque.com/leafly/blog\" target=\"_blank\">语雀知识库地址</a></p></li></ol><ol start=\"3\"><li><p>在Hexo博客的目录下面找到package.json文件，进入如下配置：</p></li></ol><pre data-lang=\"json\"><code>{\n&quot;name&quot;: &quot;hexo-blog&quot;, // 这里一般原来就有，直接添加下面的内容即可\n&quot;yuqueConfig&quot;: {\n    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,\n    &quot;login&quot;: &quot;leafly&quot;,\n    &quot;repo&quot;: &quot;blog&quot;,\n    &quot;postPath&quot;: &quot;source/_posts/yuque&quot;\n  },\n}</code></pre><ol start=\"4\"><li><p>同步文章</p></li></ol><pre data-lang=\"powershell\"><code>$ yuque-hexo sync</code></pre><p>执行完毕，会自动将语雀上的文章同步到<code>source/_post/yuque</code>文件夹下</p><pre data-lang=\"powershell\"><code>$ hexo g\n$ hexo d</code></pre><p>将博客内容同步到github。</p><p><br /></p><h4 id=\"ol3liq\"><a href=\"#ol3liq\"></a>如何添加分类、标签、创建时间</h4><p>插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息</p><pre data-lang=\"makedown\"><code>tags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50</code></pre><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>categories: Hexo</p><p>tags: [教程]<cursor /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22sxSd1%22%7D\"></card><p>之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用<a href=\"https://jaredforsyth.com/hexo-admin/\" target=\"_blank\">hexo-admin</a>，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客<a href=\"https://www.yuque.com/page/luan.ma/yuque2blog\" target=\"_blank\">静态博客使用语雀编辑器</a>，文中介绍了如何利用语雀管理博客，决定一试。</p><p><br /></p><h4 id=\"x43bcd\"><a href=\"#x43bcd\"></a>Hexo搭建博客</h4><p>首先需要先利用<a href=\"https://hexo.io/zh-cn/index.html\" target=\"_blank\">hexo</a>搭建博客，具体的搭建流程可以参考<a href=\"http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/\" target=\"_blank\">Github+Hexo搭建个人博客详细教程</a></p><p><br /></p><h4 id=\"wgwlfo\"><a href=\"#wgwlfo\"></a>安装语雀插件</h4><p><a href=\"https://github.com/x-cold/yuque-hexo/\" target=\"_blank\">yuque-hexo</a>是一个Node.js环境下的语雀下载器。</p><ol start=\"1\"><li><p>安装yuque-hexo</p></li></ol><ol start=\"2\"><li><p>注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的<a href=\"https://www.yuque.com/leafly/blog\" target=\"_blank\">语雀知识库地址</a></p></li></ol><ol start=\"3\"><li><p>在Hexo博客的目录下面找到package.json文件，进入如下配置：</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22f584b4cd%22%2C%22mode%22%3A%22json%22%2C%22code%22%3A%22%7B%5Cn%5C%22name%5C%22%3A%20%5C%22hexo-blog%5C%22%2C%20%2F%2F%20%E8%BF%99%E9%87%8C%E4%B8%80%E8%88%AC%E5%8E%9F%E6%9D%A5%E5%B0%B1%E6%9C%89%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E5%8D%B3%E5%8F%AF%5Cn%5C%22yuqueConfig%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22baseUrl%5C%22%3A%20%5C%22https%3A%2F%2Fwww.yuque.com%2Fapi%2Fv2%5C%22%2C%5Cn%20%20%20%20%5C%22login%5C%22%3A%20%5C%22leafly%5C%22%2C%5Cn%20%20%20%20%5C%22repo%5C%22%3A%20%5C%22blog%5C%22%2C%5Cn%20%20%20%20%5C%22postPath%5C%22%3A%20%5C%22source%2F_posts%2Fyuque%5C%22%5Cn%20%20%7D%2C%5Cn%7D%22%7D\"></card><ol start=\"4\"><li><p>同步文章</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%228a3b6a0e%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20yuque-hexo%20sync%22%7D\"></card><p>执行完毕，会自动将语雀上的文章同步到<code>source/_post/yuque</code>文件夹下</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22690feb80%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20hexo%20g%5Cn%24%20hexo%20d%22%7D\"></card><p>将博客内容同步到github。</p><p><br /></p><h4 id=\"ol3liq\"><a href=\"#ol3liq\"></a>如何添加分类、标签、创建时间</h4><p>插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22bbb5f6e4%22%2C%22mode%22%3A%22makedown%22%2C%22code%22%3A%22tags%3A%20%5BHexo%5D%5Cncategories%3A%20%E6%95%99%E7%A8%8B%5Cndate%3A%202018-10-10%2015%3A43%3A50%22%7D\"></card><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-12T08:41:25.000Z",
    "deleted_at": null,
    "created_at": "2018-11-09T12:43:26.000Z",
    "updated_at": "2019-06-12T08:41:25.000Z",
    "published_at": "2019-06-12T08:41:25.000Z",
    "first_published_at": null,
    "word_count": 408,
    "cover": null,
    "description": "categories: Hexotags: [教程]之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用hexo-admin，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 2020195,
    "slug": "nvsxd7",
    "title": "阅读器翻页动画优化总结",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-07-03T11:35:20.078Z",
      "updated_at": "2019-07-03T11:35:20.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-06-19T06:54:31.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-06-19T06:54:31.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "最近在优化阅读器的翻页方式，我们阅读器支持仿真翻页、覆盖翻页和无动画翻页三种翻页模式，仿真翻页和无动画翻页是使用系统的 `UIPageViewController` 实现的，覆盖翻页是使用邓泽淼开源的[DZMCoverAnimation](https://github.com/dengzemiao/DZMCoverAnimation)实现的。\n\n在 `DZMCoverAnimation` 中，使用 `[UIView animationWithDuration:animations:completion:]` 实现覆盖翻页的过渡动画。根据[苹果的官方文档](https://developer.apple.com/documentation/uikit/uiview/1622515-animatewithduration?language=objc) `animationWithDuration:animations:completion:` 方法在执行动画的过程中，会使所有的用户手势都会暂时性失效。\n\n近期我们有个需求，需要实现覆盖翻页模式下的快速翻页效果即用户快速点击都能触发覆盖翻页效果。使用   `animationWithDuration:animations:completion:`  方法显然已经不能满足这个需求，这时候就需要使用 `CAAnimation` 来实现动画效果。\n\n因为 `Core Animation` 动画的执行过程都是在后台，所以不会阻塞主线程。\n\n所以这里我们利用 `CABasicAnimation` 来替代 `animationWithDuration:animations:completion:` 实现过渡动画。\n\n<a name=\"qn836\"></a>\n#### CABasicAnimation的用法\n使用 `animationWithKeyPath:` 对CABasicAnimation进行实例化，通过传入指定的keyPath字符串，指名具体的动画的方式，下面是动画过程一些相关属性的说明。\n\n| 属性 | 说明 |\n| --- | --- |\n| duration | 动画的时长 |\n| repeatCount | 重复的次数。不停重复设置为 HUGE_VALF |\n| repeatDuration | 设置动画的时间。在该时间内动画一直执行，不计次数。 |\n| beginTime | 指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式 |\n| timingFunction | 设置动画的速度变化 |\n| autoreverses | 动画结束时是否执行逆动画 |\n| fromValue | 所改变属性的起始值 |\n| toValue | 所改变属性的结束时的值 |\n| byValue | 所改变属性相同起始值的改变量 |\n\n参考示例：\n```objectivec\nCABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"position.x\"];\nanimation.fromValue = @0;\nanimation.toValue = @100;\nanimation.duration = 0.3;\n[self.view.layer addAnimation:animation forKey:@\"layer.position\"];\n```\n\n<a name=\"ypmaa\"></a>\n#### 防止动画结束后回到初始状态\n`CABasicAnimation` 执行完动画后，默认会恢复到初始状态，这是因为我们给一个视图添加动画时，真正移动的并不是视图本身，而是presentation layer的一个缓存，动画开始时，presentation layer开始移动，原始layer隐藏，动画结束时，presentation layer从屏幕上移除，原始layer显示。这也就是视图在动画结束后又恢复到原始状态的原因。\n\n要想防止动画结束后回到初始状态，可以设置 `fillMode = kCAFillModeForwards` 和 `removedOnCompletion = NO` 。这是因为 `kCAFillModeForwards` 表示动画结束后layer的状态保持在动画的最后一帧， `removedOnCompletion = NO` 表示动画结束后presentation layer不做移除。\n\n最终，结合上述两点，就可以利用 `CABasicAnimation` 代替`animationWithDuration:animations:completion:` 实现覆盖翻页动画过渡效果。\n",
    "body_draft": "",
    "body_html": "<p>最近在优化阅读器的翻页方式，我们阅读器支持仿真翻页、覆盖翻页和无动画翻页三种翻页模式，仿真翻页和无动画翻页是使用系统的 <code>UIPageViewController</code> 实现的，覆盖翻页是使用邓泽淼开源的<a href=\"https://github.com/dengzemiao/DZMCoverAnimation\" target=\"_blank\">DZMCoverAnimation</a>实现的。</p><p><br /></p><p>在 <code>DZMCoverAnimation</code> 中，使用 <code>[UIView animationWithDuration:animations:completion:]</code> 实现覆盖翻页的过渡动画。根据<a href=\"https://developer.apple.com/documentation/uikit/uiview/1622515-animatewithduration?language=objc\" target=\"_blank\">苹果的官方文档</a> <code>animationWithDuration:animations:completion:</code> 方法在执行动画的过程中，会使所有的用户手势都会暂时性失效。</p><p><br /></p><p>近期我们有个需求，需要实现覆盖翻页模式下的快速翻页效果即用户快速点击都能触发覆盖翻页效果。使用   <code>animationWithDuration:animations:completion:</code>  方法显然已经不能满足这个需求，这时候就需要使用 <code>CAAnimation</code> 来实现动画效果。</p><p><br /></p><p>因为 <code>Core Animation</code> 动画的执行过程都是在后台，所以不会阻塞主线程。</p><p><br /></p><p>所以这里我们利用 <code>CABasicAnimation</code> 来替代 <code>animationWithDuration:animations:completion:</code> 实现过渡动画。</p><p><br /></p><h4 id=\"qn836\">CABasicAnimation的用法</h4><p>使用 <code>animationWithKeyPath:</code> 对CABasicAnimation进行实例化，通过传入指定的keyPath字符串，指名具体的动画的方式，下面是动画过程一些相关属性的说明。</p><table class=\"lake-table\" style=\"width: 723px;\"><colgroup><col width=\"361\"></col><col width=\"361\"></col></colgroup><tr><td>属性</td><td>说明</td></tr><tbody><tr><td>duration</td><td>动画的时长</td></tr><tr><td>repeatCount</td><td>重复的次数。不停重复设置为 HUGE_VALF</td></tr><tr><td>repeatDuration</td><td>设置动画的时间。在该时间内动画一直执行，不计次数。</td></tr><tr><td>beginTime</td><td>指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式</td></tr><tr><td>timingFunction</td><td>设置动画的速度变化</td></tr><tr><td>autoreverses</td><td>动画结束时是否执行逆动画</td></tr><tr><td>fromValue</td><td>所改变属性的起始值</td></tr><tr><td>toValue</td><td>所改变属性的结束时的值</td></tr><tr><td>byValue</td><td>所改变属性相同起始值的改变量</td></tr></tbody></table><p>参考示例：</p><pre data-lang=\"objectivec\"><code>CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;position.x&quot;];\nanimation.fromValue = @0;\nanimation.toValue = @100;\nanimation.duration = 0.3;\n[self.view.layer addAnimation:animation forKey:@&quot;layer.position&quot;];</code></pre><p><br /></p><h4 id=\"ypmaa\">防止动画结束后回到初始状态</h4><p><code>CABasicAnimation</code> <span class=\"lake-fontsize-11\">执行完动画后，默认会恢复到初始状态，这是因为我们给一个视图添加动画时，真正移动的并不是视图本身，而是</span><span class=\"lake-fontsize-11\" style=\"color: #2F2F2F;\">presentation layer的一个缓存，动画开始时，</span><span class=\"lake-fontsize-11\" style=\"color: #2F2F2F;\">presentation layer开始移动，原始layer隐藏，动画结束时，</span><span class=\"lake-fontsize-11\" style=\"color: #2F2F2F;\">presentation layer从屏幕上移除，原始layer显示。这也就是视图在动画结束后又恢复到原始状态的原因</span><span class=\"lake-fontsize-12\" style=\"color: #2F2F2F;\">。</span></p><p><span class=\"lake-fontsize-12\" style=\"color: #2F2F2F;\"><br /></span></p><p><span class=\"lake-fontsize-11\">要想防止动画结束后回到初始状态，可以设置 </span><span class=\"lake-fontsize-11\"><code><span>fillMode = kCAFillModeForwards</span></code></span><span class=\"lake-fontsize-11\"> 和 </span><span class=\"lake-fontsize-11\"><code>removedOnCompletion = NO</code></span><span class=\"lake-fontsize-11\"> 。这是因为 </span><span class=\"lake-fontsize-11\"><code>kCAFillModeForwards</code></span><span class=\"lake-fontsize-11\"> 表示动画结束后layer的状态保持在动画的最后一帧， </span><span class=\"lake-fontsize-11\"><code>removedOnCompletion = NO</code></span><span class=\"lake-fontsize-11\"> 表示动画结束后presentation layer不做移除。</span></p><p><br /></p><p>最终，结合上述两点，就可以利用 <code>CABasicAnimation</code> 代替<code>animationWithDuration:animations:completion:</code> 实现覆盖翻页动画过渡效果。</p>",
    "body_lake": "<!doctype lake><p>最近在优化阅读器的翻页方式，我们阅读器支持仿真翻页、覆盖翻页和无动画翻页三种翻页模式，仿真翻页和无动画翻页是使用系统的 <code>UIPageViewController</code> 实现的，覆盖翻页是使用邓泽淼开源的<a href=\"https://github.com/dengzemiao/DZMCoverAnimation\" target=\"_blank\">DZMCoverAnimation</a>实现的。</p><p><br /></p><p>在 <code>DZMCoverAnimation</code> 中，使用 <code>[UIView animationWithDuration:animations:completion:]</code> 实现覆盖翻页的过渡动画。根据<a href=\"https://developer.apple.com/documentation/uikit/uiview/1622515-animatewithduration?language=objc\" target=\"_blank\">苹果的官方文档</a> <code>animationWithDuration:animations:completion:</code> 方法在执行动画的过程中，会使所有的用户手势都会暂时性失效。</p><p><br /></p><p>近期我们有个需求，需要实现覆盖翻页模式下的快速翻页效果即用户快速点击都能触发覆盖翻页效果。使用   <code>animationWithDuration:animations:completion:</code>  方法显然已经不能满足这个需求，这时候就需要使用 <code>CAAnimation</code> 来实现动画效果。</p><p><br /></p><p>因为 <code>Core Animation</code> 动画的执行过程都是在后台，所以不会阻塞主线程。</p><p><br /></p><p>所以这里我们利用 <code>CABasicAnimation</code> 来替代 <code>animationWithDuration:animations:completion:</code> 实现过渡动画。</p><p><br /></p><h4 id=\"qn836\">CABasicAnimation的用法</h4><p>使用 <code>animationWithKeyPath:</code> 对CABasicAnimation进行实例化，通过传入指定的keyPath字符串，指名具体的动画的方式，下面是动画过程一些相关属性的说明。</p><card type=\"block\" name=\"table\" value=\"data:%7B%22rows%22%3A10%2C%22cols%22%3A2%2C%22html%22%3A%22%3Ctable%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20723px%3B%5C%22%3E%3Ccolgroup%3E%3Ccol%20span%3D%5C%221%5C%22%20width%3D%5C%22361%5C%22%20%2F%3E%3Ccol%20span%3D%5C%221%5C%22%20width%3D%5C%22361%5C%22%20%2F%3E%3C%2Fcolgroup%3E%3Cthead%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%E5%B1%9E%E6%80%A7%3C%2Ftd%3E%3Ctd%3E%E8%AF%B4%E6%98%8E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Fthead%3E%3Ctbody%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3Eduration%3C%2Ftd%3E%3Ctd%3E%E5%8A%A8%E7%94%BB%E7%9A%84%E6%97%B6%E9%95%BF%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3ErepeatCount%3C%2Ftd%3E%3Ctd%3E%E9%87%8D%E5%A4%8D%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%82%E4%B8%8D%E5%81%9C%E9%87%8D%E5%A4%8D%E8%AE%BE%E7%BD%AE%E4%B8%BA%20HUGE_VALF%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3ErepeatDuration%3C%2Ftd%3E%3Ctd%3E%E8%AE%BE%E7%BD%AE%E5%8A%A8%E7%94%BB%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82%E5%9C%A8%E8%AF%A5%E6%97%B6%E9%97%B4%E5%86%85%E5%8A%A8%E7%94%BB%E4%B8%80%E7%9B%B4%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%B8%8D%E8%AE%A1%E6%AC%A1%E6%95%B0%E3%80%82%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3EbeginTime%3C%2Ftd%3E%3Ctd%3E%E6%8C%87%E5%AE%9A%E5%8A%A8%E7%94%BB%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%BB%B6%E8%BF%9F%E5%87%A0%E7%A7%92%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%AE%BE%E7%BD%AE%E4%B8%BA%E3%80%90CACurrentMediaTime()%20%2B%20%E7%A7%92%E6%95%B0%E3%80%91%20%E7%9A%84%E6%96%B9%E5%BC%8F%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3EtimingFunction%3C%2Ftd%3E%3Ctd%3E%E8%AE%BE%E7%BD%AE%E5%8A%A8%E7%94%BB%E7%9A%84%E9%80%9F%E5%BA%A6%E5%8F%98%E5%8C%96%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3Eautoreverses%3C%2Ftd%3E%3Ctd%3E%E5%8A%A8%E7%94%BB%E7%BB%93%E6%9D%9F%E6%97%B6%E6%98%AF%E5%90%A6%E6%89%A7%E8%A1%8C%E9%80%86%E5%8A%A8%E7%94%BB%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3EfromValue%3C%2Ftd%3E%3Ctd%3E%E6%89%80%E6%94%B9%E5%8F%98%E5%B1%9E%E6%80%A7%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%80%BC%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3EtoValue%3C%2Ftd%3E%3Ctd%3E%E6%89%80%E6%94%B9%E5%8F%98%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%93%E6%9D%9F%E6%97%B6%E7%9A%84%E5%80%BC%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3EbyValue%3C%2Ftd%3E%3Ctd%3E%E6%89%80%E6%94%B9%E5%8F%98%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%90%8C%E8%B5%B7%E5%A7%8B%E5%80%BC%E7%9A%84%E6%94%B9%E5%8F%98%E9%87%8F%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22id%22%3A%22F3h4L%22%7D\"></card><p>参考示例：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22CABasicAnimation%20*animation%20%3D%20%5BCABasicAnimation%20animationWithKeyPath%3A%40%5C%22position.x%5C%22%5D%3B%5Cnanimation.fromValue%20%3D%20%400%3B%5Cnanimation.toValue%20%3D%20%40100%3B%5Cnanimation.duration%20%3D%200.3%3B%5Cn%5Bself.view.layer%20addAnimation%3Aanimation%20forKey%3A%40%5C%22layer.position%5C%22%5D%3B%22%2C%22id%22%3A%225TZ9O%22%7D\"></card><p><br /></p><h4 id=\"ypmaa\">防止动画结束后回到初始状态</h4><p><code>CABasicAnimation</code> <span class=\"lake-fontsize-11\">执行完动画后，默认会恢复到初始状态，这是因为我们给一个视图添加动画时，真正移动的并不是视图本身，而是</span><span class=\"lake-fontsize-11\" style=\"color: #2F2F2F;\">presentation layer的一个缓存，动画开始时，</span><span class=\"lake-fontsize-11\" style=\"color: #2F2F2F;\">presentation layer开始移动，原始layer隐藏，动画结束时，</span><span class=\"lake-fontsize-11\" style=\"color: #2F2F2F;\">presentation layer从屏幕上移除，原始layer显示。这也就是视图在动画结束后又恢复到原始状态的原因</span><span class=\"lake-fontsize-12\" style=\"color: #2F2F2F;\">。</span></p><p><span class=\"lake-fontsize-12\" style=\"color: #2F2F2F;\"><br /></span></p><p><span class=\"lake-fontsize-11\">要想防止动画结束后回到初始状态，可以设置 </span><span class=\"lake-fontsize-11\"><code><span>fillMode = kCAFillModeForwards</span></code></span><span class=\"lake-fontsize-11\"> 和 </span><span class=\"lake-fontsize-11\"><code>removedOnCompletion = NO</code></span><span class=\"lake-fontsize-11\"> 。这是因为 </span><span class=\"lake-fontsize-11\"><code>kCAFillModeForwards</code></span><span class=\"lake-fontsize-11\"> 表示动画结束后layer的状态保持在动画的最后一帧， </span><span class=\"lake-fontsize-11\"><code>removedOnCompletion = NO</code></span><span class=\"lake-fontsize-11\"> 表示动画结束后presentation layer不做移除。</span></p><p><br /></p><p>最终，结合上述两点，就可以利用 <code>CABasicAnimation</code> 代替<code>animationWithDuration:animations:completion:</code> 实现覆盖翻页动画过渡效果。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-02T10:33:43.000Z",
    "deleted_at": null,
    "created_at": "2019-07-02T02:41:07.000Z",
    "updated_at": "2019-07-02T10:40:53.000Z",
    "published_at": "2019-07-02T10:40:53.000Z",
    "first_published_at": "2019-07-02T10:33:43.000Z",
    "word_count": 707,
    "cover": null,
    "description": "最近在优化阅读器的翻页方式，我们阅读器支持仿真翻页、覆盖翻页和无动画翻页三种翻页模式，仿真翻页和无动画翻页是使用系统的 UIPageViewController 实现的，覆盖翻页是使用邓泽淼开源的DZMCoverAnimation实现的。在 DZMCoverAnimation 中，使用 [UI...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 2012366,
    "slug": "ogptry",
    "title": "iOS封装SDK",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-07-03T11:35:20.078Z",
      "updated_at": "2019-07-03T11:35:20.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-06-19T06:54:31.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-06-19T06:54:31.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "日常开发中，我们可能需要封装一些SDK或者使用一些别人封装的SDK。这里总结一下SDK的封装流程。\n\n<a name=\"sH1aJ\"></a>\n## 基本概念\n通常我们遇到的SDK有两种：.framework和.a文件。首先，我们需要弄清楚这两种类型的文件有什么区别。\n\n在讲清楚.framework和.a文件的区别前，我们需要先了解另外两个概念：静态库和动态库。\n\n<a name=\"MsdOd\"></a>\n#### 静态库\n静态库即是静态链接库，在编译时会直接拷贝一份，复制到目标程序里。静态库的代码就相当于是目标程序的一部分。\n\n<a name=\"qmzIU\"></a>\n#### 动态库\n动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用，等到App启动时，动态库才会被真正加载进来。\n\n<a name=\"BfxbV\"></a>\n#### 静态库 VS 动态库\n\n- 静态库在编译时将代码拷贝进目标程序中，会导致目标程序的体积增加。被多次使用就会在内存中存在多份冗余拷贝。\n- 动态库在App冷启动时需要加载动态链接库，进行rebase指针调整和bind符号绑定等工作，会导致App的启动时间增长。由系统动态加载到内存，供App调用，系统只加载一次，多个程序共用，节省内存。\n- iOS中静态库的形式：.a 和 .framework\n- iOS中动态库的形式：.dylib 和 .framework\n\n<a name=\"0nmXZ\"></a>\n#### 苹果的动态库发展史\n在iOS 8之前，iOS平台不支持自定义动态库，开发者可以使用的动态库只能是苹果自家的 `UIKit.framework` 、 `Foundation.framework` 等。这种限制的原因是出于安全考虑，因为iOS应用都是运行在沙盒中，不同的程序之间不能共享代码，动态下载代码是苹果明令禁止的，既然没办法发挥动态库的优势，动态库也就没有存在的必要了。<br />在iOS 8之前，也有一些第三方提供的.framework文件存在，但是它们本质上都是静态库，只不过通过一些方法进行了包装，相比较.a文件使用更方便一些。<br />iOS 8/Xcode 6 推出后，iOS平台添加了动态库的支持，支持开发者有条件地创建和使用动态库，这种动态库叫做 `Cocoa Touch Framework` ，但是这种动态framework与系统的framework还是有很大区别的。系统的framework在编译时不需要拷贝进目标程序中，而 `Cocoa Touch Framework` 在打包和提交App时会被放到app bundle中，运行在沙盒里，不同的app就算使用了相同的framework也是会有多份的框架被分别签名、打包和加载，因此苹果又把这种framework称为在[Embedded Framework](https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html)。\n\n`Cocoa Touch Framework` 的推出主要是为了解决两个问题：\n\n1. 从iOS 8开始的扩展开发\n1. Swift在早期不支持编译为静态库\n\n<a name=\"RiNwW\"></a>\n## .a VS .framework\n\n- .a是纯二进制文件 .framework中除了二进制文件还有资源文件\n- .a文件不能直接使用，需要引入.h文件配合 .framework文件包含了.h文件和其他文，可以直接使用\n\n<a name=\"oYQRv\"></a>\n## 制作教程\n关于如何制作.a文件或.framework的教程网上特别多，这里我就不做具体描述。这里主要总结一下几个关键步骤。\n<a name=\"jLvrh\"></a>\n### 架构\n苹果的架构分为两大类：模拟器架构和真机架构\n\n1. 模拟器架构\n- i386  32位架构 4S ~ 5\n- x86_64 64位架构 5S ~ 现在的机型\n2. 真机架构\n- armv7 32位架构 3GS ~ 4S\n- armv7s 特殊架构 5 ~ 5C （此架构有问题，有的程序变得更快，有的程序变得更慢）\n- arm64 64位架构 5S ~ 现在的机型\n\n<a name=\"sD83I\"></a>\n#### 合成架构\n使用模拟器编译出来的包是模拟器架构，使用真机编译出来的包是真机架构。可以使用 `lipo -info` 查看当前包的架构。<br />真机和模拟器架构合成的好处是调试会非常方便，缺点是体积会变大，一般而言，SDK都需要合成架构方便使用者使用。<br />合成架构的命令：<br />`lipo -create simulator.a device.a -output name.a` <br />合成.framework文件的架构命令也是使用 `lipo -create` 区别点是合成的是.framework文件内部的可执行文件。\n\n<a name=\"c315M\"></a>\n### 脚本打包\n手动打包虽然能满足我们的需求，但是利用脚本打包会带来几点优势：\n\n1. 提高效率，原本繁琐的打包流程，只需要执行一下脚本就能完成\n1. 统一规范，繁琐的操作流程，依赖个人去完成，难免会出现差错，利用脚本可以确保准确性\n1. 易于使用，利用脚本打包，即使是新人也可以非常容易的上手，降低沟通成本\n\n既然脚本打包有这么多优点，接下来就总结一下实现脚本打包的过程：\n\n<a name=\"kNnmW\"></a>\n#### 脚本打包思路\n\n1. 利用 `xcodebuild` 分别打包模拟器架构和真机架构\n1. 利用 `lipo -create` 合并模拟器和真机架构\n1. 如果是framework的合并，需要将合并了的二进制可执行文件复制到framework中\n1. 复制文件到指定目录下，并打开文件夹\n\n<a name=\"ARByx\"></a>\n#### 详细脚本\n```bash\n# 项目名\nPOD_PROJECT_NAME=${PROJECT_NAME}\nCONFIGURATION=Release\n#自定义的用来存放最后合并的framework\nUNIVERSAL_OUTPUTFOLDER=${SRCROOT}/Products/${CONFIGURATION}-universal\n\nWORKSPACE_NAME=${PROJECT_NAME}.xcworkspace\nSCHEME_NAME=${PROJECT_NAME}\n\n#clean build是先清除原来的build\nxcodebuild -workspace ${WORKSPACE_NAME} -scheme ${SCHEME_NAME} -sdk iphonesimulator -configuration \"${CONFIGURATION}\" clean build\nxcodebuild -workspace ${WORKSPACE_NAME} -scheme ${SCHEME_NAME} -sdk iphoneos -configuration \"${CONFIGURATION}\" clean build\necho \"${WORKSPACE_NAME}\"\necho \"${PROJECT_NAME}\"\n\n#先移除原来的\nrm -rf \"${UNIVERSAL_OUTPUTFOLDER}\"\nmkdir -p \"${UNIVERSAL_OUTPUTFOLDER}\"\n\n#清空build文件夹\nrm -rf \"${BUILD_DIR}\"\n\n# 生成OS库\nxcodebuild build -workspace ${WORKSPACE_NAME} -scheme ${POD_PROJECT_NAME} ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\"\n\n# 生成模拟器i386库\nxcodebuild build -workspace ${WORKSPACE_NAME} -scheme ${POD_PROJECT_NAME} -configuration ${CONFIGURATION} -sdk iphonesimulator -arch i386 BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\"\n\n# 重命名i386库\nmv ${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${POD_PROJECT_NAME}/${POD_PROJECT_NAME}.framework ${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${POD_PROJECT_NAME}/${POD_PROJECT_NAME}i386.framework\n\n# 生成模拟器x86_64库\nxcodebuild build -workspace ${WORKSPACE_NAME} -scheme ${POD_PROJECT_NAME} -configuration ${CONFIGURATION} -sdk iphonesimulator -arch x86_64 BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\"\n\n#合并模拟器i386和x86_64架构\nlipo -create  \"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}i386.framework/${PROJECT_NAME}\" \"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}\" -output \"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}\"\n\n#因为framework的合并,lipo只是合并了最后的二进制可执行文件,所以其它的需要我们自己复制过来\n#拷贝文件到指定的目录\ncp -R \"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}/${PROJECT_NAME}.framework\" \"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework\"\n\n#合并模拟器（i386/x86_64）和真机（armv7/arm64）的架构\nlipo -create  \"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}\" \"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}\" -output \"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}\"\n\nopen \"${UNIVERSAL_OUTPUTFOLDER}\"\n```\n\n<a name=\"spveF\"></a>\n#### 利用Aggregate提供快捷方法\n\n1. 在当前项目下新建Aggregate Target\n\n![](https://cdn.nlark.com/yuque/0/2019/png/183307/1561969431794-4718bee3-b5cc-4391-bd6b-4db925cb9816.png#align=left&display=inline&height=721&originHeight=721&originWidth=1000&size=0&status=done&width=1000)\n\n2. 添加Run Script\n\n![](https://cdn.nlark.com/yuque/0/2019/png/183307/1561969454208-d3c888d5-6adf-4f05-9832-244d0ff4be5a.png#align=left&display=inline&height=343&originHeight=343&originWidth=1000&size=0&status=done&width=1000)\n\n3. 在Run Script Phases输入脚本内容\n\n![](https://cdn.nlark.com/yuque/0/2019/png/183307/1561969490482-5f40c393-5660-4601-a4ec-0b1d2b1c3a4b.png#align=left&display=inline&height=509&originHeight=509&originWidth=1000&size=0&status=done&width=1000)\n\n4. 编译Aggregate Target 完成脚本打包\n",
    "body_draft": "",
    "body_html": "<p>日常开发中，我们可能需要封装一些SDK或者使用一些别人封装的SDK。这里总结一下SDK的封装流程。</p><p><br /></p><h2 id=\"sH1aJ\">基本概念</h2><p>通常我们遇到的SDK有两种：.framework和.a文件。首先，我们需要弄清楚这两种类型的文件有什么区别。</p><p><br /></p><p>在讲清楚.framework和.a文件的区别前，我们需要先了解另外两个概念：静态库和动态库。</p><p><br /></p><h4 id=\"MsdOd\">静态库</h4><p>静态库即是静态链接库，在编译时会直接拷贝一份，复制到目标程序里。静态库的代码就相当于是目标程序的一部分。</p><p><br /></p><h4 id=\"qmzIU\">动态库</h4><p>动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用，等到App启动时，动态库才会被真正加载进来。</p><p><br /></p><h4 id=\"BfxbV\">静态库 VS 动态库</h4><ul><li>静态库在编译时将代码拷贝进目标程序中，会导致目标程序的体积增加。被多次使用就会在内存中存在多份冗余拷贝。</li><li>动态库在App冷启动时需要加载动态链接库，进行rebase指针调整和bind符号绑定等工作，会导致App的启动时间增长。由系统动态加载到内存，供App调用，系统只加载一次，多个程序共用，节省内存。</li><li>iOS中静态库的形式：.a 和 .framework</li><li>iOS中动态库的形式：.dylib 和 .framework</li></ul><p><br /></p><h4 id=\"0nmXZ\">苹果的动态库发展史</h4><p>在iOS 8之前，iOS平台不支持自定义动态库，开发者可以使用的动态库只能是苹果自家的 <code>UIKit.framework</code> 、 <code>Foundation.framework</code> 等。这种限制的原因是出于安全考虑，因为iOS应用都是运行在沙盒中，不同的程序之间不能共享代码，动态下载代码是苹果明令禁止的，既然没办法发挥动态库的优势，动态库也就没有存在的必要了。</p><p>在iOS 8之前，也有一些第三方提供的.framework文件存在，但是它们本质上都是静态库，只不过通过一些方法进行了包装，相比较.a文件使用更方便一些。</p><p>iOS 8/Xcode 6 推出后，iOS平台添加了动态库的支持，支持开发者有条件地创建和使用动态库，这种动态库叫做 <code>Cocoa Touch Framework</code> ，但是这种动态framework与系统的framework还是有很大区别的。系统的framework在编译时不需要拷贝进目标程序中，而 <code>Cocoa Touch Framework</code> 在打包和提交App时会被放到app bundle中，运行在沙盒里，不同的app就算使用了相同的framework也是会有多份的框架被分别签名、打包和加载，因此苹果又把这种framework称为在<a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\" target=\"_blank\">Embedded Framework</a>。</p><p><br /></p><p><code>Cocoa Touch Framework</code> 的推出主要是为了解决两个问题：</p><ol start=\"1\"><li>从iOS 8开始的扩展开发</li><li>Swift在早期不支持编译为静态库</li></ol><p><br /></p><h2 id=\"RiNwW\">.a VS .framework</h2><ul><li>.a是纯二进制文件 .framework中除了二进制文件还有资源文件</li><li>.a文件不能直接使用，需要引入.h文件配合 .framework文件包含了.h文件和其他文，可以直接使用</li></ul><p><br /></p><h2 id=\"oYQRv\">制作教程</h2><p>关于如何制作.a文件或.framework的教程网上特别多，这里我就不做具体描述。这里主要总结一下几个关键步骤。</p><h3 id=\"jLvrh\">架构</h3><p>苹果的架构分为两大类：模拟器架构和真机架构</p><ol start=\"1\"><li>模拟器架构</li></ol><ul><li>i386  32位架构 4S ~ 5</li><li>x86_64 64位架构 5S ~ 现在的机型</li></ul><ol start=\"2\"><li>真机架构</li></ol><ul><li>armv7 32位架构 3GS ~ 4S</li><li>armv7s 特殊架构 5 ~ 5C （此架构有问题，有的程序变得更快，有的程序变得更慢）</li><li>arm64 64位架构 5S ~ 现在的机型</li></ul><p><br /></p><h4 id=\"sD83I\">合成架构</h4><p>使用模拟器编译出来的包是模拟器架构，使用真机编译出来的包是真机架构。可以使用 <code>lipo -info</code> 查看当前包的架构。</p><p>真机和模拟器架构合成的好处是调试会非常方便，缺点是体积会变大，一般而言，SDK都需要合成架构方便使用者使用。</p><p>合成架构的命令：</p><p><code>lipo -create simulator.a device.a -output name.a</code> </p><p>合成.framework文件的架构命令也是使用 <code>lipo -create</code> 区别点是合成的是.framework文件内部的可执行文件。</p><p><br /></p><h3 id=\"c315M\">脚本打包</h3><p>手动打包虽然能满足我们的需求，但是利用脚本打包会带来几点优势：</p><ol start=\"1\"><li>提高效率，原本繁琐的打包流程，只需要执行一下脚本就能完成</li><li>统一规范，繁琐的操作流程，依赖个人去完成，难免会出现差错，利用脚本可以确保准确性</li><li>易于使用，利用脚本打包，即使是新人也可以非常容易的上手，降低沟通成本</li></ol><p><br /></p><p>既然脚本打包有这么多优点，接下来就总结一下实现脚本打包的过程：</p><p><br /></p><h4 id=\"kNnmW\">脚本打包思路</h4><ol start=\"1\"><li>利用 <code>xcodebuild</code> 分别打包模拟器架构和真机架构</li><li>利用 <code>lipo -create</code> 合并模拟器和真机架构</li><li>如果是framework的合并，需要将合并了的二进制可执行文件复制到framework中</li><li>复制文件到指定目录下，并打开文件夹</li></ol><p><br /></p><h4 id=\"ARByx\">详细脚本</h4><pre data-lang=\"bash\"><code># 项目名\nPOD_PROJECT_NAME=${PROJECT_NAME}\nCONFIGURATION=Release\n#自定义的用来存放最后合并的framework\nUNIVERSAL_OUTPUTFOLDER=${SRCROOT}/Products/${CONFIGURATION}-universal\n\nWORKSPACE_NAME=${PROJECT_NAME}.xcworkspace\nSCHEME_NAME=${PROJECT_NAME}\n\n#clean build是先清除原来的build\nxcodebuild -workspace ${WORKSPACE_NAME} -scheme ${SCHEME_NAME} -sdk iphonesimulator -configuration &quot;${CONFIGURATION}&quot; clean build\nxcodebuild -workspace ${WORKSPACE_NAME} -scheme ${SCHEME_NAME} -sdk iphoneos -configuration &quot;${CONFIGURATION}&quot; clean build\necho &quot;${WORKSPACE_NAME}&quot;\necho &quot;${PROJECT_NAME}&quot;\n\n#先移除原来的\nrm -rf &quot;${UNIVERSAL_OUTPUTFOLDER}&quot;\nmkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot;\n\n#清空build文件夹\nrm -rf &quot;${BUILD_DIR}&quot;\n\n# 生成OS库\nxcodebuild build -workspace ${WORKSPACE_NAME} -scheme ${POD_PROJECT_NAME} ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot;\n\n# 生成模拟器i386库\nxcodebuild build -workspace ${WORKSPACE_NAME} -scheme ${POD_PROJECT_NAME} -configuration ${CONFIGURATION} -sdk iphonesimulator -arch i386 BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot;\n\n# 重命名i386库\nmv ${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${POD_PROJECT_NAME}/${POD_PROJECT_NAME}.framework ${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${POD_PROJECT_NAME}/${POD_PROJECT_NAME}i386.framework\n\n# 生成模拟器x86_64库\nxcodebuild build -workspace ${WORKSPACE_NAME} -scheme ${POD_PROJECT_NAME} -configuration ${CONFIGURATION} -sdk iphonesimulator -arch x86_64 BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot;\n\n#合并模拟器i386和x86_64架构\nlipo -create  &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}i386.framework/${PROJECT_NAME}&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}&quot; -output &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}&quot;\n\n#因为framework的合并,lipo只是合并了最后的二进制可执行文件,所以其它的需要我们自己复制过来\n#拷贝文件到指定的目录\ncp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}/${PROJECT_NAME}.framework&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework&quot;\n\n#合并模拟器（i386/x86_64）和真机（armv7/arm64）的架构\nlipo -create  &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}/${PROJECT_NAME}.framework/${PROJECT_NAME}&quot; -output &quot;${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}&quot;\n\nopen &quot;${UNIVERSAL_OUTPUTFOLDER}&quot;</code></pre><p><br /></p><h4 id=\"spveF\">利用Aggregate提供快捷方法</h4><ol start=\"1\"><li>在当前项目下新建Aggregate Target</li></ol><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/183307/1561969431794-4718bee3-b5cc-4391-bd6b-4db925cb9816.png#align=left&amp;display=inline&amp;height=721&amp;originHeight=721&amp;originWidth=1000&amp;size=0&amp;status=done&amp;width=1000\" style=\"max-width: 600px; width: 1000px;\" /></p><p><br /></p><ol start=\"2\"><li>添加Run Script</li></ol><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/183307/1561969454208-d3c888d5-6adf-4f05-9832-244d0ff4be5a.png#align=left&amp;display=inline&amp;height=343&amp;originHeight=343&amp;originWidth=1000&amp;size=0&amp;status=done&amp;width=1000\" style=\"max-width: 600px; width: 1000px;\" /></p><p><br /></p><ol start=\"3\"><li>在Run Script Phases输入脚本内容</li></ol><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/183307/1561969490482-5f40c393-5660-4601-a4ec-0b1d2b1c3a4b.png#align=left&amp;display=inline&amp;height=509&amp;originHeight=509&amp;originWidth=1000&amp;size=0&amp;status=done&amp;width=1000\" style=\"max-width: 600px; width: 1000px;\" /></p><p><br /></p><ol start=\"4\"><li>编译Aggregate Target 完成脚本打包</li></ol>",
    "body_lake": "<!doctype lake><p>日常开发中，我们可能需要封装一些SDK或者使用一些别人封装的SDK。这里总结一下SDK的封装流程。</p><p><br /></p><h2 id=\"sH1aJ\">基本概念</h2><p>通常我们遇到的SDK有两种：.framework和.a文件。首先，我们需要弄清楚这两种类型的文件有什么区别。</p><p><br /></p><p>在讲清楚.framework和.a文件的区别前，我们需要先了解另外两个概念：静态库和动态库。</p><p><br /></p><h4 id=\"MsdOd\">静态库</h4><p>静态库即是静态链接库，在编译时会直接拷贝一份，复制到目标程序里。静态库的代码就相当于是目标程序的一部分。</p><p><br /></p><h4 id=\"qmzIU\">动态库</h4><p>动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用，等到App启动时，动态库才会被真正加载进来。</p><p><br /></p><h4 id=\"BfxbV\">静态库 VS 动态库</h4><ul><li>静态库在编译时将代码拷贝进目标程序中，会导致目标程序的体积增加。被多次使用就会在内存中存在多份冗余拷贝。</li><li>动态库在App冷启动时需要加载动态链接库，进行rebase指针调整和bind符号绑定等工作，会导致App的启动时间增长。由系统动态加载到内存，供App调用，系统只加载一次，多个程序共用，节省内存。</li><li>iOS中静态库的形式：.a 和 .framework</li><li>iOS中动态库的形式：.dylib 和 .framework</li></ul><p><br /></p><h4 id=\"0nmXZ\">苹果的动态库发展史</h4><p>在iOS 8之前，iOS平台不支持自定义动态库，开发者可以使用的动态库只能是苹果自家的 <code>UIKit.framework</code> 、 <code>Foundation.framework</code> 等。这种限制的原因是出于安全考虑，因为iOS应用都是运行在沙盒中，不同的程序之间不能共享代码，动态下载代码是苹果明令禁止的，既然没办法发挥动态库的优势，动态库也就没有存在的必要了。</p><p>在iOS 8之前，也有一些第三方提供的.framework文件存在，但是它们本质上都是静态库，只不过通过一些方法进行了包装，相比较.a文件使用更方便一些。</p><p>iOS 8/Xcode 6 推出后，iOS平台添加了动态库的支持，支持开发者有条件地创建和使用动态库，这种动态库叫做 <code>Cocoa Touch Framework</code> ，但是这种动态framework与系统的framework还是有很大区别的。系统的framework在编译时不需要拷贝进目标程序中，而 <code>Cocoa Touch Framework</code> 在打包和提交App时会被放到app bundle中，运行在沙盒里，不同的app就算使用了相同的framework也是会有多份的框架被分别签名、打包和加载，因此苹果又把这种framework称为在<a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\" target=\"_blank\">Embedded Framework</a>。</p><p><br /></p><p><code>Cocoa Touch Framework</code> 的推出主要是为了解决两个问题：</p><ol start=\"1\"><li>从iOS 8开始的扩展开发</li><li>Swift在早期不支持编译为静态库</li></ol><p><br /></p><h2 id=\"RiNwW\">.a VS .framework</h2><ul><li>.a是纯二进制文件 .framework中除了二进制文件还有资源文件</li><li>.a文件不能直接使用，需要引入.h文件配合 .framework文件包含了.h文件和其他文，可以直接使用</li></ul><p><br /></p><h2 id=\"oYQRv\">制作教程</h2><p>关于如何制作.a文件或.framework的教程网上特别多，这里我就不做具体描述。这里主要总结一下几个关键步骤。</p><h3 id=\"jLvrh\">架构</h3><p>苹果的架构分为两大类：模拟器架构和真机架构</p><ol start=\"1\"><li>模拟器架构</li></ol><ul><li>i386  32位架构 4S ~ 5</li><li>x86_64 64位架构 5S ~ 现在的机型</li></ul><ol start=\"2\"><li>真机架构</li></ol><ul><li>armv7 32位架构 3GS ~ 4S</li><li>armv7s 特殊架构 5 ~ 5C （此架构有问题，有的程序变得更快，有的程序变得更慢）</li><li>arm64 64位架构 5S ~ 现在的机型</li></ul><p><br /></p><h4 id=\"sD83I\">合成架构</h4><p>使用模拟器编译出来的包是模拟器架构，使用真机编译出来的包是真机架构。可以使用 <code>lipo -info</code> 查看当前包的架构。</p><p>真机和模拟器架构合成的好处是调试会非常方便，缺点是体积会变大，一般而言，SDK都需要合成架构方便使用者使用。</p><p>合成架构的命令：</p><p><code>lipo -create simulator.a device.a -output name.a</code> </p><p>合成.framework文件的架构命令也是使用 <code>lipo -create</code> 区别点是合成的是.framework文件内部的可执行文件。</p><p><br /></p><h3 id=\"c315M\">脚本打包</h3><p>手动打包虽然能满足我们的需求，但是利用脚本打包会带来几点优势：</p><ol start=\"1\"><li>提高效率，原本繁琐的打包流程，只需要执行一下脚本就能完成</li><li>统一规范，繁琐的操作流程，依赖个人去完成，难免会出现差错，利用脚本可以确保准确性</li><li>易于使用，利用脚本打包，即使是新人也可以非常容易的上手，降低沟通成本</li></ol><p><br /></p><p>既然脚本打包有这么多优点，接下来就总结一下实现脚本打包的过程：</p><p><br /></p><h4 id=\"kNnmW\">脚本打包思路</h4><ol start=\"1\"><li>利用 <code>xcodebuild</code> 分别打包模拟器架构和真机架构</li><li>利用 <code>lipo -create</code> 合并模拟器和真机架构</li><li>如果是framework的合并，需要将合并了的二进制可执行文件复制到framework中</li><li>复制文件到指定目录下，并打开文件夹</li></ol><p><br /></p><h4 id=\"ARByx\">详细脚本</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23%20%E9%A1%B9%E7%9B%AE%E5%90%8D%5CnPOD_PROJECT_NAME%3D%24%7BPROJECT_NAME%7D%5CnCONFIGURATION%3DRelease%5Cn%23%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E6%9C%80%E5%90%8E%E5%90%88%E5%B9%B6%E7%9A%84framework%5CnUNIVERSAL_OUTPUTFOLDER%3D%24%7BSRCROOT%7D%2FProducts%2F%24%7BCONFIGURATION%7D-universal%5Cn%5CnWORKSPACE_NAME%3D%24%7BPROJECT_NAME%7D.xcworkspace%5CnSCHEME_NAME%3D%24%7BPROJECT_NAME%7D%5Cn%5Cn%23clean%20build%E6%98%AF%E5%85%88%E6%B8%85%E9%99%A4%E5%8E%9F%E6%9D%A5%E7%9A%84build%5Cnxcodebuild%20-workspace%20%24%7BWORKSPACE_NAME%7D%20-scheme%20%24%7BSCHEME_NAME%7D%20-sdk%20iphonesimulator%20-configuration%20%5C%22%24%7BCONFIGURATION%7D%5C%22%20clean%20build%5Cnxcodebuild%20-workspace%20%24%7BWORKSPACE_NAME%7D%20-scheme%20%24%7BSCHEME_NAME%7D%20-sdk%20iphoneos%20-configuration%20%5C%22%24%7BCONFIGURATION%7D%5C%22%20clean%20build%5Cnecho%20%5C%22%24%7BWORKSPACE_NAME%7D%5C%22%5Cnecho%20%5C%22%24%7BPROJECT_NAME%7D%5C%22%5Cn%5Cn%23%E5%85%88%E7%A7%BB%E9%99%A4%E5%8E%9F%E6%9D%A5%E7%9A%84%5Cnrm%20-rf%20%5C%22%24%7BUNIVERSAL_OUTPUTFOLDER%7D%5C%22%5Cnmkdir%20-p%20%5C%22%24%7BUNIVERSAL_OUTPUTFOLDER%7D%5C%22%5Cn%5Cn%23%E6%B8%85%E7%A9%BAbuild%E6%96%87%E4%BB%B6%E5%A4%B9%5Cnrm%20-rf%20%5C%22%24%7BBUILD_DIR%7D%5C%22%5Cn%5Cn%23%20%E7%94%9F%E6%88%90OS%E5%BA%93%5Cnxcodebuild%20build%20-workspace%20%24%7BWORKSPACE_NAME%7D%20-scheme%20%24%7BPOD_PROJECT_NAME%7D%20ONLY_ACTIVE_ARCH%3DNO%20-configuration%20%24%7BCONFIGURATION%7D%20-sdk%20iphoneos%20BUILD_DIR%3D%5C%22%24%7BBUILD_DIR%7D%5C%22%20BUILD_ROOT%3D%5C%22%24%7BBUILD_ROOT%7D%5C%22%5Cn%5Cn%23%20%E7%94%9F%E6%88%90%E6%A8%A1%E6%8B%9F%E5%99%A8i386%E5%BA%93%5Cnxcodebuild%20build%20-workspace%20%24%7BWORKSPACE_NAME%7D%20-scheme%20%24%7BPOD_PROJECT_NAME%7D%20-configuration%20%24%7BCONFIGURATION%7D%20-sdk%20iphonesimulator%20-arch%20i386%20BUILD_DIR%3D%5C%22%24%7BBUILD_DIR%7D%5C%22%20BUILD_ROOT%3D%5C%22%24%7BBUILD_ROOT%7D%5C%22%5Cn%5Cn%23%20%E9%87%8D%E5%91%BD%E5%90%8Di386%E5%BA%93%5Cnmv%20%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphonesimulator%2F%24%7BPOD_PROJECT_NAME%7D%2F%24%7BPOD_PROJECT_NAME%7D.framework%20%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphonesimulator%2F%24%7BPOD_PROJECT_NAME%7D%2F%24%7BPOD_PROJECT_NAME%7Di386.framework%5Cn%5Cn%23%20%E7%94%9F%E6%88%90%E6%A8%A1%E6%8B%9F%E5%99%A8x86_64%E5%BA%93%5Cnxcodebuild%20build%20-workspace%20%24%7BWORKSPACE_NAME%7D%20-scheme%20%24%7BPOD_PROJECT_NAME%7D%20-configuration%20%24%7BCONFIGURATION%7D%20-sdk%20iphonesimulator%20-arch%20x86_64%20BUILD_DIR%3D%5C%22%24%7BBUILD_DIR%7D%5C%22%20BUILD_ROOT%3D%5C%22%24%7BBUILD_ROOT%7D%5C%22%5Cn%5Cn%23%E5%90%88%E5%B9%B6%E6%A8%A1%E6%8B%9F%E5%99%A8i386%E5%92%8Cx86_64%E6%9E%B6%E6%9E%84%5Cnlipo%20-create%20%20%5C%22%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphonesimulator%2F%24%7BPROJECT_NAME%7D%2F%24%7BPROJECT_NAME%7Di386.framework%2F%24%7BPROJECT_NAME%7D%5C%22%20%5C%22%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphonesimulator%2F%24%7BPROJECT_NAME%7D%2F%24%7BPROJECT_NAME%7D.framework%2F%24%7BPROJECT_NAME%7D%5C%22%20-output%20%5C%22%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphonesimulator%2F%24%7BPROJECT_NAME%7D%2F%24%7BPROJECT_NAME%7D.framework%2F%24%7BPROJECT_NAME%7D%5C%22%5Cn%5Cn%23%E5%9B%A0%E4%B8%BAframework%E7%9A%84%E5%90%88%E5%B9%B6%2Clipo%E5%8F%AA%E6%98%AF%E5%90%88%E5%B9%B6%E4%BA%86%E6%9C%80%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2C%E6%89%80%E4%BB%A5%E5%85%B6%E5%AE%83%E7%9A%84%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E5%A4%8D%E5%88%B6%E8%BF%87%E6%9D%A5%5Cn%23%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E7%9B%AE%E5%BD%95%5Cncp%20-R%20%5C%22%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphoneos%2F%24%7BPROJECT_NAME%7D%2F%24%7BPROJECT_NAME%7D.framework%5C%22%20%5C%22%24%7BUNIVERSAL_OUTPUTFOLDER%7D%2F%24%7BPROJECT_NAME%7D.framework%5C%22%5Cn%5Cn%23%E5%90%88%E5%B9%B6%E6%A8%A1%E6%8B%9F%E5%99%A8%EF%BC%88i386%2Fx86_64%EF%BC%89%E5%92%8C%E7%9C%9F%E6%9C%BA%EF%BC%88armv7%2Farm64%EF%BC%89%E7%9A%84%E6%9E%B6%E6%9E%84%5Cnlipo%20-create%20%20%5C%22%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphonesimulator%2F%24%7BPROJECT_NAME%7D%2F%24%7BPROJECT_NAME%7D.framework%2F%24%7BPROJECT_NAME%7D%5C%22%20%5C%22%24%7BBUILD_DIR%7D%2F%24%7BCONFIGURATION%7D-iphoneos%2F%24%7BPROJECT_NAME%7D%2F%24%7BPROJECT_NAME%7D.framework%2F%24%7BPROJECT_NAME%7D%5C%22%20-output%20%5C%22%24%7BUNIVERSAL_OUTPUTFOLDER%7D%2F%24%7BPROJECT_NAME%7D.framework%2F%24%7BPROJECT_NAME%7D%5C%22%5Cn%5Cnopen%20%5C%22%24%7BUNIVERSAL_OUTPUTFOLDER%7D%5C%22%22%2C%22id%22%3A%22kRA8E%22%7D\"></card><p><br /></p><h4 id=\"spveF\">利用Aggregate提供快捷方法</h4><ol start=\"1\"><li>在当前项目下新建Aggregate Target</li></ol><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F183307%2F1561969431794-4718bee3-b5cc-4391-bd6b-4db925cb9816.png%22%2C%22originWidth%22%3A1000%2C%22originHeight%22%3A721%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1000%2C%22height%22%3A721%7D\"></card></p><p><br /></p><ol start=\"2\"><li>添加Run Script</li></ol><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F183307%2F1561969454208-d3c888d5-6adf-4f05-9832-244d0ff4be5a.png%22%2C%22originWidth%22%3A1000%2C%22originHeight%22%3A343%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1000%2C%22height%22%3A343%7D\"></card></p><p><br /></p><ol start=\"3\"><li>在Run Script Phases输入脚本内容</li></ol><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F183307%2F1561969490482-5f40c393-5660-4601-a4ec-0b1d2b1c3a4b.png%22%2C%22originWidth%22%3A1000%2C%22originHeight%22%3A509%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1000%2C%22height%22%3A509%7D\"></card></p><p><br /></p><ol start=\"4\"><li>编译Aggregate Target 完成脚本打包<cursor /></li></ol>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-01T08:25:35.000Z",
    "deleted_at": null,
    "created_at": "2019-07-01T05:19:08.000Z",
    "updated_at": "2019-07-01T08:25:35.000Z",
    "published_at": "2019-07-01T08:25:35.000Z",
    "first_published_at": "2019-07-01T06:38:25.000Z",
    "word_count": 1900,
    "cover": null,
    "description": "日常开发中，我们可能需要封装一些SDK或者使用一些别人封装的SDK。这里总结一下SDK的封装流程。基本概念通常我们遇到的SDK有两种：.framework和.a文件。首先，我们需要弄清楚这两种类型的文件有什么区别。在讲清楚.framework和.a文件的区别前，我们需要先了解另外两个概念：静态...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1998249,
    "slug": "gmqtia",
    "title": "iOS高效开发",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-07-03T11:35:20.078Z",
      "updated_at": "2019-07-03T11:35:20.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-06-19T06:54:31.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-06-19T06:54:31.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: iOS<br />tags: [总结]\n\n---\n\n工欲善其事必先利其器，合理的利用工具，提升开发效率，不仅仅帮助我们节省时间，关键是能帮我们从一些重复、低效的工作中抽离出来，专注于有挑战，有深度的问题，不断提升自己。这里总结一些我在日常开发中提升开发效率的一些技巧，如果您有更好的提升效率的方法也请不吝赐教。\n\n<a name=\"RxXxI\"></a>\n## xopen快捷脚本\n自定义xopen快捷脚本，在终端中快速打开项目<br />![](https://cdn.nlark.com/yuque/0/2019/gif/183307/1562028112900-78c7a90a-d135-43da-bda3-a8f633731c6d.gif#align=left&display=inline&height=410&originHeight=410&originWidth=656&status=done&width=656)\n\n详细步骤：\n\n1. 创建一个xopen文件 文件内容如下：\n```ruby\n#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts \"Opening  #{proj}\"\n   `open #{proj}`\nelse\n  puts \"No  xcworkspace|xcproj  file  found\"\nend\n```\n\n2. 将 `xopen` 文件移入 `/usr/local/bin` 目录下 并执行chmod 777添加读写权限\n\n<a name=\"6OWDd\"></a>\n## 代码片段\nXcode为我们提供了一些代码片段，但是不够全面，不过Xcode支持我们自己添加代码片段，通过添加常用的代码片段，可以极大的节省开发效率。<br />腾讯的QMUI团队开源了一份他们总结的代码片段库_[qmui-ios-codesnippets](https://github.com/QMUI/QMUI_iOS_CodeSnippets)，_集成他们的代码片段库就能满足日常的开发需求，提升coding的效率。\n\n<a name=\"nm4ba\"></a>\n## fastlane\n[fastlane]()是一套ruby编写的持续集成工具集。通过fastlane可以实现自动打包、发布等工作。<br />原先我都是利用Xcode提供的 `xcodebuild` 命令自定义了一个 `xpublish` 脚本来进行打包，详细的配置过程可以参考：[iOS--两套自动打包脚本](https://juejin.im/post/5be2e07fe51d454d5c7c2b96)，不过当我发现有 `fastlane` 这个神器后果断放弃了原来使用的脚本，主要原因当然还是 `fastlane` 更加全面和强大。 `fastlane` 的集成过程比较简单，网上有很多资料，可以参考[小团队的自动化发布--Fastlane带来的全自动化发布](https://whlsxl.github.io/fastlane1/)。<br />因为我们项目已经使用Jenkins进行持续集成，日常使用 `fastlane` 并不多，主要会在偶尔打单独的测试包或审核包时才会使用，这里简单总结一下我的fastlane配置。\n\n```ruby\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"send ipa to pgyer\"\n  lane :pgyer do\n    # 执行pod install 需要在Gemfile里配置cocoapods\n    cocoapods(\n      clean: true,\n      podfile: \"./Podfile\"\n    )\n    # 打包项目\n    build_app(workspace: \"****.xcworkspace\", scheme: \"****\", export_method: \"ad-hoc\", output_directory: \"./fastlane/package\", configuration: \"Release\")\n    # 上传蒲公英 需要先安装蒲公英插件\n    pgyer(api_key: \"********\", user_key: \"**********\")\n    # 上传完成后 发送消息通知 避免忘记\n    notification(subtitle: \"Finished Uploading\", message: \"upload success\")\n  end\nend\n```\n\n有几点说明：\n\n1. 支持cocoapods需要在Gemfile里配置一下\n\n```ruby\n# 配置cocoapods，并指定版本\ngem 'cocoapods', '1.7.1'\n```\n\n\n2. 蒲公英的插件安装命令\n\n`fastlane add_plugin pgyer` \n\n安装完后的Gemfile:\n```ruby\nsource \"https://rubygems.org\"\n\ngem \"fastlane\"\n\n# 配置cocoapods，并指定版本\ngem 'cocoapods', '1.7.1'\n\nplugins_path = File.join(File.dirname(__FILE__), 'fastlane', 'Pluginfile')\neval_gemfile(plugins_path) if File.exist?(plugins_path)\n```\n\n更多关于 `fastlane` 的功能可以查看[官方文档中的Actions](https://docs.fastlane.tools/actions/)。\n\n<a name=\"wtjSf\"></a>\n## Jenkins\n[Jenkins]()是一款开源的CI工具，利用Jenkins可以通过规范化的操作流程避免一些低级错误，将开发人员从简单、繁琐的工作中释放出来。关于Jenkins的配置教程网上也是有很多，[Jenkins 持续集成使用教程](https://juejin.im/post/5ad6beff6fb9a028c06b5889)就比较详细。\n\n<a name=\"OTH2U\"></a>\n## SwitchHosts\n[SwitchHosts]()是一个开源的用于hosts管理和切换的软件。<br />对于绝大多数公司肯定存在测试环境和线上环境，通常我们需要在测试环境验证无误后才会发布到正式环境，这就需要客户端在开发阶段能够请求不同的服务器IP，利用 `SwitchHosts` 和 `Charles` 就能实现不修改客户端代码的情况下访问不同的服务器IP。这样做就能避免了客户端打包时需要根据需求切换访问地址，之前就有公司误将测试环境的App发布给用户的情况。\n",
    "body_draft": "",
    "body_html": "<p>categories: iOS</p><p>tags: [总结]</p><hr /><p>工欲善其事必先利其器，合理的利用工具，提升开发效率，不仅仅帮助我们节省时间，关键是能帮我们从一些重复、低效的工作中抽离出来，专注于有挑战，有深度的问题，不断提升自己。这里总结一些我在日常开发中提升开发效率的一些技巧，如果您有更好的提升效率的方法也请不吝赐教。</p><p><br /></p><h2 id=\"RxXxI\">xopen快捷脚本</h2><p>自定义xopen快捷脚本，在终端中快速打开项目</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/183307/1562028112900-78c7a90a-d135-43da-bda3-a8f633731c6d.gif#align=left&amp;display=inline&amp;height=410&amp;originHeight=410&amp;originWidth=656&amp;status=done&amp;width=656\" style=\"max-width: 600px; width: 656px;\" /></p><p><br /></p><p>详细步骤：</p><ol start=\"1\"><li>创建一个xopen文件 文件内容如下：</li></ol><pre data-lang=\"ruby\"><code>#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts &quot;Opening  #{proj}&quot;\n   `open #{proj}`\nelse\n  puts &quot;No  xcworkspace|xcproj  file  found&quot;\nend</code></pre><ol start=\"2\"><li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下 并执行chmod 777添加读写权限</li></ol><p><br /></p><h2 id=\"6OWDd\">代码片段</h2><p>Xcode为我们提供了一些代码片段，但是不够全面，不过Xcode支持我们自己添加代码片段，通过添加常用的代码片段，可以极大的节省开发效率。</p><p>腾讯的QMUI团队开源了一份他们总结的代码片段库<em><a href=\"https://github.com/QMUI/QMUI_iOS_CodeSnippets\" target=\"_blank\">qmui-ios-codesnippets</a>，</em>集成他们的代码片段库就能满足日常的开发需求，提升coding的效率。</p><p><br /></p><h2 id=\"nm4ba\">fastlane</h2><p><a href=\"\" target=\"_blank\">fastlane</a>是一套ruby编写的持续集成工具集。通过fastlane可以实现自动打包、发布等工作。</p><p>原先我都是利用Xcode提供的 <code>xcodebuild</code> 命令自定义了一个 <code>xpublish</code> 脚本来进行打包，详细的配置过程可以参考：<a href=\"https://juejin.im/post/5be2e07fe51d454d5c7c2b96\" target=\"_blank\">iOS--两套自动打包脚本</a>，不过当我发现有 <code>fastlane</code> 这个神器后果断放弃了原来使用的脚本，主要原因当然还是 <code>fastlane</code> 更加全面和强大。 <code>fastlane</code> 的集成过程比较简单，网上有很多资料，可以参考<a href=\"https://whlsxl.github.io/fastlane1/\" target=\"_blank\">小团队的自动化发布--Fastlane带来的全自动化发布</a>。</p><p>因为我们项目已经使用Jenkins进行持续集成，日常使用 <code>fastlane</code> 并不多，主要会在偶尔打单独的测试包或审核包时才会使用，这里简单总结一下我的fastlane配置。</p><p><br /></p><pre data-lang=\"ruby\"><code>default_platform(:ios)\n\nplatform :ios do\n  desc &quot;send ipa to pgyer&quot;\n  lane :pgyer do\n    # 执行pod install 需要在Gemfile里配置cocoapods\n    cocoapods(\n      clean: true,\n      podfile: &quot;./Podfile&quot;\n    )\n    # 打包项目\n    build_app(workspace: &quot;****.xcworkspace&quot;, scheme: &quot;****&quot;, export_method: &quot;ad-hoc&quot;, output_directory: &quot;./fastlane/package&quot;, configuration: &quot;Release&quot;)\n    # 上传蒲公英 需要先安装蒲公英插件\n    pgyer(api_key: &quot;********&quot;, user_key: &quot;**********&quot;)\n    # 上传完成后 发送消息通知 避免忘记\n    notification(subtitle: &quot;Finished Uploading&quot;, message: &quot;upload success&quot;)\n  end\nend</code></pre><p><br /></p><p>有几点说明：</p><ol start=\"1\"><li>支持cocoapods需要在Gemfile里配置一下</li><p><br /></p></ol><pre data-lang=\"ruby\"><code># 配置cocoapods，并指定版本\ngem 'cocoapods', '1.7.1'</code></pre><ol start=\"2\"><p><br /></p><li>蒲公英的插件安装命令</li></ol><p><code>fastlane add_plugin pgyer</code> </p><p><br /></p><p>安装完后的Gemfile:</p><pre data-lang=\"ruby\"><code>source &quot;https://rubygems.org&quot;\n\ngem &quot;fastlane&quot;\n\n# 配置cocoapods，并指定版本\ngem 'cocoapods', '1.7.1'\n\nplugins_path = File.join(File.dirname(__FILE__), 'fastlane', 'Pluginfile')\neval_gemfile(plugins_path) if File.exist?(plugins_path)</code></pre><p><br /></p><p>更多关于 <code>fastlane</code> 的功能可以查看<a href=\"https://docs.fastlane.tools/actions/\" target=\"_blank\">官方文档中的Actions</a>。</p><p><br /></p><h2 id=\"wtjSf\">Jenkins</h2><p><a href=\"\" target=\"_blank\">Jenkins</a>是一款开源的CI工具，利用Jenkins可以通过规范化的操作流程避免一些低级错误，将开发人员从简单、繁琐的工作中释放出来。关于Jenkins的配置教程网上也是有很多，<a href=\"https://juejin.im/post/5ad6beff6fb9a028c06b5889\" target=\"_blank\">Jenkins 持续集成使用教程</a>就比较详细。</p><p><br /></p><h2 id=\"OTH2U\">SwitchHosts</h2><p><a href=\"\" target=\"_blank\">SwitchHosts</a>是一个开源的用于hosts管理和切换的软件。</p><p>对于绝大多数公司肯定存在测试环境和线上环境，通常我们需要在测试环境验证无误后才会发布到正式环境，这就需要客户端在开发阶段能够请求不同的服务器IP，利用 <code>SwitchHosts</code> 和 <code>Charles</code> 就能实现不修改客户端代码的情况下访问不同的服务器IP。这样做就能避免了客户端打包时需要根据需求切换访问地址，之前就有公司误将测试环境的App发布给用户的情况。</p>",
    "body_lake": "<!doctype lake><p>categories: iOS</p><p>tags: [总结]</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22uNSGD%22%7D\"></card><p>工欲善其事必先利其器，合理的利用工具，提升开发效率，不仅仅帮助我们节省时间，关键是能帮我们从一些重复、低效的工作中抽离出来，专注于有挑战，有深度的问题，不断提升自己。这里总结一些我在日常开发中提升开发效率的一些技巧，如果您有更好的提升效率的方法也请不吝赐教。</p><p><br /></p><h2 id=\"RxXxI\">xopen快捷脚本</h2><p>自定义xopen快捷脚本，在终端中快速打开项目</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fgif%2F183307%2F1562028112900-78c7a90a-d135-43da-bda3-a8f633731c6d.gif%22%2C%22originWidth%22%3A656%2C%22originHeight%22%3A410%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A656%2C%22height%22%3A410%7D\"></card></p><p><br /></p><p>详细步骤：</p><ol start=\"1\"><li>创建一个xopen文件 文件内容如下：</li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22%23!%2Fusr%2Fbin%2Fenv%20ruby%5Cnrequire%20'shellwords'%5Cn%5Cnproj%20%3D%20Dir%5B'*.xcworkspace'%5D.first%5Cnproj%20%3D%20Dir%5B'*.xcodeproj'%5D.first%20unless%20proj%5Cn%5Cnif%20proj%5Cn%20%20%20puts%20%5C%22Opening%20%20%23%7Bproj%7D%5C%22%5Cn%20%20%20%60open%20%23%7Bproj%7D%60%5Cnelse%5Cn%20%20puts%20%5C%22No%20%20xcworkspace%7Cxcproj%20%20file%20%20found%5C%22%5Cnend%22%2C%22id%22%3A%22LzAlp%22%7D\"></card><ol start=\"2\"><li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下 并执行chmod 777添加读写权限</li></ol><p><br /></p><h2 id=\"6OWDd\">代码片段</h2><p>Xcode为我们提供了一些代码片段，但是不够全面，不过Xcode支持我们自己添加代码片段，通过添加常用的代码片段，可以极大的节省开发效率。</p><p>腾讯的QMUI团队开源了一份他们总结的代码片段库<em><a href=\"https://github.com/QMUI/QMUI_iOS_CodeSnippets\" target=\"_blank\">qmui-ios-codesnippets</a>，</em>集成他们的代码片段库就能满足日常的开发需求，提升coding的效率。</p><p><br /></p><h2 id=\"nm4ba\">fastlane</h2><p><a href=\"\" target=\"_blank\">fastlane</a>是一套ruby编写的持续集成工具集。通过fastlane可以实现自动打包、发布等工作。</p><p>原先我都是利用Xcode提供的 <code>xcodebuild</code> 命令自定义了一个 <code>xpublish</code> 脚本来进行打包，详细的配置过程可以参考：<a href=\"https://juejin.im/post/5be2e07fe51d454d5c7c2b96\" target=\"_blank\">iOS--两套自动打包脚本</a>，不过当我发现有 <code>fastlane</code> 这个神器后果断放弃了原来使用的脚本，主要原因当然还是 <code>fastlane</code> 更加全面和强大。 <code>fastlane</code> 的集成过程比较简单，网上有很多资料，可以参考<a href=\"https://whlsxl.github.io/fastlane1/\" target=\"_blank\">小团队的自动化发布--Fastlane带来的全自动化发布</a>。</p><p>因为我们项目已经使用Jenkins进行持续集成，日常使用 <code>fastlane</code> 并不多，主要会在偶尔打单独的测试包或审核包时才会使用，这里简单总结一下我的fastlane配置。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22default_platform(%3Aios)%5Cn%5Cnplatform%20%3Aios%20do%5Cn%20%20desc%20%5C%22send%20ipa%20to%20pgyer%5C%22%5Cn%20%20lane%20%3Apgyer%20do%5Cn%20%20%20%20%23%20%E6%89%A7%E8%A1%8Cpod%20install%20%E9%9C%80%E8%A6%81%E5%9C%A8Gemfile%E9%87%8C%E9%85%8D%E7%BD%AEcocoapods%5Cn%20%20%20%20cocoapods(%5Cn%20%20%20%20%20%20clean%3A%20true%2C%5Cn%20%20%20%20%20%20podfile%3A%20%5C%22.%2FPodfile%5C%22%5Cn%20%20%20%20)%5Cn%20%20%20%20%23%20%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE%5Cn%20%20%20%20build_app(workspace%3A%20%5C%22****.xcworkspace%5C%22%2C%20scheme%3A%20%5C%22****%5C%22%2C%20export_method%3A%20%5C%22ad-hoc%5C%22%2C%20output_directory%3A%20%5C%22.%2Ffastlane%2Fpackage%5C%22%2C%20configuration%3A%20%5C%22Release%5C%22)%5Cn%20%20%20%20%23%20%E4%B8%8A%E4%BC%A0%E8%92%B2%E5%85%AC%E8%8B%B1%20%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%89%E8%A3%85%E8%92%B2%E5%85%AC%E8%8B%B1%E6%8F%92%E4%BB%B6%5Cn%20%20%20%20pgyer(api_key%3A%20%5C%22********%5C%22%2C%20user_key%3A%20%5C%22**********%5C%22)%5Cn%20%20%20%20%23%20%E4%B8%8A%E4%BC%A0%E5%AE%8C%E6%88%90%E5%90%8E%20%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%20%E9%81%BF%E5%85%8D%E5%BF%98%E8%AE%B0%5Cn%20%20%20%20notification(subtitle%3A%20%5C%22Finished%20Uploading%5C%22%2C%20message%3A%20%5C%22upload%20success%5C%22)%5Cn%20%20end%5Cnend%22%2C%22id%22%3A%22eMiIr%22%7D\"></card><p><br /></p><p>有几点说明：</p><ol start=\"1\"><li>支持cocoapods需要在Gemfile里配置一下</li><p><br /></p></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22%23%20%E9%85%8D%E7%BD%AEcocoapods%EF%BC%8C%E5%B9%B6%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%5Cngem%20'cocoapods'%2C%20'1.7.1'%22%2C%22id%22%3A%22DvbAd%22%7D\"></card><ol start=\"2\"><p><br /></p><li>蒲公英的插件安装命令</li></ol><p><code>fastlane add_plugin pgyer</code> </p><p><br /></p><p>安装完后的Gemfile:</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22source%20%5C%22https%3A%2F%2Frubygems.org%5C%22%5Cn%5Cngem%20%5C%22fastlane%5C%22%5Cn%5Cn%23%20%E9%85%8D%E7%BD%AEcocoapods%EF%BC%8C%E5%B9%B6%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%5Cngem%20'cocoapods'%2C%20'1.7.1'%5Cn%5Cnplugins_path%20%3D%20File.join(File.dirname(__FILE__)%2C%20'fastlane'%2C%20'Pluginfile')%5Cneval_gemfile(plugins_path)%20if%20File.exist%3F(plugins_path)%22%2C%22id%22%3A%222h3P4%22%7D\"></card><p><br /></p><p>更多关于 <code>fastlane</code> 的功能可以查看<a href=\"https://docs.fastlane.tools/actions/\" target=\"_blank\">官方文档中的Actions</a>。</p><p><br /></p><h2 id=\"wtjSf\">Jenkins</h2><p><a href=\"\" target=\"_blank\">Jenkins</a>是一款开源的CI工具，利用Jenkins可以通过规范化的操作流程避免一些低级错误，将开发人员从简单、繁琐的工作中释放出来。关于Jenkins的配置教程网上也是有很多，<a href=\"https://juejin.im/post/5ad6beff6fb9a028c06b5889\" target=\"_blank\">Jenkins 持续集成使用教程</a>就比较详细。</p><p><br /></p><h2 id=\"OTH2U\">SwitchHosts</h2><p><a href=\"\" target=\"_blank\">SwitchHosts</a>是一个开源的用于hosts管理和切换的软件。</p><p>对于绝大多数公司肯定存在测试环境和线上环境，通常我们需要在测试环境验证无误后才会发布到正式环境，这就需要客户端在开发阶段能够请求不同的服务器IP，利用 <code>SwitchHosts</code> 和 <code>Charles</code> 就能实现不修改客户端代码的情况下访问不同的服务器IP。这样做就能避免了客户端打包时需要根据需求切换访问地址，之前就有公司误将测试环境的App发布给用户的情况。<cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-03T11:35:20.000Z",
    "deleted_at": null,
    "created_at": "2019-06-28T05:36:06.000Z",
    "updated_at": "2019-07-03T11:35:20.000Z",
    "published_at": "2019-07-03T11:35:20.000Z",
    "first_published_at": "2019-06-28T05:47:17.000Z",
    "word_count": 1030,
    "cover": null,
    "description": "categories: iOStags: [总结]工欲善其事必先利其器，合理的利用工具，提升开发效率，不仅仅帮助我们节省时间，关键是能帮我们从一些重复、低效的工作中抽离出来，专注于有挑战，有深度的问题，不断提升自己。这里总结一些我在日常开发中提升开发效率的一些技巧，如果您有更好的提升效率的方法...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1968466,
    "slug": "unf24m",
    "title": "复盘一次内存优化",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-07-03T11:35:20.078Z",
      "updated_at": "2019-07-03T11:35:20.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-06-19T06:54:31.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-06-19T06:54:31.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"PMUtg\"></a>\n# 背景\n> 最近有用户反馈，App在进入后台后经常会被杀死，需要重新启动，对于用户来说，这样的体验无疑非常糟糕。当App内存消耗比较大，切换到其他App时，即使其他App向系统申请的内存不是特别大，系统也会因为资源紧张，优先把内存消耗较多的App回收，这就出现了用户反馈的问题。要想解决这个问题，就需要对App的内存进行优化。\n\n\n<a name=\"deoSu\"></a>\n# 常见的内存问题有哪些？\n\n- 内存泄漏：申请的内存空间使用完毕之后未回收\n> 一次两次的内存泄漏危害还好，但是如果一直泄漏，内存迟早要被消耗光，导致App崩溃，因此在日常开发过程中一定要避免内存泄漏\n\n- 内存常驻：内存不合理运用，存在已分配内存的引用，但实际中程序不会再使用。\n> 因为一些原因，有些对象在App的整个生命周期中常驻，比如单例，如果不善加管理，任由这些内存常驻，App的内存就会一直居高不下，这类问题很难利用工具直接定位，需要我们结合代码分析\n\n- 内存峰值过大：某个场景下，内存消耗大幅增加，产生一个较高的内存峰值\n> 某些场景可能因为代码的原因，导致内存瞬间大幅增加，这时就需要针对性分析，排查内存增加的原因，并进行优化\n\n- 内存溢出：申请内存时，系统没有足够的内存空间供其使用，导致App崩溃\n> 当内存消耗一直比较高，新申请的内存又比较大，就有可能导致内存溢出，这时App就会被系统杀死，也就是OOM\n\n<br />\n<a name=\"te3Wg\"></a>\n# 优化思路\n<a name=\"nwgan\"></a>\n### 1. 利用Instrument分析内存\nInstrument是苹果提供的分析工具，可以利用Instrument分析内存分配和内存泄漏的情况。网上关于Instrument使用的教程非常多，这里我总结几点注意点。\n\n- 利用Instrument分析内存主要依赖 `Allocations` 和 `Leaks` 两个选项，分别对应内存分配和内存泄漏\n- `Allocations` 分析内存时，总的内存占用 = `All Heap Allocations` + `All Anonymous VM:` \n  - `All Heap Allocations` App运行在堆上的内存，对应着由代码生成的各种实例对象\n  - `All Anonymous VM:` 匿名的虚拟内存，这里包含一些系统模块的内存占用，也有一些保证我们代码正常运行不可缺少的部分\n    - CG raster data（光栅化数据，也就是像素数据。注意不一定是图片，一块显示缓存里也可能是文字或者其他内容。通常每像素消耗 4 个字节）\n    - Image IO（图片编解码缓存）\n    - Stack (每个线程都会需要500KB左右的栈空间)\n    - CoreAnimation\n    - SQLite\n    - Network\n- 如果所有的calltree显示的都是地址时，可以确认一下 `Debug Information Format` 是不是选择的 `DWARF with dSYM File` \n- Instrument每一列的数据解释\n| 列名 | 含义 |\n| :---: | :---: |\n| Graph | 是否选择要绘制对应Category的走势图 |\n| Category | 类别，真实内存、虚拟内存等 |\n| Persistent Bytes | 没有释放的内存大小 |\n| # Persistent | 没有释放的内存个数 |\n| # Transient | 已经释放的内存个数 |\n| Total Bytes | 累计的内存大小 |\n| # Total | 累计的内存个数 |\n| Bytes Used | 占用的字节大小 |\n| Count | 申请内存的次数 |\n| Symbol Name | 调用栈信息 |\n\n\n我这边经过使用Instrument对内存的分析，很快就定位到了 `Kingfisher` 这个库。接下来，重点调研 `Kingfisher` \n\n<a name=\"AvPoN\"></a>\n### 2. Kingfisher内存优化\n首先查看Kingfisher有关内存问题的[issues](https://github.com/onevcat/Kingfisher/issues?utf8=✓&q=is%3Aissue+is%3Aclosed+memory)，通过查看这些issues终于明白了，原来Kingfisher V4版本在设计之初选择了一个相对比较激进的处理图片内存缓存的方法，让图片在内存中无限制的缓存，直到遇到内存警告时再进行清理。通常情况下，这个策略可以很好的工作，但是有些情况下系统并不会及时、准确的传递内存警告，这就会导致App有概率被杀死，尤其在一些低端设备上。在Kingfisher V5版本，喵神已经调整了策略，针对Kingfisher V4版本也可以通过设置最大缓存值来限制。\n\n下面是喵神的原话：\n> In Kingfisher 4, by default, the memory cache was using a \"greedy\" way to accept images. It will keep sending images to memory cache without an upper limitation, until a `.didReceiveMemoryWarningNotification` received. As soon as the system detects the memory availability level is low, Kingfisher will free up the used memory to make the system happy.\n> This mechanism worked well, at least for a time. We received reports on users apps crash due to memory pressure recently. After some investigation, we found that sometimes, the system won't deliver the `.didReceiveMemoryWarningNotification` correctly. It, in turn, makes Kingfisher think there is still plenty of memory to use. But it is not the truth.\n> This problem can be fixed by limiting the max memory cache size in Kingfisher. But since the default behavior is \"no limit\", so it keeps happening for new users of Kingfisher. In Kingfisher 5, we use a more conservative strategy by default. Now a maximum of 25% device memory would be used as the memory cache.\n\n因为Kingfisher V5需要从iOS 10开始支持，我们项目需要支持iOS 9系统，所以我就基于Kingfisher V4进行优化。\n<a name=\"NywtA\"></a>\n#### 2.1 限制图片缓存大小\n正如喵神在文档中讲的，Kingfisher V4版本可以通过限制图片缓存的大小来避免内存增长过大的情况。为了能充分利用各个型号设备的内存，我这里参考了Kingfisher V5的策略，限制图片缓存大小为当前设备最大物理内存的5%。\n\n```swift\nlet totalMemory = ProcessInfo.processInfo.physicalMemory\nlet costLimit = totalMemory / 20\nlet costMemory = (costLimit > UInt.max) ? UInt.max : UInt(costLimit)\nImageCache.default.maxMemoryCost = costMemory\n```\n\n<a name=\"WRHRD\"></a>\n#### 2.2 及时停止不必要的图片请求\nKingfisher提供了 `cancelDownloadTask` 方法，可以在一些合适时机主动停止图片的下载请求，比如对于列表页面，可以通过实现 `didEndDisplaying` 代理回调，在回调中执行 `cell.imageView.kf.cancelDownloadTask()` 来停止图片下载。\n\n<a name=\"OmOXQ\"></a>\n### 3. 内存常驻排查\n内存常驻问题相对比较难排查，这里总结一下我的解决思路：\n<a name=\"EjaD4\"></a>\n#### 3.1 使用懒加载方式延迟加载一些不需要立即使用的对象或资源\n结合代码分析项目中是否存在一些对象或资源并不需要立即创建，将这些对象或资源采用懒加载的方式在需要的时候再进行加载，比如我们项目中在进入App后不仅加载了书城，同时还加载了福利页面，事实上福利页面是一个WebView页面相对比较消耗内存，而用户不一定需要进入福利页面，这就增加了不必要的内存消耗。\n\n<a name=\"15goR\"></a>\n#### 3.2 避免单例滥用\n单例对象在整个App的生命周期内都存活，结合代码分析项目的单例是否一定要存在，单例中是否存在一些不必要的对象，能否将它们移除。\n\n<a name=\"cjarl\"></a>\n#### 3.3 图片加载优化\n\n- 避免使用 `[UIColor colorWithPatternImage:]` 方法\n\n`[UIColor colorWithPatternImage:]` 这个方法会引用一个加载到内存的图片，同时在内存中创建出另一个对象，可以使用 self.view.layer.contents = (id) image.CGImage; 替换，以优化内存。\n\n- 善用 `imageNamed:` 和 `contentsOfFile:` 方法\n\n这两个方法都可以加载图片，区别是 `imageNamed:` 会在内存中缓存图片资源， `contentsOfFile:` 不会缓存图片资源，因此，根据实际情况合理选择加载方式，有助于内存优化。\n\n<a name=\"FnSmF\"></a>\n#### 3.4 删除冗余的模型字段\n随着版本迭代，有些接口字段已经不再使用，这时及时将这些字段移除，有助于减少这些模型占用的内存空间，积少成多，优化内存。\n\n<a name=\"E4BtI\"></a>\n### 4. 分析对比优化效果\n完成优化工作后，还需要对比优化前后的内存，用数据来表现优化的效果。这时可以利用 `Instrument` 的 `Mark Generation` 功能，分别统计每个功能模块优化前后的内存增长。经过统计对比，我们项目在阅读器翻页过程中的性能优化最明显，达到了60%。这是因为我们在阅读器中插入了大量的广告图片，如果按照Kingfisher的默认缓存设置，这些图片会一直保留在内存中，等待内存警告或进入后台时才会释放，限制了缓存最大值后，这个现象自然就得到了大幅度的优化。\n\n\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"PMUtg\">背景</h1><blockquote><p>最近有用户反馈，App在进入后台后经常会被杀死，需要重新启动，对于用户来说，这样的体验无疑非常糟糕。当App内存消耗比较大，切换到其他App时，即使其他App向系统申请的内存不是特别大，系统也会因为资源紧张，优先把内存消耗较多的App回收，这就出现了用户反馈的问题。要想解决这个问题，就需要对App的内存进行优化。</p></blockquote><p><br /></p><h1 id=\"deoSu\">常见的内存问题有哪些？</h1><ul><li>内存泄漏：申请的内存空间使用完毕之后未回收</li></ul><blockquote><p><span class=\"lake-fontsize-9\">一次两次的内存泄漏危害还好，但是如果一直泄漏，内存迟早要被消耗光，导致App崩溃，因此在日常开发过程中一定要避免内存泄漏</span></p></blockquote><ul><li>内存常驻：内存不合理运用，存在已分配内存的引用，但实际中程序不会再使用。</li></ul><blockquote><p><span class=\"lake-fontsize-9\">因为一些原因</span><span class=\"lake-fontsize-9\">，有些对象在App的整个生命周期中常驻，比如单例，如果不善加管理，任由这些内存常驻，App的内存就会一直居高不下，这类问题很难利用工具直接定位，需要我们结合代码分析</span></p></blockquote><ul><li>内存峰值过大：某个场景下，内存消耗大幅增加，产生一个较高的内存峰值</li></ul><blockquote><p><span>某些场景可能因为代码的原因，导致内存瞬间大幅增加，这时就需要针对性分析，排查内存增加的原因，并进行优化</span></p></blockquote><ul><li>内存溢出：申请内存时，系统没有足够的内存空间供其使用，导致App崩溃</li></ul><blockquote><p><span class=\"lake-fontsize-9\">当内存消耗一直比较高，新申请的内存又比较大，就有可能导致内存溢出，这时App就会被系统杀死，也就是OOM</span></p></blockquote><p><span class=\"lake-fontsize-9\"><br /></span></p><h1 id=\"te3Wg\">优化思路</h1><h3 id=\"nwgan\">1. 利用Instrument分析内存</h3><p>Instrument是苹果提供的分析工具，可以利用Instrument分析内存分配和内存泄漏的情况。网上关于Instrument使用的教程非常多，这里我总结几点注意点。</p><ul><li>利用Instrument分析内存主要依赖 <code>Allocations</code> 和 <code>Leaks</code> 两个选项，分别对应内存分配和内存泄漏</li><li><code>Allocations</code> 分析内存时，总的内存占用 = <code>All Heap Allocations</code> + <code>All Anonymous VM:</code> </li></ul><ul data-lake-indent=\"1\"><li><code>All Heap Allocations</code> App运行在堆上的内存，对应着由代码生成的各种实例对象</li><li><code>All Anonymous VM:</code> 匿名的虚拟内存，这里包含一些系统模块的内存占用，也有一些保证我们代码正常运行不可缺少的部分</li></ul><ul data-lake-indent=\"2\"><li>CG raster data（光栅化数据，也就是像素数据。注意不一定是图片，一块显示缓存里也可能是文字或者其他内容。通常每像素消耗 4 个字节）</li><li>Image IO（图片编解码缓存）</li><li>Stack (每个线程都会需要500KB左右的栈空间)</li><li>CoreAnimation</li><li>SQLite</li><li>Network</li></ul><ul><li>如果所有的calltree显示的都是地址时，可以确认一下 <code>Debug Information Format</code> 是不是选择的 <code>DWARF with dSYM File</code> </li><li>Instrument每一列的数据解释</li></ul><table class=\"lake-table\" style=\"width: 748px;\"><colgroup><col width=\"240\"></col><col width=\"506\"></col></colgroup><tbody><tr><td style=\"text-align: center; background-color: #E9E9E9;\"><p>列名</p></td><td style=\"text-align: center; background-color: #E9E9E9;\"><p>含义</p></td></tr><tr><td style=\"text-align: center;\"><p>Graph</p></td><td style=\"text-align: center;\"><p>是否选择要绘制对应Category的走势图</p></td></tr><tr><td style=\"text-align: center;\"><p>Category</p></td><td style=\"text-align: center;\"><p>类别，真实内存、虚拟内存等</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>Persistent Bytes</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>没有释放的内存大小</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p># Persistent</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>没有释放的内存个数</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p># Transient</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>已经释放的内存个数</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>Total Bytes</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>累计的内存大小</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p># Total</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>累计的内存个数</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>Bytes Used</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>占用的字节大小</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>Count</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>申请内存的次数</p></td></tr><tr><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>Symbol Name</p></td><td colspan=\"1\" style=\"text-align: center; background-color: #FFFFFF;\"><p>调用栈信息</p></td></tr></tbody></table><p><br /></p><p>我这边经过使用Instrument对内存的分析，很快就定位到了 <code>Kingfisher</code> 这个库。接下来，重点调研 <code>Kingfisher</code> </p><p><br /></p><h3 id=\"AvPoN\">2. Kingfisher内存优化</h3><p>首先查看Kingfisher有关内存问题的<a href=\"https://github.com/onevcat/Kingfisher/issues?utf8=✓&amp;q=is%3Aissue+is%3Aclosed+memory\" target=\"_blank\">issues</a>，通过查看这些issues终于明白了，原来Kingfisher V4版本在设计之初选择了一个相对比较激进的处理图片内存缓存的方法，让图片在内存中无限制的缓存，直到遇到内存警告时再进行清理。通常情况下，这个策略可以很好的工作，但是有些情况下系统并不会及时、准确的传递内存警告，这就会导致App有概率被杀死，尤其在一些低端设备上。在Kingfisher V5版本，喵神已经调整了策略，针对Kingfisher V4版本也可以通过设置最大缓存值来限制。</p><p><br /></p><p>下面是喵神的原话：</p><blockquote style=\"padding-left: 1em;\"><p>In Kingfisher 4, by default, the memory cache was using a &quot;greedy&quot; way to accept images. It will keep sending images to memory cache without an upper limitation, until a <code>.didReceiveMemoryWarningNotification</code> received. As soon as the system detects the memory availability level is low, Kingfisher will free up the used memory to make the system happy.</p><p>This mechanism worked well, at least for a time. We received reports on users apps crash due to memory pressure recently. After some investigation, we found that sometimes, the system won't deliver the <code>.didReceiveMemoryWarningNotification</code> correctly. It, in turn, makes Kingfisher think there is still plenty of memory to use. But it is not the truth.</p><p>This problem can be fixed by limiting the max memory cache size in Kingfisher. But since the default behavior is &quot;no limit&quot;, so it keeps happening for new users of Kingfisher. In Kingfisher 5, we use a more conservative strategy by default. Now a maximum of 25% device memory would be used as the memory cache.</p></blockquote><p>因为Kingfisher V5需要从iOS 10开始支持，我们项目需要支持iOS 9系统，所以我就基于Kingfisher V4进行优化。</p><h4 id=\"NywtA\">2.1 限制图片缓存大小</h4><p>正如喵神在文档中讲的，Kingfisher V4版本可以通过限制图片缓存的大小来避免内存增长过大的情况。为了能充分利用各个型号设备的内存，我这里参考了Kingfisher V5的策略，限制图片缓存大小为当前设备最大物理内存的5%。</p><p><br /></p><pre data-lang=\"swift\"><code>let totalMemory = ProcessInfo.processInfo.physicalMemory\nlet costLimit = totalMemory / 20\nlet costMemory = (costLimit &gt; UInt.max) ? UInt.max : UInt(costLimit)\nImageCache.default.maxMemoryCost = costMemory</code></pre><p><br /></p><h4 id=\"WRHRD\">2.2 及时停止不必要的图片请求</h4><p>Kingfisher提供了 <code>cancelDownloadTask</code> 方法，可以在一些合适时机主动停止图片的下载请求，比如对于列表页面，可以通过实现 <code>didEndDisplaying</code> 代理回调，在回调中执行 <code>cell.imageView.kf.cancelDownloadTask()</code> 来停止图片下载。</p><p><br /></p><h3 id=\"OmOXQ\">3. 内存常驻排查</h3><p>内存常驻问题相对比较难排查，这里总结一下我的解决思路：</p><h4 id=\"EjaD4\">3.1 使用懒加载方式延迟加载一些不需要立即使用的对象或资源</h4><p>结合代码分析项目中是否存在一些对象或资源并不需要立即创建，将这些对象或资源采用懒加载的方式在需要的时候再进行加载，比如我们项目中在进入App后不仅加载了书城，同时还加载了福利页面，事实上福利页面是一个WebView页面相对比较消耗内存，而用户不一定需要进入福利页面，这就增加了不必要的内存消耗。</p><p><br /></p><h4 id=\"15goR\">3.2 避免单例滥用</h4><p>单例对象在整个App的生命周期内都存活，结合代码分析项目的单例是否一定要存在，单例中是否存在一些不必要的对象，能否将它们移除。</p><p><br /></p><h4 id=\"cjarl\">3.3 图片加载优化</h4><ul><li>避免使用 <code>[UIColor colorWithPatternImage:]</code> 方法</li></ul><p><code>[UIColor colorWithPatternImage:]</code> 这个方法会引用一个加载到内存的图片，同时在内存中创建出另一个对象，可以使用<span style=\"background-color: \"rgba(0, 0, 0, 0.0588235)\";\"> self.view.layer.contents = (id) image.CGImage; </span>替换，以优化内存。</p><ul><li>善用 <code>imageNamed:</code> 和 <code>contentsOfFile:</code> 方法</li></ul><p>这两个方法都可以加载图片，区别是 <code>imageNamed:</code> 会在内存中缓存图片资源， <code>contentsOfFile:</code> 不会缓存图片资源，因此，根据实际情况合理选择加载方式，有助于内存优化。</p><p><br /></p><h4 id=\"FnSmF\">3.4 删除冗余的模型字段</h4><p>随着版本迭代，有些接口字段已经不再使用，这时及时将这些字段移除，有助于减少这些模型占用的内存空间，积少成多，优化内存。</p><p><br /></p><h3 id=\"E4BtI\">4. 分析对比优化效果</h3><p>完成优化工作后，还需要对比优化前后的内存，用数据来表现优化的效果。这时可以利用 <code>Instrument</code> 的 <code>Mark Generation</code> 功能，分别统计每个功能模块优化前后的内存增长。经过统计对比，我们项目在阅读器翻页过程中的性能优化最明显，达到了60%。这是因为我们在阅读器中插入了大量的广告图片，如果按照Kingfisher的默认缓存设置，这些图片会一直保留在内存中，等待内存警告或进入后台时才会释放，限制了缓存最大值后，这个现象自然就得到了大幅度的优化。</p><p><br /></p><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"PMUtg\">背景</h1><blockquote><p>最近有用户反馈，App在进入后台后经常会被杀死，需要重新启动，对于用户来说，这样的体验无疑非常糟糕。当App内存消耗比较大，切换到其他App时，即使其他App向系统申请的内存不是特别大，系统也会因为资源紧张，优先把内存消耗较多的App回收，这就出现了用户反馈的问题。要想解决这个问题，就需要对App的内存进行优化。</p></blockquote><p><br /></p><h1 id=\"deoSu\">常见的内存问题有哪些？</h1><ul><li>内存泄漏：申请的内存空间使用完毕之后未回收</li></ul><blockquote><p><span class=\"lake-fontsize-9\">一次两次的内存泄漏危害还好，但是如果一直泄漏，内存迟早要被消耗光，导致App崩溃，因此在日常开发过程中一定要避免内存泄漏</span></p></blockquote><ul><li>内存常驻：内存不合理运用，存在已分配内存的引用，但实际中程序不会再使用。</li></ul><blockquote><p><span class=\"lake-fontsize-9\">因为一些原因</span><span class=\"lake-fontsize-9\">，有些对象在App的整个生命周期中常驻，比如单例，如果不善加管理，任由这些内存常驻，App的内存就会一直居高不下，这类问题很难利用工具直接定位，需要我们结合代码分析</span></p></blockquote><ul><li>内存峰值过大：某个场景下，内存消耗大幅增加，产生一个较高的内存峰值</li></ul><blockquote><p><span>某些场景可能因为代码的原因，导致内存瞬间大幅增加，这时就需要针对性分析，排查内存增加的原因，并进行优化</span></p></blockquote><ul><li>内存溢出：申请内存时，系统没有足够的内存空间供其使用，导致App崩溃</li></ul><blockquote><p><span class=\"lake-fontsize-9\">当内存消耗一直比较高，新申请的内存又比较大，就有可能导致内存溢出，这时App就会被系统杀死，也就是OOM</span></p></blockquote><p><span class=\"lake-fontsize-9\"><br /></span></p><h1 id=\"te3Wg\">优化思路</h1><h3 id=\"nwgan\">1. 利用Instrument分析内存</h3><p>Instrument是苹果提供的分析工具，可以利用Instrument分析内存分配和内存泄漏的情况。网上关于Instrument使用的教程非常多，这里我总结几点注意点。</p><ul><li>利用Instrument分析内存主要依赖 <code>Allocations</code> 和 <code>Leaks</code> 两个选项，分别对应内存分配和内存泄漏</li><li><code>Allocations</code> 分析内存时，总的内存占用 = <code>All Heap Allocations</code> + <code>All Anonymous VM:</code> </li></ul><ul data-lake-indent=\"1\"><li><code>All Heap Allocations</code> App运行在堆上的内存，对应着由代码生成的各种实例对象</li><li><code>All Anonymous VM:</code> 匿名的虚拟内存，这里包含一些系统模块的内存占用，也有一些保证我们代码正常运行不可缺少的部分</li></ul><ul data-lake-indent=\"2\"><li>CG raster data（光栅化数据，也就是像素数据。注意不一定是图片，一块显示缓存里也可能是文字或者其他内容。通常每像素消耗 4 个字节）</li><li>Image IO（图片编解码缓存）</li><li>Stack (每个线程都会需要500KB左右的栈空间)</li><li>CoreAnimation</li><li>SQLite</li><li>Network</li></ul><ul><li>如果所有的calltree显示的都是地址时，可以确认一下 <code>Debug Information Format</code> 是不是选择的 <code>DWARF with dSYM File</code> </li><li>Instrument每一列的数据解释</li></ul><card type=\"block\" name=\"table\" value=\"data:%7B%22rows%22%3A11%2C%22cols%22%3A2%2C%22html%22%3A%22%3Ctable%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20748px%3B%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22240%5C%22%20span%3D%5C%221%5C%22%20%2F%3E%3Ccol%20width%3D%5C%22506%5C%22%20span%3D%5C%221%5C%22%20%2F%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20style%3D%5C%22text-align%3A%20center%3B%20background-color%3A%20%23E9E9E9%3B%5C%22%3E%3Cp%3E%E5%88%97%E5%90%8D%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20style%3D%5C%22text-align%3A%20center%3B%20background-color%3A%20%23E9E9E9%3B%5C%22%3E%3Cp%3E%E5%90%AB%E4%B9%89%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20style%3D%5C%22text-align%3A%20center%3B%5C%22%3E%3Cp%3EGraph%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20style%3D%5C%22text-align%3A%20center%3B%5C%22%3E%3Cp%3E%E6%98%AF%E5%90%A6%E9%80%89%E6%8B%A9%E8%A6%81%E7%BB%98%E5%88%B6%E5%AF%B9%E5%BA%94Category%E7%9A%84%E8%B5%B0%E5%8A%BF%E5%9B%BE%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20style%3D%5C%22text-align%3A%20center%3B%5C%22%3E%3Cp%3ECategory%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20style%3D%5C%22text-align%3A%20center%3B%5C%22%3E%3Cp%3E%E7%B1%BB%E5%88%AB%EF%BC%8C%E7%9C%9F%E5%AE%9E%E5%86%85%E5%AD%98%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AD%89%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3EPersistent%20Bytes%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E6%B2%A1%E6%9C%89%E9%87%8A%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%23%20Persistent%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E6%B2%A1%E6%9C%89%E9%87%8A%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AA%E6%95%B0%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%23%20Transient%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E5%B7%B2%E7%BB%8F%E9%87%8A%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AA%E6%95%B0%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3ETotal%20Bytes%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E7%B4%AF%E8%AE%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%23%20Total%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E7%B4%AF%E8%AE%A1%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AA%E6%95%B0%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3EBytes%20Used%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E5%8D%A0%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3ECount%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%AC%A1%E6%95%B0%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3ESymbol%20Name%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22text-align%3A%20center%3B%20vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%E8%B0%83%E7%94%A8%E6%A0%88%E4%BF%A1%E6%81%AF%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%2C%22id%22%3A%22s5xro%22%7D\"></card><p><br /></p><p>我这边经过使用Instrument对内存的分析，很快就定位到了 <code>Kingfisher</code> 这个库。接下来，重点调研 <code>Kingfisher</code> </p><p><br /></p><h3 id=\"AvPoN\">2. Kingfisher内存优化</h3><p>首先查看Kingfisher有关内存问题的<a href=\"https://github.com/onevcat/Kingfisher/issues?utf8=✓&amp;q=is%3Aissue+is%3Aclosed+memory\" target=\"_blank\">issues</a>，通过查看这些issues终于明白了，原来Kingfisher V4版本在设计之初选择了一个相对比较激进的处理图片内存缓存的方法，让图片在内存中无限制的缓存，直到遇到内存警告时再进行清理。通常情况下，这个策略可以很好的工作，但是有些情况下系统并不会及时、准确的传递内存警告，这就会导致App有概率被杀死，尤其在一些低端设备上。在Kingfisher V5版本，喵神已经调整了策略，针对Kingfisher V4版本也可以通过设置最大缓存值来限制。</p><p><br /></p><p>下面是喵神的原话：</p><blockquote style=\"padding-left: 1em;\"><p>In Kingfisher 4, by default, the memory cache was using a &quot;greedy&quot; way to accept images. It will keep sending images to memory cache without an upper limitation, until a <code>.didReceiveMemoryWarningNotification</code> received. As soon as the system detects the memory availability level is low, Kingfisher will free up the used memory to make the system happy.</p><p>This mechanism worked well, at least for a time. We received reports on users apps crash due to memory pressure recently. After some investigation, we found that sometimes, the system won't deliver the <code>.didReceiveMemoryWarningNotification</code> correctly. It, in turn, makes Kingfisher think there is still plenty of memory to use. But it is not the truth.</p><p>This problem can be fixed by limiting the max memory cache size in Kingfisher. But since the default behavior is &quot;no limit&quot;, so it keeps happening for new users of Kingfisher. In Kingfisher 5, we use a more conservative strategy by default. Now a maximum of 25% device memory would be used as the memory cache.</p></blockquote><p>因为Kingfisher V5需要从iOS 10开始支持，我们项目需要支持iOS 9系统，所以我就基于Kingfisher V4进行优化。</p><h4 id=\"NywtA\">2.1 限制图片缓存大小</h4><p>正如喵神在文档中讲的，Kingfisher V4版本可以通过限制图片缓存的大小来避免内存增长过大的情况。为了能充分利用各个型号设备的内存，我这里参考了Kingfisher V5的策略，限制图片缓存大小为当前设备最大物理内存的5%。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22swift%22%2C%22code%22%3A%22let%20totalMemory%20%3D%20ProcessInfo.processInfo.physicalMemory%5Cnlet%20costLimit%20%3D%20totalMemory%20%2F%2020%5Cnlet%20costMemory%20%3D%20(costLimit%20%3E%20UInt.max)%20%3F%20UInt.max%20%3A%20UInt(costLimit)%5CnImageCache.default.maxMemoryCost%20%3D%20costMemory%22%2C%22id%22%3A%22pkwGK%22%7D\"></card><p><br /></p><h4 id=\"WRHRD\">2.2 及时停止不必要的图片请求</h4><p>Kingfisher提供了 <code>cancelDownloadTask</code> 方法，可以在一些合适时机主动停止图片的下载请求，比如对于列表页面，可以通过实现 <code>didEndDisplaying</code> 代理回调，在回调中执行 <code>cell.imageView.kf.cancelDownloadTask()</code> 来停止图片下载。</p><p><br /></p><h3 id=\"OmOXQ\">3. 内存常驻排查</h3><p>内存常驻问题相对比较难排查，这里总结一下我的解决思路：</p><h4 id=\"EjaD4\">3.1 使用懒加载方式延迟加载一些不需要立即使用的对象或资源</h4><p>结合代码分析项目中是否存在一些对象或资源并不需要立即创建，将这些对象或资源采用懒加载的方式在需要的时候再进行加载，比如我们项目中在进入App后不仅加载了书城，同时还加载了福利页面，事实上福利页面是一个WebView页面相对比较消耗内存，而用户不一定需要进入福利页面，这就增加了不必要的内存消耗。</p><p><br /></p><h4 id=\"15goR\">3.2 避免单例滥用</h4><p>单例对象在整个App的生命周期内都存活，结合代码分析项目的单例是否一定要存在，单例中是否存在一些不必要的对象，能否将它们移除。</p><p><br /></p><h4 id=\"cjarl\">3.3 图片加载优化</h4><ul><li>避免使用 <code>[UIColor colorWithPatternImage:]</code> 方法</li></ul><p><code>[UIColor colorWithPatternImage:]</code> 这个方法会引用一个加载到内存的图片，同时在内存中创建出另一个对象，可以使用<span style=\"background-color: rgba(0, 0, 0, 0.0588235);\"> self.view.layer.contents = (id) image.CGImage; </span>替换，以优化内存。</p><ul><li>善用 <code>imageNamed:</code> 和 <code>contentsOfFile:</code> 方法</li></ul><p>这两个方法都可以加载图片，区别是 <code>imageNamed:</code> 会在内存中缓存图片资源， <code>contentsOfFile:</code> 不会缓存图片资源，因此，根据实际情况合理选择加载方式，有助于内存优化。</p><p><br /></p><h4 id=\"FnSmF\">3.4 删除冗余的模型字段</h4><p>随着版本迭代，有些接口字段已经不再使用，这时及时将这些字段移除，有助于减少这些模型占用的内存空间，积少成多，优化内存。</p><p><br /></p><h3 id=\"E4BtI\"><anchor />4. 分析对比优化效果</h3><p>完成优化工作后，还需要对比优化前后的内存，用数据来表现优化的效果。这时可以利用 <code>Instrument</code> 的 <code>Mark Generation</code> 功能，分别统计每个功能模块优化前后的内存增长。经过统计对比，我们项目在阅读器翻页过程中的性能优化最明显，达到了60%。这是因为我们在阅读器中插入了大量的广告图片，如果按照Kingfisher的默认缓存设置，这些图片会一直保留在内存中，等待内存警告或进入后台时才会释放，限制了缓存最大值后，这个现象自然就得到了大幅度的优化。<focus /></p><p><br /></p><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-28T07:33:09.000Z",
    "deleted_at": null,
    "created_at": "2019-06-24T11:08:15.000Z",
    "updated_at": "2019-06-28T07:33:09.000Z",
    "published_at": "2019-06-28T07:33:09.000Z",
    "first_published_at": "2019-06-24T12:17:24.000Z",
    "word_count": 2174,
    "cover": null,
    "description": "背景最近有用户反馈，App在进入后台后经常会被杀死，需要重新启动，对于用户来说，这样的体验无疑非常糟糕。当App内存消耗比较大，切换到其他App时，即使其他App向系统申请的内存不是特别大，系统也会因为资源紧张，优先把内存消耗较多的App回收，这就出现了用户反馈的问题。要想解决这个问题，就需要...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]