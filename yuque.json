[
  {
    "id": 1887511,
    "slug": "gltpit",
    "title": "弄透Block",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 4,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-06-12T08:27:21.973Z",
      "updated_at": "2019-06-12T08:27:21.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-05-25T14:37:46.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: iOS<br />tags: [iOS]\n\n---\n\n\n<a name=\"CYyta\"></a>\n# 目标\n\n- [x] Block是什么？\n- [x] 总结Block的使用场景\n- [x] 为什么Block属性需要用copy修饰？\n- [x] __block修饰后为何就可以修改？\n- [x] Block循环引用是怎么产生的？\n\n\n<a name=\"d9d97201\"></a>\n# Block是什么？\n\n> Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数\n\n\n1. 匿名函数\n\n匿名函数是指不带函数名称的函数\n\n2. 带有自动变量\n\n这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态\n\n```objectivec\nint val = 10;\nvoid (^blk)(void) = ^{\n  printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝\n```\n\n3. 为了解决block不能修改自动变量的值，可以使用 `__block` 修饰\n\n```objectivec\n__block int val = 10;\nvoid (^blk)(void) = ^{\n printf(\"val=%d\\n\", val);\n};\nval = 2;\nblk(); // 这里输出的值是2\n```\n\n\n<a name=\"e3d6ac67\"></a>\n# Block的使用场景\n\n1. 声明Block属性 利用Block属性响应事件或传递数据\n\n> UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调\n> Block回调的思路：\n> 声明一个Block属性，注意这里要用copy。\n> 利用Block属性进行回调\n\n\n2. 方法参数为Block 利用Block实现回调\n\n> 以 `[UIView animateWithDuration:animations:]` 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递\n\n\n3. 链式语法\n\n> 链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用\n\n\n```objectivec\n//  CaculateMaker.h\n//  ChainBlockTestApp\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface CaculateMaker : NSObject\n\n@property (nonatomic, assign) CGFloat result;\n\n/*\n* 返回类型 CaculateMaker\n* 传入参数 CGFloat num\n*/\n- (CaculateMaker *(^)(CGFloat num))add;\n\n@end\n\n\n//  CaculateMaker.m\n//  ChainBlockTestApp\n\n\n#import \"CaculateMaker.h\"\n\n@implementation CaculateMaker\n\n- (CaculateMaker *(^)(CGFloat num))add;{\n    return ^CaculateMaker *(CGFloat num){\n        _result += num;\n        return self;\n    };\n}\n\n@end\n\n// 使用\nCaculateMaker *maker = [[CaculateMaker alloc] init];\nmaker.add(20).add(30);\n```\n\n\n<a name=\"fd60c885\"></a>\n# 为什么Block属性需要用copy修饰？\n\n**因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。**<br />**<br />为何会有这种现象出现？\n\nBlock在内存中的位置分为三种类型：\n\n- **NSGlobalBlock** 是位于全局区的block，它是设置在程序的数据区中。\n- **NSStackBlock** 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。\n- **NSMallocBlock** 是位于堆区，在变量作用域结束时不受影响。\n\n这三种类型对应以下三种情况：\n\n1. Block中没有截获自动变量时Block类型是**NSGlobalBlock**\n1. Block中截获自动变量时Block类型是**NSStackBlock**\n1. 堆中的Block无法直接创建，当对**NSStackBlock**类型的Block进行copy时，会将Block放到堆中，Block类型变为**NSMallocBlock**\n\n当Block类型是**NSStackBlock**时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。\n\n```objectivec\n- (void)click:(id)sender {\n        TestClass *test = [[TestClass alloc] init];\n        \n        __block int a = 1;\n        // 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.weakBlock = ^() {\n            NSLog(@\"ok\");\n            a = 2;\n        };\n        \n        // block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.assignBlock = ^() {\n            NSLog(@\"ok\");\n            a = 3;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.copyBlock = ^() {\n            NSLog(@\"ok\");\n            a = 4;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.strongBlock = ^() {\n            NSLog(@\"ok\");\n            a = 5;\n        };\n        \n        NSLog(@\"copy property: %@\", test.copyBlock);\n        NSLog(@\"assign property: %@\", test.assignBlock);\n        NSLog(@\"weak property: %@\", test.weakBlock);\n        NSLog(@\"strong property: %@\", test.strongBlock);\n        \n        \n        [test start];\n    }\n```\n\n\n<a name=\"7a61fc63\"></a>\n# __block修饰后为何就可以修改局部变量？\n\n首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br />因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。\n\n加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br />定义一个 `__block int a = 10;`  会变成 `__Block_byref_a_0 *a;` <br />`__Block_byref_a_0` 的结构体如下所示：\n\n```objectivec\nstruct __Block_byref_a_0 {\n void *__isa;\n __Block_byref_a_0 *__forwarding; // forwarding指针\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n int a; // 原变量同类型变量\n};\n```\n\n结构体中有一个**forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量->forwarding->原变量同类型变量**\n\n如果在block中直接修改变量的值，实质的过程是新变量->__forwarding->原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。\n\n这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收\n\n总结：<br />**block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。**\n\n\n<a name=\"0eccb7a1\"></a>\n# Block的循环引用是怎么产生的？\n\n我们先看一段block导致循环引用的代码：\n\n```objectivec\nTestClass *test = [[TestClass alloc] init]; \n\ntest.copyBlock = ^() {\n    NSLog(@\"ok: %d\", test.result);\n};\n```\n\n当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br />test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。\n\n并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：\n\n```objectivec\n// self-->requestModel-->block-->self \n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// 虽然存在引用环，但是通过主动释放requestModel打破了循环\n[self.requestModel requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n    self.requestModel = nil;\n}];\n\n// t-->block-->self 不存在循环引用\nTest *t = [[Test alloc] init];\n\n[t requestData:^(NSData *data) {\n    self.name = @\"leafly\";\n}];\n\n// AFNetworking-->block-->self 不存在循环引用\n[AFNetworking requestData:^(NSData *data) {\n    self.name = @\"lealfy\";\n}];\n```\n\n",
    "body_draft": "",
    "body_html": "<p><span>categories: iOS</span></p><p><span>tags: [iOS]</span></p><hr /><p><br /></p><h1 id=\"CYyta\">目标</h1><ul class=\"lake-list\"><li class=\"lake-list-node lake-list-task\"><input type=\"checkbox\" checked=\"checked\" />Block是什么？</li><li class=\"lake-list-node lake-list-task\"><input type=\"checkbox\" checked=\"checked\" />总结Block的使用场景</li><li class=\"lake-list-node lake-list-task\"><input type=\"checkbox\" checked=\"checked\" />为什么Block属性需要用copy修饰？</li><li class=\"lake-list-node lake-list-task\"><input type=\"checkbox\" checked=\"checked\" />__block修饰后为何就可以修改？</li><li class=\"lake-list-node lake-list-task\"><input type=\"checkbox\" checked=\"checked\" />Block循环引用是怎么产生的？</li></ul><p><br /></p><p><br /></p><h1 id=\"d9d97201\">Block是什么？</h1><p><br /></p><blockquote><p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p></blockquote><p><br /></p><ol start=\"1\"><li>匿名函数</li></ol><p><br /></p><p>匿名函数是指不带函数名称的函数</p><p><br /></p><ol start=\"2\"><li>带有自动变量</li></ol><p><br /></p><p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p><p><br /></p><pre data-lang=\"objectivec\"><code>int val = 10;\nvoid (^blk)(void) = ^{\n  printf(&quot;val=%d\\n&quot;, val);\n};\nval = 2;\nblk(); // 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝</code></pre><p><br /></p><ol start=\"3\"><li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li></ol><p><br /></p><pre data-lang=\"objectivec\"><code>__block int val = 10;\nvoid (^blk)(void) = ^{\n printf(&quot;val=%d\\n&quot;, val);\n};\nval = 2;\nblk(); // 这里输出的值是2</code></pre><p><br /></p><p><br /></p><h1 id=\"e3d6ac67\">Block的使用场景</h1><p><br /></p><ol start=\"1\"><li>声明Block属性 利用Block属性响应事件或传递数据</li></ol><p><br /></p><blockquote><p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调</p><p>Block回调的思路：</p><p>声明一个Block属性，注意这里要用copy。</p><p>利用Block属性进行回调</p></blockquote><p><br /></p><ol start=\"2\"><li>方法参数为Block 利用Block实现回调</li></ol><p><br /></p><blockquote><p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p></blockquote><p><br /></p><ol start=\"3\"><li>链式语法</li></ol><p><br /></p><blockquote><p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p></blockquote><p><br /></p><pre data-lang=\"objectivec\"><code>//  CaculateMaker.h\n//  ChainBlockTestApp\n\n#import &lt;Foundation/Foundation.h&gt;\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface CaculateMaker : NSObject\n\n@property (nonatomic, assign) CGFloat result;\n\n/*\n* 返回类型 CaculateMaker\n* 传入参数 CGFloat num\n*/\n- (CaculateMaker *(^)(CGFloat num))add;\n\n@end\n\n\n//  CaculateMaker.m\n//  ChainBlockTestApp\n\n\n#import &quot;CaculateMaker.h&quot;\n\n@implementation CaculateMaker\n\n- (CaculateMaker *(^)(CGFloat num))add;{\n    return ^CaculateMaker *(CGFloat num){\n        _result += num;\n        return self;\n    };\n}\n\n@end\n\n// 使用\nCaculateMaker *maker = [[CaculateMaker alloc] init];\nmaker.add(20).add(30);</code></pre><p><br /></p><p><br /></p><h1 id=\"fd60c885\">为什么Block属性需要用copy修饰？</h1><p><br /></p><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong></p><p>**</p><p>为何会有这种现象出现？</p><p><br /></p><p>Block在内存中的位置分为三种类型：</p><p><br /></p><ul><li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li><li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li><li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li></ul><p><br /></p><p>这三种类型对应以下三种情况：</p><p><br /></p><ol start=\"1\"><li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li><li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li><li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li></ol><p><br /></p><p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p><p><br /></p><pre data-lang=\"objectivec\"><code>- (void)click:(id)sender {\n        TestClass *test = [[TestClass alloc] init];\n        \n        __block int a = 1;\n        // 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.weakBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 2;\n        };\n        \n        // block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS\n        test.assignBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 3;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.copyBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 4;\n        };\n        \n        // block类型是__MallocBlock__ 正常执行\n        test.strongBlock = ^() {\n            NSLog(@&quot;ok&quot;);\n            a = 5;\n        };\n        \n        NSLog(@&quot;copy property: %@&quot;, test.copyBlock);\n        NSLog(@&quot;assign property: %@&quot;, test.assignBlock);\n        NSLog(@&quot;weak property: %@&quot;, test.weakBlock);\n        NSLog(@&quot;strong property: %@&quot;, test.strongBlock);\n        \n        \n        [test start];\n    }</code></pre><p><br /></p><p><br /></p><h1 id=\"7a61fc63\">__block修饰后为何就可以修改局部变量？</h1><p><br /></p><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？</p><p>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p><p><br /></p><p>加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：</p><p>定义一个 <code>__block int a = 10;</code>  会变成 <code>__Block_byref_a_0 *a;</code> </p><p><code>__Block_byref_a_0</code> 的结构体如下所示：</p><p><br /></p><pre data-lang=\"objectivec\"><code>struct __Block_byref_a_0 {\n void *__isa;\n __Block_byref_a_0 *__forwarding; // forwarding指针\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n int a; // 原变量同类型变量\n};</code></pre><p><br /></p><p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p><p><br /></p><p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p><p><br /></p><p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p><p><br /></p><p>总结：</p><p><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。</strong><strong>无论在block内外，都是通过forwarding来访问的</strong><strong>。</strong></p><p><br /></p><p><br /></p><h1 id=\"0eccb7a1\">Block的循环引用是怎么产生的？</h1><p><br /></p><p>我们先看一段block导致循环引用的代码：</p><p><br /></p><pre data-lang=\"objectivec\"><code>TestClass *test = [[TestClass alloc] init]; \n\ntest.copyBlock = ^() {\n    NSLog(@&quot;ok: %d&quot;, test.result);\n};</code></pre><p><br /></p><p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。</p><p>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p><p><br /></p><p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p><p><br /></p><pre data-lang=\"objectivec\"><code>// self--&gt;requestModel--&gt;block--&gt;self \n[self.requestModel requestData:^(NSData *data) {\n    self.name = @&quot;leafly&quot;;\n}];\n\n// 虽然存在引用环，但是通过主动释放requestModel打破了循环\n[self.requestModel requestData:^(NSData *data) {\n    self.name = @&quot;leafly&quot;;\n    self.requestModel = nil;\n}];\n\n// t--&gt;block--&gt;self 不存在循环引用\nTest *t = [[Test alloc] init];\n\n[t requestData:^(NSData *data) {\n    self.name = @&quot;leafly&quot;;\n}];\n\n// AFNetworking--&gt;block--&gt;self 不存在循环引用\n[AFNetworking requestData:^(NSData *data) {\n    self.name = @&quot;lealfy&quot;;\n}];</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><p><span>categories: iOS</span></p><p><span>tags: [iOS]<cursor /></span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22zW4A2%22%7D\"></card><p><br /></p><h1 id=\"CYyta\">目标</h1><ul class=\"lake-list\"><li class=\"lake-list-node lake-list-task\"><card type=\"inline\" name=\"checkbox\" value=\"data:true\"></card>Block是什么？</li><li class=\"lake-list-node lake-list-task\"><card type=\"inline\" name=\"checkbox\" value=\"data:true\"></card>总结Block的使用场景</li><li class=\"lake-list-node lake-list-task\"><card type=\"inline\" name=\"checkbox\" value=\"data:true\"></card>为什么Block属性需要用copy修饰？</li><li class=\"lake-list-node lake-list-task\"><card type=\"inline\" name=\"checkbox\" value=\"data:true\"></card>__block修饰后为何就可以修改？</li><li class=\"lake-list-node lake-list-task\"><card type=\"inline\" name=\"checkbox\" value=\"data:true\"></card>Block循环引用是怎么产生的？</li></ul><p><br /></p><p><br /></p><h1 id=\"d9d97201\">Block是什么？</h1><p><br /></p><blockquote><p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p></blockquote><p><br /></p><ol start=\"1\"><li>匿名函数</li></ol><p><br /></p><p>匿名函数是指不带函数名称的函数</p><p><br /></p><ol start=\"2\"><li>带有自动变量</li></ol><p><br /></p><p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22fc149395%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22int%20val%20%3D%2010%3B%5Cnvoid%20(%5Eblk)(void)%20%3D%20%5E%7B%5Cn%20%20printf(%5C%22val%3D%25d%5C%5Cn%5C%22%2C%20val)%3B%5Cn%7D%3B%5Cnval%20%3D%202%3B%5Cnblk()%3B%20%2F%2F%20%E8%BF%99%E9%87%8C%E8%BE%93%E5%87%BA%E7%9A%84%E5%80%BC%E6%98%AF10%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF2%EF%BC%8C%E5%9B%A0%E4%B8%BAblock%E5%9C%A8%E5%AE%9E%E7%8E%B0%E6%97%B6%E5%B0%B1%E4%BC%9A%E5%AF%B9%E5%AE%83%E6%89%80%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A0%88%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%8F%AA%E8%AF%BB%E6%8B%B7%E8%B4%9D%22%7D\"></card><p><br /></p><ol start=\"3\"><li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li></ol><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224e5a1ee6%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22__block%20int%20val%20%3D%2010%3B%5Cnvoid%20(%5Eblk)(void)%20%3D%20%5E%7B%5Cn%20printf(%5C%22val%3D%25d%5C%5Cn%5C%22%2C%20val)%3B%5Cn%7D%3B%5Cnval%20%3D%202%3B%5Cnblk()%3B%20%2F%2F%20%E8%BF%99%E9%87%8C%E8%BE%93%E5%87%BA%E7%9A%84%E5%80%BC%E6%98%AF2%22%7D\"></card><p><br /></p><p><br /></p><h1 id=\"e3d6ac67\">Block的使用场景</h1><p><br /></p><ol start=\"1\"><li>声明Block属性 利用Block属性响应事件或传递数据</li></ol><p><br /></p><blockquote><p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调</p><p>Block回调的思路：</p><p>声明一个Block属性，注意这里要用copy。</p><p>利用Block属性进行回调</p></blockquote><p><br /></p><ol start=\"2\"><li>方法参数为Block 利用Block实现回调</li></ol><p><br /></p><blockquote><p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p></blockquote><p><br /></p><ol start=\"3\"><li>链式语法</li></ol><p><br /></p><blockquote><p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2246df164d%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22%2F%2F%20%20CaculateMaker.h%5Cn%2F%2F%20%20ChainBlockTestApp%5Cn%5Cn%23import%20%3CFoundation%2FFoundation.h%3E%5Cn%23import%20%3CUIKit%2FUIKit.h%3E%5Cn%5Cn%40interface%20CaculateMaker%20%3A%20NSObject%5Cn%5Cn%40property%20(nonatomic%2C%20assign)%20CGFloat%20result%3B%5Cn%5Cn%2F*%5Cn*%20%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%20CaculateMaker%5Cn*%20%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%20CGFloat%20num%5Cn*%2F%5Cn-%20(CaculateMaker%20*(%5E)(CGFloat%20num))add%3B%5Cn%5Cn%40end%5Cn%5Cn%5Cn%2F%2F%20%20CaculateMaker.m%5Cn%2F%2F%20%20ChainBlockTestApp%5Cn%5Cn%5Cn%23import%20%5C%22CaculateMaker.h%5C%22%5Cn%5Cn%40implementation%20CaculateMaker%5Cn%5Cn-%20(CaculateMaker%20*(%5E)(CGFloat%20num))add%3B%7B%5Cn%20%20%20%20return%20%5ECaculateMaker%20*(CGFloat%20num)%7B%5Cn%20%20%20%20%20%20%20%20_result%20%2B%3D%20num%3B%5Cn%20%20%20%20%20%20%20%20return%20self%3B%5Cn%20%20%20%20%7D%3B%5Cn%7D%5Cn%5Cn%40end%5Cn%5Cn%2F%2F%20%E4%BD%BF%E7%94%A8%5CnCaculateMaker%20*maker%20%3D%20%5B%5BCaculateMaker%20alloc%5D%20init%5D%3B%5Cnmaker.add(20).add(30)%3B%22%7D\"></card><p><br /></p><p><br /></p><h1 id=\"fd60c885\">为什么Block属性需要用copy修饰？</h1><p><br /></p><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong></p><p>**</p><p>为何会有这种现象出现？</p><p><br /></p><p>Block在内存中的位置分为三种类型：</p><p><br /></p><ul><li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li><li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li><li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li></ul><p><br /></p><p>这三种类型对应以下三种情况：</p><p><br /></p><ol start=\"1\"><li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li><li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li><li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li></ol><p><br /></p><p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224bf6dc5b%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22-%20(void)click%3A(id)sender%20%7B%5Cn%20%20%20%20%20%20%20%20TestClass%20*test%20%3D%20%5B%5BTestClass%20alloc%5D%20init%5D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20__block%20int%20a%20%3D%201%3B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8Cblock%E7%B1%BB%E5%9E%8B%E6%98%AF__NSStackBlock__%20%20%E5%BD%93TestClass%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E6%97%B6%E5%BF%85%E5%B4%A9%20EXC_BAD_ACCESS%5Cn%20%20%20%20%20%20%20%20test.weakBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%202%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20block%E7%B1%BB%E5%9E%8B%E6%98%AF__NSStackBlock__%20%20%E5%BD%93TestClass%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E6%97%B6%E5%BF%85%E5%B4%A9%20EXC_BAD_ACCESS%5Cn%20%20%20%20%20%20%20%20test.assignBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%203%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20block%E7%B1%BB%E5%9E%8B%E6%98%AF__MallocBlock__%20%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%5Cn%20%20%20%20%20%20%20%20test.copyBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%204%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20block%E7%B1%BB%E5%9E%8B%E6%98%AF__MallocBlock__%20%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%5Cn%20%20%20%20%20%20%20%20test.strongBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20NSLog(%40%5C%22ok%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20a%20%3D%205%3B%5Cn%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22copy%20property%3A%20%25%40%5C%22%2C%20test.copyBlock)%3B%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22assign%20property%3A%20%25%40%5C%22%2C%20test.assignBlock)%3B%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22weak%20property%3A%20%25%40%5C%22%2C%20test.weakBlock)%3B%5Cn%20%20%20%20%20%20%20%20NSLog(%40%5C%22strong%20property%3A%20%25%40%5C%22%2C%20test.strongBlock)%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%5Btest%20start%5D%3B%5Cn%20%20%20%20%7D%22%7D\"></card><p><br /></p><p><br /></p><h1 id=\"7a61fc63\">__block修饰后为何就可以修改局部变量？</h1><p><br /></p><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？</p><p>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p><p><br /></p><p>加上__block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：</p><p>定义一个 <code>__block int a = 10;</code>  会变成 <code>__Block_byref_a_0 *a;</code> </p><p><code>__Block_byref_a_0</code> 的结构体如下所示：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%226ddb7a54%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22struct%20__Block_byref_a_0%20%7B%5Cn%20void%20*__isa%3B%5Cn%20__Block_byref_a_0%20*__forwarding%3B%20%2F%2F%20forwarding%E6%8C%87%E9%92%88%5Cn%20int%20__flags%3B%5Cn%20int%20__size%3B%5Cn%20void%20(*__Block_byref_id_object_copy)(void*%2C%20void*)%3B%5Cn%20void%20(*__Block_byref_id_object_dispose)(void*)%3B%5Cn%20int%20a%3B%20%2F%2F%20%E5%8E%9F%E5%8F%98%E9%87%8F%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%5Cn%7D%3B%22%7D\"></card><p><br /></p><p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p><p><br /></p><p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p><p><br /></p><p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p><p><br /></p><p>总结：</p><p><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。</strong><strong>无论在block内外，都是通过forwarding来访问的</strong><strong>。</strong></p><p><br /></p><p><br /></p><h1 id=\"0eccb7a1\">Block的循环引用是怎么产生的？</h1><p><br /></p><p>我们先看一段block导致循环引用的代码：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%229d701249%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22TestClass%20*test%20%3D%20%5B%5BTestClass%20alloc%5D%20init%5D%3B%20%5Cn%5Cntest.copyBlock%20%3D%20%5E()%20%7B%5Cn%20%20%20%20NSLog(%40%5C%22ok%3A%20%25d%5C%22%2C%20test.result)%3B%5Cn%7D%3B%22%7D\"></card><p><br /></p><p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。</p><p>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p><p><br /></p><p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22dde6e65b%22%2C%22mode%22%3A%22objectivec%22%2C%22code%22%3A%22%2F%2F%20self--%3ErequestModel--%3Eblock--%3Eself%20%5Cn%5Bself.requestModel%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22leafly%5C%22%3B%5Cn%7D%5D%3B%5Cn%5Cn%2F%2F%20%E8%99%BD%E7%84%B6%E5%AD%98%E5%9C%A8%E5%BC%95%E7%94%A8%E7%8E%AF%EF%BC%8C%E4%BD%86%E6%98%AF%E9%80%9A%E8%BF%87%E4%B8%BB%E5%8A%A8%E9%87%8A%E6%94%BErequestModel%E6%89%93%E7%A0%B4%E4%BA%86%E5%BE%AA%E7%8E%AF%5Cn%5Bself.requestModel%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22leafly%5C%22%3B%5Cn%20%20%20%20self.requestModel%20%3D%20nil%3B%5Cn%7D%5D%3B%5Cn%5Cn%2F%2F%20t--%3Eblock--%3Eself%20%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%5CnTest%20*t%20%3D%20%5B%5BTest%20alloc%5D%20init%5D%3B%5Cn%5Cn%5Bt%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22leafly%5C%22%3B%5Cn%7D%5D%3B%5Cn%5Cn%2F%2F%20AFNetworking--%3Eblock--%3Eself%20%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%5Cn%5BAFNetworking%20requestData%3A%5E(NSData%20*data)%20%7B%5Cn%20%20%20%20self.name%20%3D%20%40%5C%22lealfy%5C%22%3B%5Cn%7D%5D%3B%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-12T08:26:49.000Z",
    "deleted_at": null,
    "created_at": "2019-06-11T02:18:48.000Z",
    "updated_at": "2019-06-12T08:26:49.000Z",
    "published_at": "2019-06-12T08:26:49.000Z",
    "first_published_at": "2019-06-11T02:19:19.000Z",
    "word_count": 1877,
    "cover": null,
    "description": "categories: iOStags: [iOS]目标Block是什么？总结Block的使用场景为什么Block属性需要用copy修饰？__block修饰后为何就可以修改？Block循环引用是怎么产生的？Block是什么？Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1887425,
    "slug": "ms0pw9",
    "title": "xopen快捷脚本",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 4,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-06-12T08:27:21.973Z",
      "updated_at": "2019-06-12T08:27:21.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-05-25T14:37:46.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: iOS<br />tags: [iOS]\n\n---\n\n\n<a name=\"wB1xX\"></a>\n# 目标\n\n- [x] 自定义xopen快捷脚本，在终端中快速打开项目\n\n<a name=\"7Hxs8\"></a>\n# 详细教程\n\n1. 创建 `xopen` 文件\n1. 编辑 `xopen` 内容\n\n```ruby\n#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts \"Opening  #{proj}\"\n   `open #{proj}`\nelse\n  puts \"No  xcworkspace|xcproj  file  found\"\nend\n```\n\n3. 将 `xopen` 文件移入 `/usr/local/bin` 目录下\n3. 添加权限 `chmod 777 xopen` \n3. 在终端中，cd到项目目录下，执行xopen\n",
    "body_draft": "",
    "body_html": "<p>categories: iOS</p><p>tags: [iOS]</p><p><br /></p><hr /><p><br /></p><h1 id=\"wB1xX\">目标</h1><ul class=\"lake-list\"><li class=\"lake-list-node lake-list-task\"><input type=\"checkbox\" checked=\"checked\" />自定义xopen快捷脚本，在终端中快速打开项目</li></ul><p><br /></p><h1 id=\"7Hxs8\">详细教程</h1><ol start=\"1\"><li>创建 <code>xopen</code> 文件</li><li>编辑 <code>xopen</code> 内容</li><p><br /></p></ol><pre data-lang=\"ruby\"><code>#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts &quot;Opening  #{proj}&quot;\n   `open #{proj}`\nelse\n  puts &quot;No  xcworkspace|xcproj  file  found&quot;\nend</code></pre><p><br /></p><ol start=\"3\"><li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下</li><li>添加权限 <code>chmod 777 xopen</code> </li><li>在终端中，cd到项目目录下，执行xopen</li></ol>",
    "body_lake": "<!doctype lake><p>categories: iOS</p><p>tags: [iOS]</p><p><br /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22uNSGD%22%7D\"></card><p><br /><cursor /></p><h1 id=\"wB1xX\">目标</h1><ul class=\"lake-list\"><li class=\"lake-list-node lake-list-task\"><card type=\"inline\" name=\"checkbox\" value=\"data:true\"></card>自定义xopen快捷脚本，在终端中快速打开项目</li></ul><p><br /></p><h1 id=\"7Hxs8\">详细教程</h1><ol start=\"1\"><li>创建 <code>xopen</code> 文件</li><li>编辑 <code>xopen</code> 内容</li><p><br /></p></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22ruby%22%2C%22code%22%3A%22%23!%2Fusr%2Fbin%2Fenv%20ruby%5Cnrequire%20'shellwords'%5Cn%5Cnproj%20%3D%20Dir%5B'*.xcworkspace'%5D.first%5Cnproj%20%3D%20Dir%5B'*.xcodeproj'%5D.first%20unless%20proj%5Cn%5Cnif%20proj%5Cn%20%20%20puts%20%5C%22Opening%20%20%23%7Bproj%7D%5C%22%5Cn%20%20%20%60open%20%23%7Bproj%7D%60%5Cnelse%5Cn%20%20puts%20%5C%22No%20%20xcworkspace%7Cxcproj%20%20file%20%20found%5C%22%5Cnend%22%2C%22id%22%3A%22LzAlp%22%7D\"></card><p><br /></p><ol start=\"3\"><li>将 <code>xopen</code> 文件移入 <code>/usr/local/bin</code> 目录下</li><li>添加权限 <code>chmod 777 xopen</code> </li><li>在终端中，cd到项目目录下，执行xopen</li></ol>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-12T08:27:21.000Z",
    "deleted_at": null,
    "created_at": "2019-06-11T02:10:16.000Z",
    "updated_at": "2019-06-12T08:27:22.000Z",
    "published_at": "2019-06-12T08:27:21.000Z",
    "first_published_at": "2019-06-11T02:17:45.000Z",
    "word_count": 109,
    "cover": null,
    "description": "categories: iOStags: [iOS]目标自定义xopen快捷脚本，在终端中快速打开项目详细教程创建 xopen 文件编辑 xopen 内容#!/usr/bin/env ruby require 'shellwords'  proj = Dir['*.xcworkspace']....",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 959531,
    "slug": "nhbulg",
    "title": "Github+Hexo搭建个人博客详细教程",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 4,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-06-11T02:19:19.636Z",
      "updated_at": "2019-06-11T02:19:19.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-05-25T14:37:46.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Hexo\n\n---\n\n<a name=\"sl6tws\"></a>\n#### [](#sl6tws)安装Node.js\n\n1. 安装nvm\n\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n\n2. 安装node\n\n```powershell\n$ nvm install node\n```\n\n3. 验证node是否安装成功\n\n```powershell\n$  node -v\n$  v8.12.0\n```\n<a name=\"t8a8gr\"></a>\n#### [](#t8a8gr)安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n<a name=\"ua2lyy\"></a>\n#### [](#ua2lyy)Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n<a name=\"oefdft\"></a>\n#### [](#oefdft)配置_config.yml\n```\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n<a name=\"s6t5gs\"></a>\n#### [](#s6t5gs)编写博客\n```\n$ hexo new post '文章标题'\n```\n在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n<a name=\"ybauhr\"></a>\n#### [](#ybauhr)推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n<a name=\"padgfi\"></a>\n#### [](#padgfi)多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n\n1. 新建分支 hexo\n\n2. 在设置里将hexo设置为默认分支\n\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n\n<a name=\"xhgmdd\"></a>\n#### [](#xhgmdd)绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n\n1. 购买域名\n\n\n     一般去阿里云购买，具体流程网上很多，就不再细说\n\n2. 配置DNS地址\n\n\n     在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n\n3. 配置hexo文件\n\n\n     在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n\n4. 发布到github\n\n\n我的博客地址是[http://blog.ileafly.com](http://blog.ileafly.com)\n<a name=\"yst3oh\"></a>\n#### [](#yst3oh)绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n<a name=\"qvkuep\"></a>\n#### [](#qvkuep)自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。<br />我比较喜欢的主题是[Anisina](https://github.com/haojen/hexo-theme-Anisina)和[cafe](https://github.com/giscafer/hexo-theme-cafe)，这里就以[cafe](https://github.com/giscafer/hexo-theme-cafe)为例简述一下集成的流程。\n```\n# 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml\n```\n<a name=\"ctisce\"></a>\n#### [](#ctisce)集成评论\n目前比较好用的评论是[LiveRe](https://www.livere.com)，注册并按照City版，获取uid。在__config.yml作如下配置：\n```ruby\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'\n```\n\n\n",
    "body_draft": "tags: [Hexo]\r\ncategories: 教程\n\n---\n\n#### <a name=\"sl6tws\"></a>安装Node.js\n1. 安装nvm\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n2. 安装node\n```powershell\n$ nvm install node\n```\n3. 验证node是否安装成功\n```powershell\n$  node -v\n$  v8.12.0\n```\n#### <a name=\"t8a8gr\"></a>安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n#### <a name=\"ua2lyy\"></a>Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n#### <a name=\"oefdft\"></a>配置\\_config.yml\n```plain\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n#### <a name=\"s6t5gs\"></a>编写博客\n```plain\n$ hexo new post '文章标题'\n```\n在source/\\_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n#### <a name=\"ybauhr\"></a>推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n#### <a name=\"padgfi\"></a>多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n1. 新建分支 hexo\n2. 在设置里将hexo设置为默认分支\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n#### <a name=\"xhgmdd\"></a>绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n1. 购买域名\n      一般去阿里云购买，具体流程网上很多，就不再细说\n2. 配置DNS地址\n      在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n3. 配置hexo文件\n      在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n4. 发布到github\n我的博客地址是[http://www.ileafly.com](http://www.ileafly.com)\n#### <a name=\"yst3oh\"></a>绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n#### <a name=\"qvkuep\"></a>自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。\n我比较喜欢的主题是[Anisina](https://github.com/haojen/hexo-theme-Anisina)和[cafe](https://github.com/giscafer/hexo-theme-cafe)，这里就以[cafe](https://github.com/giscafer/hexo-theme-cafe)为例简述一下集成的流程。\n```\n# 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml\n```\n#### <a name=\"ctisce\"></a>集成评论\n目前比较好用的评论是[LiveRe](https://www.livere.com)，注册并按照City版，获取uid。在\\_\\_config.yml作如下配置：\n```ruby\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'\n```\n\n\n",
    "body_html": "<p>categories: Hexo</p><hr /><h4 id=\"sl6tws\"><a href=\"#sl6tws\"></a>安装Node.js</h4><ol start=\"1\"><li><p>安装nvm</p></li></ol><pre data-lang=\"powershell\"><code>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</code></pre><ol start=\"2\"><li><p>安装node</p></li></ol><pre data-lang=\"powershell\"><code>$ nvm install node</code></pre><ol start=\"3\"><li><p>验证node是否安装成功</p></li></ol><pre data-lang=\"powershell\"><code>$  node -v\n$  v8.12.0</code></pre><h4 id=\"t8a8gr\"><a href=\"#t8a8gr\"></a>安装Hexo</h4><pre data-lang=\"powershell\"><code>$ npm install -g hexo</code></pre><p>安装完成后，进入一个文件夹，执行</p><pre data-lang=\"powershell\"><code>$ hexo init\n$ npm install hexo --save</code></pre><h4 id=\"ua2lyy\"><a href=\"#ua2lyy\"></a>Github创建个人仓库</h4><p>在Github上创建一个新仓库，并命名为  <code>你的github用户名.github.io</code></p><h4 id=\"oefdft\"><a href=\"#oefdft\"></a>配置_config.yml</h4><pre><code>deploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master</code></pre><h4 id=\"s6t5gs\"><a href=\"#s6t5gs\"></a>编写博客</h4><pre><code>$ hexo new post '文章标题'</code></pre><p>在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。</p><h4 id=\"ybauhr\"><a href=\"#ybauhr\"></a>推送站点</h4><pre data-lang=\"powershell\"><code>$ hexo g\n$ hexo d</code></pre><p>上传成功后，访问<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a></p><hr /><p>接下来再介绍一些进阶用法：</p><h4 id=\"padgfi\"><a href=\"#padgfi\"></a>多台电脑管理hexo博客</h4><p>利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。</p><ol start=\"1\"><li><p>新建分支 hexo</p></li></ol><ol start=\"2\"><li><p>在设置里将hexo设置为默认分支</p></li></ol><ol start=\"3\"><li><p>clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支</p></li></ol><ol start=\"4\"><li><p>新电脑需要重新安装hexo环境，安装完成后clone代码到本地</p></li></ol><h4 id=\"xhgmdd\"><a href=\"#xhgmdd\"></a>绑定个人域名</h4><p>拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程</p><ol start=\"1\"><li><p>购买域名</p></li></ol><p>     一般去阿里云购买，具体流程网上很多，就不再细说</p><ol start=\"2\"><li><p>配置DNS地址</p></li></ol><p>     在阿里云后台配置DNS信息，将<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a>的ip绑定到你想要绑定的域名上</p><ol start=\"3\"><li><p>配置hexo文件</p></li></ol><p>     在source目录下，新建文件，命名为<code>CNAME</code>，填入域名地址。</p><ol start=\"4\"><li><p>发布到github</p></li></ol><p>我的博客地址是<a href=\"http://blog.ileafly.com\" target=\"_blank\">http://blog.ileafly.com</a></p><h4 id=\"yst3oh\"><a href=\"#yst3oh\"></a>绑定语雀管理博客内容</h4><p>可以利用语雀管理博客内容，非常方便，详细流程可参考<a href=\"http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/\" target=\"_blank\">使用语雀管理博客</a>。</p><h4 id=\"qvkuep\"><a href=\"#qvkuep\"></a>自定义主题</h4><p>Hexo有非常非常多的主题，你可以在<a href=\"https://hexo.io/themes/index.html\" target=\"_blank\">Themes | Hexo</a>浏览这些主题，选择你喜欢的主题进行使用。</p><p>我比较喜欢的主题是<a href=\"https://github.com/haojen/hexo-theme-Anisina\" target=\"_blank\">Anisina</a>和<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\">cafe</a>，这里就以<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\">cafe</a>为例简述一下集成的流程。</p><pre><code># 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml</code></pre><h4 id=\"ctisce\"><a href=\"#ctisce\"></a>集成评论</h4><p>目前比较好用的评论是<a href=\"https://www.livere.com\" target=\"_blank\">LiveRe</a>，注册并按照City版，获取uid。在__config.yml作如下配置：</p><pre data-lang=\"ruby\"><code>comment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'</code></pre><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>categories: Hexo</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22bYRHS%22%7D\"></card><h4 id=\"sl6tws\"><a href=\"#sl6tws\"></a>安装Node.js</h4><ol start=\"1\"><li><p>安装nvm</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22733bb5df%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20curl%20-o-%20https%3A%2F%2Fraw.githubusercontent.com%2Fcreationix%2Fnvm%2Fv0.30.2%2Finstall.sh%20%7C%20bash%22%7D\"></card><ol start=\"2\"><li><p>安装node</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%220f36d641%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%C2%A0nvm%20install%20node%22%7D\"></card><ol start=\"3\"><li><p>验证node是否安装成功</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b14a43b3%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20%C2%A0node%20-v%5Cn%24%20%20v8.12.0%22%7D\"></card><h4 id=\"t8a8gr\"><a href=\"#t8a8gr\"></a>安装Hexo</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b6bfcc9b%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20npm%20install%20-g%20hexo%22%7D\"></card><p>安装完成后，进入一个文件夹，执行</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22a8df4e5e%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20hexo%20init%5Cn%24%20npm%20install%20hexo%20--save%22%7D\"></card><h4 id=\"ua2lyy\"><a href=\"#ua2lyy\"></a>Github创建个人仓库</h4><p>在Github上创建一个新仓库，并命名为  <code>你的github用户名.github.io</code></p><h4 id=\"oefdft\"><a href=\"#oefdft\"></a>配置_config.yml</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%229f6cd6e3%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%22deploy%3A%5Cn%20%20%20type%3A%20git%5Cn%20%20%20repository%3A%20https%3A%2F%2Fgithub.com%2Fusername%2Fusername.github.io%5Cn%20%20%20branch%3A%20master%22%7D\"></card><h4 id=\"s6t5gs\"><a href=\"#s6t5gs\"></a>编写博客</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%227a38eae7%22%2C%22mode%22%3A%22plain%22%2C%22code%22%3A%22%24%20hexo%20new%20post%20'%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98'%22%7D\"></card><p>在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。</p><h4 id=\"ybauhr\"><a href=\"#ybauhr\"></a>推送站点</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22690feb80%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20hexo%20g%5Cn%24%20hexo%20d%22%7D\"></card><p>上传成功后，访问<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22Tk3SK%22%7D\"></card><p>接下来再介绍一些进阶用法：</p><h4 id=\"padgfi\"><a href=\"#padgfi\"></a>多台电脑管理hexo博客</h4><p>利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。</p><ol start=\"1\"><li><p>新建分支 hexo</p></li></ol><ol start=\"2\"><li><p>在设置里将hexo设置为默认分支</p></li></ol><ol start=\"3\"><li><p>clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支</p></li></ol><ol start=\"4\"><li><p>新电脑需要重新安装hexo环境，安装完成后clone代码到本地</p></li></ol><h4 id=\"xhgmdd\"><a href=\"#xhgmdd\"></a>绑定个人域名</h4><p>拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程</p><ol start=\"1\"><li><p>购买域名</p></li></ol><p>     一般去阿里云购买，具体流程网上很多，就不再细说</p><ol start=\"2\"><li><p>配置DNS地址</p></li></ol><p>     在阿里云后台配置DNS信息，将<a href=\"https://username.github.io\" target=\"_blank\">https://username.github.io</a>的ip绑定到你想要绑定的域名上</p><ol start=\"3\"><li><p>配置hexo文件<cursor /></p></li></ol><p>     在source目录下，新建文件，命名为<code>CNAME</code>，填入域名地址。</p><ol start=\"4\"><li><p>发布到github</p></li></ol><p>我的博客地址是<a href=\"http://blog.ileafly.com\" target=\"_blank\">http://blog.ileafly.com</a></p><h4 id=\"yst3oh\"><a href=\"#yst3oh\"></a>绑定语雀管理博客内容</h4><p>可以利用语雀管理博客内容，非常方便，详细流程可参考<a href=\"http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/\" target=\"_blank\">使用语雀管理博客</a>。</p><h4 id=\"qvkuep\"><a href=\"#qvkuep\"></a>自定义主题</h4><p>Hexo有非常非常多的主题，你可以在<a href=\"https://hexo.io/themes/index.html\" target=\"_blank\">Themes | Hexo</a>浏览这些主题，选择你喜欢的主题进行使用。</p><p>我比较喜欢的主题是<a href=\"https://github.com/haojen/hexo-theme-Anisina\" target=\"_blank\">Anisina</a>和<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\">cafe</a>，这里就以<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\">cafe</a>为例简述一下集成的流程。</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%222ad5521a%22%2C%22code%22%3A%22%23%20%E5%AE%89%E8%A3%85%5Cn%24%20git%20clone%20https%3A%2F%2Fgithub.com%2Fgiscafer%2Fhexo-theme-cafe.git%20themes%2Fcafe%5Cn%5Cn%23%20%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20%60_config.yml%60%20%E4%B8%BB%E9%A2%98%E5%B1%9E%E6%80%A7%20theme%20%E4%B8%BA%20%60cafe%60.%5Cn%5Cn%23%20%E6%9B%B4%E6%96%B0cafe%E6%96%87%E4%BB%B6%5Cncd%20themes%2Fcafe%5Cngit%20pull%5Cn%5Cn%23%20%E4%B8%BB%E9%A2%98%20themes%2Fcafe%2F_config.yml%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%8F%82%E8%80%83%E8%AF%B4%E6%98%8E%E9%85%8D%E7%BD%AE%20https%3A%2F%2Fgithub.com%2Fgiscafer%2Fhexo-theme-cafe%2Fblob%2Fmaster%2F_config.yml%22%7D\"></card><h4 id=\"ctisce\"><a href=\"#ctisce\"></a>集成评论</h4><p>目前比较好用的评论是<a href=\"https://www.livere.com\" target=\"_blank\">LiveRe</a>，注册并按照City版，获取uid。在__config.yml作如下配置：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2298ed6de8%22%2C%22mode%22%3A%22ruby%22%2C%22code%22%3A%22comment%3A%5Cn%20%20%20type%3A%20livere%5Cn%20%20%20livere_id%3A%20'city'%5Cn%20%20%20livere_uid%3A%20'*******'%22%7D\"></card><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-11T01:44:07.000Z",
    "deleted_at": null,
    "created_at": "2018-11-10T01:14:00.000Z",
    "updated_at": "2019-06-11T01:44:07.000Z",
    "published_at": "2019-06-11T01:44:07.000Z",
    "first_published_at": null,
    "word_count": 711,
    "cover": null,
    "description": "categories: Hexo安装Node.js安装nvm$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash安装node$ nvm install node验证node是否...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 959068,
    "slug": "momb9q",
    "title": "使用语雀管理博客",
    "book_id": 173958,
    "book": {
      "id": 173958,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 183307,
      "description": "",
      "creator_id": 183307,
      "public": 1,
      "items_count": 4,
      "likes_count": 0,
      "watches_count": 2,
      "content_updated_at": "2019-06-11T02:19:19.636Z",
      "updated_at": "2019-06-11T02:19:19.000Z",
      "created_at": "2018-11-09T06:36:25.000Z",
      "namespace": "leafly/blog",
      "user": {
        "id": 183307,
        "type": "User",
        "login": "leafly",
        "name": "leafly",
        "description": "iOS、vue、koa",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2018-09-27T09:52:55.000Z",
        "updated_at": "2019-05-25T14:37:46.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 183307,
    "creator": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Hexo\n\n---\n\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n<a name=\"x43bcd\"></a>\n#### [](#x43bcd)Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n<a name=\"wgwlfo\"></a>\n#### [](#wgwlfo)安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n\n1. 安装yuque-hexo\n\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n\n4. 同步文章\n\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n<a name=\"ol3liq\"></a>\n#### [](#ol3liq)如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n",
    "body_draft": "tags: [Hexo]\r\ncategories: 教程\n\n---\n\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n#### <a name=\"x43bcd\"></a>Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n#### <a name=\"wgwlfo\"></a>安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n1. 安装yuque-hexo\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n4. 同步文章\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n#### <a name=\"ol3liq\"></a>如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n",
    "body_html": "<p>categories: Hexo</p><hr /><p>之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用<a href=\"https://jaredforsyth.com/hexo-admin/\" target=\"_blank\">hexo-admin</a>，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客<a href=\"https://www.yuque.com/page/luan.ma/yuque2blog\" target=\"_blank\">静态博客使用语雀编辑器</a>，文中介绍了如何利用语雀管理博客，决定一试。</p><p><br /></p><h4 id=\"x43bcd\"><a href=\"#x43bcd\"></a>Hexo搭建博客</h4><p>首先需要先利用<a href=\"https://hexo.io/zh-cn/index.html\" target=\"_blank\">hexo</a>搭建博客，具体的搭建流程可以参考<a href=\"http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/\" target=\"_blank\">Github+Hexo搭建个人博客详细教程</a></p><p><br /></p><h4 id=\"wgwlfo\"><a href=\"#wgwlfo\"></a>安装语雀插件</h4><p><a href=\"https://github.com/x-cold/yuque-hexo/\" target=\"_blank\">yuque-hexo</a>是一个Node.js环境下的语雀下载器。</p><ol start=\"1\"><li><p>安装yuque-hexo</p></li></ol><ol start=\"2\"><li><p>注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的<a href=\"https://www.yuque.com/leafly/blog\" target=\"_blank\">语雀知识库地址</a></p></li></ol><ol start=\"3\"><li><p>在Hexo博客的目录下面找到package.json文件，进入如下配置：</p></li></ol><pre data-lang=\"json\"><code>{\n&quot;name&quot;: &quot;hexo-blog&quot;, // 这里一般原来就有，直接添加下面的内容即可\n&quot;yuqueConfig&quot;: {\n    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,\n    &quot;login&quot;: &quot;leafly&quot;,\n    &quot;repo&quot;: &quot;blog&quot;,\n    &quot;postPath&quot;: &quot;source/_posts/yuque&quot;\n  },\n}</code></pre><ol start=\"4\"><li><p>同步文章</p></li></ol><pre data-lang=\"powershell\"><code>$ yuque-hexo sync</code></pre><p>执行完毕，会自动将语雀上的文章同步到<code>source/_post/yuque</code>文件夹下</p><pre data-lang=\"powershell\"><code>$ hexo g\n$ hexo d</code></pre><p>将博客内容同步到github。</p><p><br /></p><h4 id=\"ol3liq\"><a href=\"#ol3liq\"></a>如何添加分类、标签、创建时间</h4><p>插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息</p><pre data-lang=\"makedown\"><code>tags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50</code></pre><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>categories: Hexo<cursor /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22sxSd1%22%7D\"></card><p>之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用<a href=\"https://jaredforsyth.com/hexo-admin/\" target=\"_blank\">hexo-admin</a>，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客<a href=\"https://www.yuque.com/page/luan.ma/yuque2blog\" target=\"_blank\">静态博客使用语雀编辑器</a>，文中介绍了如何利用语雀管理博客，决定一试。</p><p><br /></p><h4 id=\"x43bcd\"><a href=\"#x43bcd\"></a>Hexo搭建博客</h4><p>首先需要先利用<a href=\"https://hexo.io/zh-cn/index.html\" target=\"_blank\">hexo</a>搭建博客，具体的搭建流程可以参考<a href=\"http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/\" target=\"_blank\">Github+Hexo搭建个人博客详细教程</a></p><p><br /></p><h4 id=\"wgwlfo\"><a href=\"#wgwlfo\"></a>安装语雀插件</h4><p><a href=\"https://github.com/x-cold/yuque-hexo/\" target=\"_blank\">yuque-hexo</a>是一个Node.js环境下的语雀下载器。</p><ol start=\"1\"><li><p>安装yuque-hexo</p></li></ol><ol start=\"2\"><li><p>注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的<a href=\"https://www.yuque.com/leafly/blog\" target=\"_blank\">语雀知识库地址</a></p></li></ol><ol start=\"3\"><li><p>在Hexo博客的目录下面找到package.json文件，进入如下配置：</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22f584b4cd%22%2C%22mode%22%3A%22json%22%2C%22code%22%3A%22%7B%5Cn%5C%22name%5C%22%3A%20%5C%22hexo-blog%5C%22%2C%20%2F%2F%20%E8%BF%99%E9%87%8C%E4%B8%80%E8%88%AC%E5%8E%9F%E6%9D%A5%E5%B0%B1%E6%9C%89%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E5%8D%B3%E5%8F%AF%5Cn%5C%22yuqueConfig%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22baseUrl%5C%22%3A%20%5C%22https%3A%2F%2Fwww.yuque.com%2Fapi%2Fv2%5C%22%2C%5Cn%20%20%20%20%5C%22login%5C%22%3A%20%5C%22leafly%5C%22%2C%5Cn%20%20%20%20%5C%22repo%5C%22%3A%20%5C%22blog%5C%22%2C%5Cn%20%20%20%20%5C%22postPath%5C%22%3A%20%5C%22source%2F_posts%2Fyuque%5C%22%5Cn%20%20%7D%2C%5Cn%7D%22%7D\"></card><ol start=\"4\"><li><p>同步文章</p></li></ol><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%228a3b6a0e%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20yuque-hexo%20sync%22%7D\"></card><p>执行完毕，会自动将语雀上的文章同步到<code>source/_post/yuque</code>文件夹下</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22690feb80%22%2C%22mode%22%3A%22powershell%22%2C%22code%22%3A%22%24%20hexo%20g%5Cn%24%20hexo%20d%22%7D\"></card><p>将博客内容同步到github。</p><p><br /></p><h4 id=\"ol3liq\"><a href=\"#ol3liq\"></a>如何添加分类、标签、创建时间</h4><p>插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22bbb5f6e4%22%2C%22mode%22%3A%22makedown%22%2C%22code%22%3A%22tags%3A%20%5BHexo%5D%5Cncategories%3A%20%E6%95%99%E7%A8%8B%5Cndate%3A%202018-10-10%2015%3A43%3A50%22%7D\"></card><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-03T10:06:20.000Z",
    "deleted_at": null,
    "created_at": "2018-11-09T12:43:26.000Z",
    "updated_at": "2019-06-03T10:06:20.000Z",
    "published_at": "2019-06-03T10:06:20.000Z",
    "first_published_at": null,
    "word_count": 405,
    "cover": null,
    "description": "categories: Hexo之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用hexo-admin，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客静态博客使用语...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]