[
  {
    "title": "使用语雀管理博客",
    "description": "Test",
    "created_at": "2018-11-09T12:43:26.000Z",
    "updated_at": "2018-11-09T13:33:32.000Z",
    "published_at": "2018-11-09T13:33:32.000Z",
    "format": "asl",
    "slug": "momb9q",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-09T13:31:57.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n之前一直使用hexo搭建自己的个人博客，用的久了就发现随着博客数量的增加，管理越来越麻烦，之前也尝试过使用[hexo-admin](https://jaredforsyth.com/hexo-admin/)，hexo-admin虽然能够达到管理博客的目的，不过界面有点丑，不能忍，一直想找一个替代方案，最近在语雀中读到了一篇博客[静态博客使用语雀编辑器](https://www.yuque.com/page/luan.ma/yuque2blog)，文中介绍了如何利用语雀管理博客，决定一试。\n\n<a name=\"x43bcd\"></a>\n#### [](#x43bcd)Hexo搭建博客\n首先需要先利用[hexo](https://hexo.io/zh-cn/index.html)搭建博客，具体的搭建流程可以参考[Github+Hexo搭建个人博客详细教程](http://www.ileafly.com/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/)\n\n<a name=\"wgwlfo\"></a>\n#### [](#wgwlfo)安装语雀插件\n[yuque-hexo](https://github.com/x-cold/yuque-hexo/)是一个Node.js环境下的语雀下载器。\n\n1. 安装yuque-hexo\n\n2. 注册语雀，创建知识库，公开知识库，获得博客知识库的地址，比如我的[语雀知识库地址](https://www.yuque.com/leafly/blog)\n\n3. 在Hexo博客的目录下面找到package.json文件，进入如下配置：\n\n```json\n{\n\"name\": \"hexo-blog\", // 这里一般原来就有，直接添加下面的内容即可\n\"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"leafly\",\n    \"repo\": \"blog\",\n    \"postPath\": \"source/_posts/yuque\"\n  },\n}\n```\n\n4. 同步文章\n\n```powershell\n$ yuque-hexo sync\n```\n执行完毕，会自动将语雀上的文章同步到`source/_post/yuque`文件夹下\n```powershell\n$ hexo g\n$ hexo d\n```\n将博客内容同步到github。\n\n<a name=\"ol3liq\"></a>\n#### [](#ol3liq)如何添加分类、标签、创建时间\n插件支持Front-matter，在文章顶部添加分类、标签、创建时间等信息\n```makedown\ntags: [Hexo]\ncategories: 教程\ndate: 2018-10-10 15:43:50\n```\n\n\n",
    "tags": [
      "Hexo"
    ],
    "categories": "Hexo",
    "<br />categories": "教程"
  },
  {
    "title": "Github+Hexo搭建个人博客详细教程",
    "description": "安装Node.js安装nvm$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash 安装node$ nvm install node 验证node是否安装成功$  node -v...",
    "created_at": "2018-11-10T01:14:00.000Z",
    "updated_at": "2018-11-10T02:45:15.000Z",
    "published_at": "2018-11-10T02:45:15.000Z",
    "format": "asl",
    "slug": "nhbulg",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-09T13:31:57.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n<a name=\"sl6tws\"></a>\n#### [](#sl6tws)安装Node.js\n\n1. 安装nvm\n\n```powershell\n$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash\n```\n\n2. 安装node\n\n```powershell\n$ nvm install node\n```\n\n3. 验证node是否安装成功\n\n```powershell\n$  node -v\n$  v8.12.0\n```\n<a name=\"t8a8gr\"></a>\n#### [](#t8a8gr)安装Hexo\n```powershell\n$ npm install -g hexo\n```\n安装完成后，进入一个文件夹，执行\n```powershell\n$ hexo init\n$ npm install hexo --save\n```\n<a name=\"ua2lyy\"></a>\n#### [](#ua2lyy)Github创建个人仓库\n在Github上创建一个新仓库，并命名为  `你的github用户名.github.io`\n<a name=\"oefdft\"></a>\n#### [](#oefdft)配置_config.yml\n```\ndeploy:\n   type: git\n   repository: https://github.com/username/username.github.io\n   branch: master\n```\n<a name=\"s6t5gs\"></a>\n#### [](#s6t5gs)编写博客\n```\n$ hexo new post '文章标题'\n```\n在source/_posts/ 文件夹下新建了博客，文件格式为markdown，编辑此文件。\n<a name=\"ybauhr\"></a>\n#### [](#ybauhr)推送站点\n```powershell\n$ hexo g\n$ hexo d\n```\n上传成功后，访问[https://username.github.io](https://username.github.io)\n\n---\n\n接下来再介绍一些进阶用法：\n<a name=\"padgfi\"></a>\n#### [](#padgfi)多台电脑管理hexo博客\n利用github管理博客内容，进行多台电脑的同步，既可以新建一个仓库单独进行博客内容的管理，也可以在现有仓库的基础上新建一个分支进行管理，相比较而言新建分支管理更加便捷。\n\n1. 新建分支 hexo\n\n2. 在设置里将hexo设置为默认分支\n\n3. clone代码到本地，在hexo分支下进行博客的编写，利用hexo d同步到master分支，同时手动同步到hexo分支\n\n4. 新电脑需要重新安装hexo环境，安装完成后clone代码到本地\n\n<a name=\"xhgmdd\"></a>\n#### [](#xhgmdd)绑定个人域名\n拥有自己的独立域名能瞬间提升博客的逼格，接下来就是绑定个人域名的流程\n\n1. 购买域名\n\n\n     一般去阿里云购买，具体流程网上很多，就不再细说\n\n2. 配置DNS地址\n\n\n     在阿里云后台配置DNS信息，将[https://username.github.io](https://username.github.io)的ip绑定到你想要绑定的域名上\n\n3. 配置hexo文件\n\n\n     在source目录下，新建文件，命名为`CNAME`，填入域名地址。\n\n4. 发布到github\n\n\n我的博客地址是[http://www.ileafly.com](http://www.ileafly.com)\n<a name=\"yst3oh\"></a>\n#### [](#yst3oh)绑定语雀管理博客内容\n可以利用语雀管理博客内容，非常方便，详细流程可参考[使用语雀管理博客](http://www.ileafly.com/2018/11/09/yuque/使用语雀管理博客/)。\n<a name=\"qvkuep\"></a>\n#### [](#qvkuep)自定义主题\nHexo有非常非常多的主题，你可以在[Themes | Hexo](https://hexo.io/themes/index.html)浏览这些主题，选择你喜欢的主题进行使用。<br />我比较喜欢的主题是[Anisina](https://github.com/haojen/hexo-theme-Anisina)和[cafe](https://github.com/giscafer/hexo-theme-cafe)，这里就以[cafe](https://github.com/giscafer/hexo-theme-cafe)为例简述一下集成的流程。\n```\n# 安装\n$ git clone https://github.com/giscafer/hexo-theme-cafe.git themes/cafe\n\n# 修改博客配置文件 `_config.yml` 主题属性 theme 为 `cafe`.\n\n# 更新cafe文件\ncd themes/cafe\ngit pull\n\n# 主题 themes/cafe/_config.yml 文件内容参考说明配置 https://github.com/giscafer/hexo-theme-cafe/blob/master/_config.yml\n```\n<a name=\"ctisce\"></a>\n#### [](#ctisce)集成评论\n目前比较好用的评论是[LiveRe](https://www.livere.com)，注册并按照City版，获取uid。在__config.yml作如下配置：\n```ruby\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: '*******'\n```\n\n\n",
    "tags": [
      "Hexo"
    ],
    "categories": "Hexo",
    "<br />categories": "教程"
  },
  {
    "title": "fastlane指南",
    "description": "fastlane是一套使用Ruby写的自动化工具集，为iOS和Android开发者提供了自动化构建工具，可以帮助开发者将App打包、签名、测试、发布、信息整理、提供AppStore等工作连接起来，实现完全自动化的工作流。fastlane-doc 参考文档。安装# 安装 fastlane gem...",
    "created_at": "2018-11-08T02:20:01.000Z",
    "updated_at": "2018-11-10T03:27:52.000Z",
    "published_at": "2018-11-10T03:27:52.000Z",
    "format": "asl",
    "slug": "qgykm3",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-09T13:31:57.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n[fastlane](https://github.com/fastlane/fastlane)是一套使用Ruby写的自动化工具集，为iOS和Android开发者提供了自动化构建工具，可以帮助开发者将App打包、签名、测试、发布、信息整理、提供AppStore等工作连接起来，实现完全自动化的工作流。<br />[fastlane-doc](https://docs.fastlane.tools) 参考文档。\n\n<a name=\"ule4kq\"></a>\n### [](#ule4kq)安装\n```powershell\n# 安装 fastlane\ngem install fastlane\n\n# 检查版本 \nfastlane --version\n```\n\n<a name=\"upokfd\"></a>\n### [](#upokfd)配置\n```ruby\n# 初始化配置\ncd 项目目录\n## fastlane init期间会有四种配置选择，这里我们选择4 完全自定义，然后一直enter直至完成即可\nfastlane init\n\n# fastlane init执行完成后会在当前目录下创建一个fastlane文件夹，包含Appfile和Fastfile文件\n## Appfile\n\napp_identifier(\"bundle  id\") # The bundle identifier of your app\napple_id(\"********@mail.com\") # Your Apple email address\n\n# For more information about the Appfile, see:\n#     https://docs.fastlane.tools/advanced/#appfile\n\n## Fastline\n\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Description of what the lane does\"\n  lane :betaDebug do\n    # add actions here: https://docs.fastlane.tools/actions\n    # pod install\n    cocoapods(use_bundle_exec: false)\n    # build app\n    build_app(workspace: \"app.xcworkspace\", scheme: \"app\", export_method: \"ad-hoc\", output_directory: \"./fastlane/package\", configuration: \"Release\")\n    # upload pgyer\n    pgyer(api_key:  \"****************\",  user_key:  \"***********************\")\n    # send email\n    mailgun(\n      postmaster: \"postmaster@*************************.mailgun.org\",\n      apikey: \"********************-4412457b-38b62932\", \n      to: \"tester1@mail.com,tester2@mail.com,tester3@mail.com\",\n      from: \"author <author@mail.com>\",\n      success: true,  \n      message: \"app 上传蒲公英成功\",\n      app_link: \"https://www.pgyer.com/****\",\n      )\n  end\nend\n```\n\n按照上述流程配置好fastlane，执行`fastlane  betaDebug `不出意外你将看到执行成功的信息，在fastlane\\package目录下找到ipa文件。\n<a name=\"h1gtce\"></a>\n### [](#h1gtce)上传蒲公英\n\n1. 安装蒲公英插件\n\n```\nfastlane add_plugin pgyer\n```\n\n2. 配置蒲公英账号信息\n\n```ruby\nlane :betaDebug do\n    # add actions here: https://docs.fastlane.tools/actions\n    build_app(workspace: \"app.xcworkspace\", scheme: \"app\", export_method: \"ad-hoc\", output_directory: \"./fastlane/package\", configuration: \"Release\")\n    pgyer(api_key:  \"****************\",  user_key:  \"***********************\")\n  end\n```\n\n3. 打包上传\n\n```powershell\nfastlane betaDebug\n```\n<a name=\"fgh2mb\"></a>\n### [](#fgh2mb)pod install\nfastlane集成了`cocoapods`进行pod管理，在终端里输入`fastlane cocoapods`可以查看相关的API文档。\n\n1. 在Gemfile中添加`gem \"cocoapods\"`\n\n2. 在Fastfile中添加cocoapods的配置\n\n```ruby\n# 这里需要注意，我尝试过按照文档里设置Podfile的路径，发现不能成功执行pod install，后来通过调查使用如下命令可以成功执行，具体原因不明\ncocoapods(use_bundle_exec: false)\n```\n<a name=\"ng4arh\"></a>\n### [](#ng4arh)邮件通知\nfastlane集成了`mailgun` 进行邮件发送，在终端里输入fastlane mailgun可以查看相关的API文档，这里总结一下正确集成mailgun的流程\n\n1. 注册mailgun\n\n\n[mailgun](https://www.mailgun.com)是一个开发人员的电子邮件服务，提供了强大的API，每个月可免费发送10000封邮件，而且还可以进行跟踪日志等操作。按照流程注册完后会有一个测试domain，利用测试domain可以发送邮件，不过需要添加收件邮箱的验证，通过添加自定义域名可以使用更强大的功能。\n\n1. 在Gemfile中添加`gem \"rest-client\"`\n\n2. 在Fastfile中添加mailgun的配置\n\n```ruby\n# mailgun 邮件通知    \n    mailgun(\n      postmaster: \"postmaster@****************.mailgun.org\",\n      apikey: \"********************-4412457b-38b62932\", \n      to: \"tester1@mail.com,tester2@mail.com,tester3@mail.com\",\n      from: \"author <author@mail.com>\",\n      success: true,  \n      message: \"app 上传蒲公英成功\",\n      app_link: \"https://www.pgyer.com/****\",\n      )\n```\n\n4. 终端执行fastlane命令，成功配置时你将看到如下信息\n\n```ruby\n[10:51:39]: ------------------------------\n[10:51:39]: --- Step: default_platform ---\n[10:51:39]: ------------------------------\n[10:51:39]: Driving the lane 'ios betaDebug' 🚀\n[10:51:39]: ---------------------\n[10:51:39]: --- Step: mailgun ---\n[10:51:39]: ---------------------\n\n+------+-----------------+-------------+\n|           fastlane summary           |\n+------+-----------------+-------------+\n| Step | Action          | Time (in s) |\n+------+-----------------+-------------+\n| 1    | default_platfo  | 0           |\n|      | rm              |             |\n| 2    | mailgun         | 1           |\n+------+-----------------+-------------+\n\n[10:51:41]: fastlane.tools finished successfully 🎉\n```\n\n<a name=\"ewqdsv\"></a>\n#### [](#ewqdsv)mailgun相关注意点\n\n- mailgun会自动读取git提交message放入邮件内容中\n\n- mailgun的apikey配置不正确时会提供401认证错误\n\n- 使用测试域名，配置多个接收邮箱时，有一个邮箱未接收认证，就会导致所有的都失败\n\n\n<a name=\"oxgbns\"></a>\n### [](#oxgbns)fastlane进阶\n上面的流程只是帮我们简单实现fastlane打包与上传至蒲公英的流程，绝大多数情况下已经够用，不过fastlane还有很多功能可以挖掘\n\n- [x] fastlane 支持pod install\n- [x] fastlane 上传蒲公英后邮件通知测试人员\n- [ ] fastlane 上传Testflight\n- [ ] fastlane 上传AppStore\n\n<a name=\"6yx6gx\"></a>\n### [](#6yx6gx)使用过程中的一些坑\n\n1. fastlane配置完成后执行一直报错，编译不能通过，通过分析发现因为我装了两个Xcode，默认使用的是9.0版本的command line，而代码是在Xcode 10中编写的，使用了一些swift 4.2的语法，解决方案是在设置里切换command line版本即可。\n\n2. cocoapods的使用其他命令尝试了一直报错，只有上面那个命名能够成功，原因还未知\n\n3. mailgun的集成详细的教程比较少，要多尝试，如果遇到401报错就看看apiKey是否设置正确，另外要注意使用测试域名，接受邮件的邮箱需要先邀请认证，否则会报400错误。\n\n\n",
    "tags": [
      "教程"
    ],
    "categories": "教程",
    "<br />categories": "iOS"
  },
  {
    "title": "ZYLoading--自定义loading控件",
    "description": "date: 2017-12-14 19:20:00categories:iOStags:iOS控件封装移动端项目的开发离不开loading控件，通常为了能快速在项目中实现loading效果我们有几个主流的开源库可以选择： MBProgressHUD、SVProgressHUD等然后，为了能让整...",
    "created_at": "2018-11-10T03:40:26.000Z",
    "updated_at": "2018-11-10T03:47:36.000Z",
    "published_at": "2018-11-10T03:47:36.000Z",
    "format": "asl",
    "slug": "ptds2t",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-09T13:31:57.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n移动端项目的开发离不开loading控件，通常为了能快速在项目中实现loading效果我们有几个主流的开源库可以选择：<br />[MBProgressHUD](https://github.com/jdg/MBProgressHUD)、[SVProgressHUD](https://github.com/SVProgressHUD/SVProgressHUD)等\n\n然后，为了能让整体项目的loading效果显得更加贴切我就想创建一个loading控件，希望此控件能够比较方便的开启、停止loading效果，而且能易于集成和更换logo。\n\n为了达到这个目的，我创建了一个名为[ZYLoading](https://github.com/luzhiyongGit/ZYLoading.git)的控件，下面就为大家分享一下我这个控件的原理以及使用方法。\n\n<a name=\"6gngga\"></a>\n## [](#6gngga)原理分析\n\n此控件的核心思想是利用runtime机制给分类增加成员属性，通过给UIView扩展开启、停止loading的方法，从而实现任何UIView的实例都能方便的开启、停止loading动画\n\n```\n#import \"UIView+ZYLoadingView.h\"\n\n#import <objc/runtime.h>\n\nstatic char LoadingViewKey;\n\n@implementation UIView (ZYLoadingView)\n\n#pragma mark - Setter\n\n// 将创建的ZYLoadingView实例关联到分类\n- (void)setLoadingView:(ZYLoadingView *)loadingView {\n    [self willChangeValueForKey:@\"LoadingViewKey\"];\n    objc_setAssociatedObject(self, &LoadingViewKey, loadingView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    [self didChangeValueForKey:@\"LoadingViewKey\"];\n}\n\n// 获取关联的ZYLoadingView\n- (ZYLoadingView *)loadingView {\n    return objc_getAssociatedObject(self, &LoadingViewKey);\n}\n\n// 开启动画\n- (void)beginLoading {\n    if (!self.loadingView) {\n        self.loadingView = [[ZYLoadingView alloc] initWithFrame:self.bounds];\n    }\n    \n    [self addSubview:self.loadingView];\n    \n    [self.loadingView startAnimation];\n}\n\n// 停止动画\n- (void)endLoading {\n    if (self.loadingView) {\n        [self.loadingView stopAnimation];\n    }\n}\n\n@end\n```\n\n<a name=\"onp8ux\"></a>\n## [](#onp8ux)使用方法\n\n<a name=\"yz1gkc\"></a>\n##### [](#yz1gkc)通过一组图片组合成动画\n\n```objectivec\n// 通过枚举选择图片组合动画\nZYLoadingConfigInstance.loadingType = ZYLoadingAnimateImages;\n// 图片名称\nZYLoadingConfigInstance.animateImageName = @\"zy_loading_\";\n// 图片尺寸\nZYLoadingConfigInstance.loopImageSize = CGSizeMake(37, 13);\n// 动画过渡时长\nZYLoadingConfigInstance.duration = 1.f;\n```\n\n<a name=\"qckoog\"></a>\n##### [](#qckoog)通过一张图旋转形成动画\n\n```objectivec\n// 通过枚举选择通过旋转图片展现loading动画\nZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;\n// 图片名称\nZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@\"loading_circle\"];\n// 图片尺寸    \nZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);\n// 动画过渡时长    \nZYLoadingConfigInstance.duration = 0.25f;\n```\n\n<a name=\"1htvcz\"></a>\n##### [](#1htvcz)通过一张图片旋转，另一张图片渐隐渐显组合成动画\n\n```objectivec\n// 通过枚举选择通过旋转图片展现loading动画    ZYLoadingConfigInstance.loadingType = ZYLoadingLoopImage;\n// 图片名称\nZYLoadingConfigInstance.loopImage = [UIImage imageNamed:@\"loading_circle\"];\n// 图片尺寸    \nZYLoadingConfigInstance.loopImageSize = CGSizeMake(60, 60);\n// logo图片名称\nZYLoadingConfigInstance.logoImage = [UIImage imageNamed:@\"loading_zhangyu\"];\n// logo图片尺寸\nZYLoadingConfigInstance.logoImageSize = CGSizeMake(40, 40);\n// 动画过渡时长\nZYLoadingConfigInstance.duration = 0.25f;\n```\n\n<a name=\"1v21fg\"></a>\n##### [](#1v21fg)开启、停止动画\n\n```objectivec\n// 开启动画\n[self.view beginLoading];\n\n// 停止动画\n[self.view endLoading];\n```\n\n你也可以直接参考github上的[ZYLoading](https://github.com/luzhiyongGit/ZYLoading.git)\n",
    "date": "2017-12-14 19:20:00 +0800",
    "tags": [
      "封装"
    ],
    "categories": "组件",
    "<br />categories": "iOS"
  },
  {
    "title": "Markdown语法初探",
    "description": "",
    "created_at": "2018-11-10T03:32:57.000Z",
    "updated_at": "2018-11-10T03:33:32.000Z",
    "published_at": null,
    "format": "asl",
    "slug": "re8dho",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-09T13:31:57.000Z",
      "_serializer": "v2.user"
    },
    "body": "title: Markdown语法初探<br />tags: [markdown]<br />categories: 教程\n\n---\n\nMarkdown是一种轻量级标记语言，这篇博客会总结一些经常使用的Markdown语法。\n\n<a name=\"7vhalw\"></a>\n#### [](#7vhalw)标题\n```makedown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n<a name=\"kb5oaz\"></a>\n# [](#kb5oaz)一级标题\n<a name=\"x39vgn\"></a>\n## [](#x39vgn)二级标题\n<a name=\"fudbls\"></a>\n### [](#fudbls)三级标题\n<a name=\"uoagan\"></a>\n#### [](#uoagan)四级标题\n<a name=\"gplupm\"></a>\n##### [](#gplupm)五级标题\n<a name=\"zhergt\"></a>\n###### [](#zhergt)六级标题\n<a name=\"171ptb\"></a>\n#### [](#171ptb)引用\n```makedown\n> 这是一段被引用的内容\n```\n> 这是一段被应用的内容\n\n\n<a name=\"mncspy\"></a>\n#### [](#mncspy)链接\n```makedown\n[链接文案](链接地址)\n```\n[链接](#mncspy)\n\n<a name=\"lfecoq\"></a>\n#### [](#lfecoq)图片\n```makedown\n![Alt  text](image  url)\n```\n![](https://cdn.nlark.com/yuque/0/2018/jpeg/183307/1541837693964-6f7a229c-9549-483c-9c1b-b487b20edbfa.jpeg#align=left&display=inline&height=140&originHeight=140&originWidth=360&status=done&width=360)\n\n<a name=\"t08aav\"></a>\n#### [](#t08aav)分割线\n```makedown\n---\n```\n\n---\n\n<a name=\"xilslv\"></a>\n#### [](#xilslv)无序列表\n```\n- 第一条\n- 第二条\n- 第三条\n```\n\n- 第一条\n\n- 第二条\n\n- 第三条\n\n\n<a name=\"kwhgeg\"></a>\n#### [](#kwhgeg)有序列表\n```makedown\n1. 第一条\n2. 第二条\n3. 第三条\n```\n\n1. 第一条\n\n2. 第二条\n\n3. 第三条\n\n\n<a name=\"tw9nqt\"></a>\n#### [](#tw9nqt)强调\n```makedown\n*斜体字*\n**加重强调**\n```\n_斜体字_<br />**加重强调**\n",
    "tags": [
      "markdown"
    ],
    "categories": "教程",
    "date": "2016-08-11 10:19:00 +0800"
  },
  {
    "title": "iOS 技巧合集",
    "description": "tags: [iOS]categories: 开发技巧date: 2017-02-20 11:55:00一行命令，统计OC项目中每个源代码文件的行数以及总行数$ find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&qu...",
    "created_at": "2018-11-10T08:22:38.000Z",
    "updated_at": "2018-11-10T09:52:33.000Z",
    "published_at": "2018-11-10T09:52:33.000Z",
    "format": "asl",
    "slug": "sokrp0",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-09T13:31:57.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "iOS"
    ],
    "categories": "iOS",
    "date": "2017-02-20 11:55:00 +0800",
    "body": "\n<a name=\"tf2kgf\"></a>\n#### [](#tf2kgf)一行命令，统计OC项目中每个源代码文件的行数以及总行数\n```powershell\n$ find . \"(\" -name \"*.m\" -or -name \"*.mm\" -or -name \"*.cpp\" -or -name \"*.h\" -or -name \"*.rss\" \")\" -print | xargs wc -l\n```\n\n<a name=\"8wricr\"></a>\n#### [](#8wricr)复制字符串到剪贴板\n```objectivec\nUIPasteboard *pasteboard = [UIPasteboard  generalPasteboard];\npasteborad.string = @\"你需要复制的字符串\";\n```\n\n<a name=\"s16fhl\"></a>\n#### [](#s16fhl)让子view不响应父view的手势\n正常情况下，父view的手势在子view上点击也会响应，想要在子view中屏蔽父view的手势有以下方法：\n\n1. 子view中再次添加手势，拦截掉父view的手势\n\n2. 实现父view的手势代理，在代理中拦截父view手势\n\n```objectivec\n- (BOOL)gestureRecognizer:(UIGestureRecognizer  *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {\n    if ([touch.view  isDescendantOfView:subview]) {\n       return NO;\n    }\n    return YES;\n}\n```\n\n<a name=\"nognoh\"></a>\n#### [](#nognoh)自定义xopen快捷打开工程\n利用ruby脚本在终端快速打开工程，ruby脚本内容如下：\n```ruby\n#!/usr/bin/env ruby\nrequire 'shellwords'\n\nproj = Dir['*.xcworkspace'].first\nproj = Dir['*.xcodeproj'].first unless proj\n\nif proj\n   puts \"Opening  #{proj}\"\n   `open #{proj}`\nelse\n  puts \"No  xcworkspace|xcproj  file  found\"\nend\n```\n将脚本文件保存为`xopen`，拷贝到`/usr/local/bin`目录下，添加权限：`chmod 777 xopen`<br />在终端中任何需要打开项目的位置，执行xopen即可。\n\n<a name=\"fqw2ll\"></a>\n#### [](#fqw2ll)CUICatalog Invalid asset name supplied\n项目中最近在打印`CUICatalog Invalid asset name supplied`，调研发现之所以输出这个log是因为传了一个空字符串来获取image，如果项目这种情况比较多，可以添加一个`symbolic breakpoint`来定位。<br />![](https://cdn.nlark.com/yuque/0/2018/png/183307/1541845301865-3989fad5-4209-460a-8ec8-af444c4a9643.png#align=left&display=inline&height=257&originHeight=271&originWidth=565&status=done&width=536)\n\n需要说明一下，$arg3用于模拟器，$r0用于真机，除了传入值是nil的情况，还可能是@\"\"，这种情况的判断规则是`[$arg3  length] == 0`\n\n<a name=\"nim5dg\"></a>\n#### [](#nim5dg)iOS导航栏显示与隐藏\n项目中可能存在需要特殊隐藏导航栏的页面，通常情况下我们只需要在特殊页面执行`viewWillAppear`时隐藏导航栏，再在`viewWillDisapper`时显示导航栏以确保不对需要正常显示导航栏的页面产生影响。不过在实际项目中，页面之间的情况远比我们想象的复杂，我们以A、B两个页面为例：\n\n- A 显示 B 隐藏  这种情况下我们按照上述操作是没有问题的\n\n- A 隐藏 B 显示  这种情况下我们按照上述操作是没有问题的\n\n- A 隐藏 B 隐藏  这种情况下就会存在连续执行先显示、再隐藏的情况，频繁操作就会存在导航栏异常的情况\n\n\n为了解决这个问题，最佳方案应该是每个页面根据自身需要执行显示或隐藏导航栏的操作，如果让每个页面无形增加了代码量，而且不利于维护。为了进一步优化，我们可以利用`UINavigationControllerDelegate`做些文章。\n```swift\nextension ZYNavigationController: UINavigationControllerDelegate {\n    func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {\n        // 判断要显示的控制器是否是自己\n        let isHidden = viewController.isKind(of: FourthViewController.self) || viewController.isKind(of: FirstViewController.self)\n        \n        self.setNavigationBarHidden(isHidden, animated: true)\n    }\n}\n```\n\n<a name=\"i5bdgx\"></a>\n#### [](#i5bdgx)iPhoneX 隐藏底部的Home条\n```objectivec\n- (BOOL)prefersHomeIndicatorAutoHidden {\n      return YES;\n}\n```\n需要注意，Home条并不会立刻消失，而是延迟1~2秒后缓慢消失\n\n<a name=\"hhsehy\"></a>\n#### [](#hhsehy)轻松搞定状态栏变化\n```swift\n// 当设置statusBarHidden时，调用setNeedsStatusBarAppearanceUpdate立即更新状态栏\nvar isStatusBarHidden: Bool = false {\n    didSet {\n        self.setNeedsStatusBarAppearanceUpdate()\n    }\n}\n// 状态栏样式 \noverride var preferredStatusBarStyle: UIStatusBarStyle {\n    return .lightContent\n}\n//  状态栏是否隐藏   \noverride var prefersStatusBarHidden: Bool {\n    return isStatusBarHidden\n}\n```\n<a name=\"sydfiq\"></a>\n#### [](#sydfiq)引导用户跳转AppStore设置支付方式\n```objectivec\n[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/editAddress?mt=8\"]];\n```\n<a name=\"rgslgc\"></a>\n#### [](#rgslgc)自定义代码片段\nXcode可以添加一段代码的快捷方式：\n\n1. 将要添加的代码选中，拖拽到Code Snippets区域\n\n2. 在弹框里对代码片段进行编辑，将想要方便更换的内容以`<#  #>`包裹，对应内容就是可变内容啦\n\n3. 在`Completion  Shortcut`一栏可以填入快捷标记\n\n4. 完成以上步骤后，在需要使用相关代码片段时，只需要输入快捷标记就能快速输入代码片段\n\n<a name=\"6l0pqp\"></a>\n#### [](#6l0pqp)腾讯QMUI Team开源的代码片段\n腾讯QMUI Team开源了他们经常使用的代码片段，非常全面，下载后存放在**~/Library/Developer/Xcode/UserData/CodeSnippets**目录下即可。<br />[qmui-ios-codesnippets](https://github.com/QMUI/QMUI_iOS_CodeSnippets)\n<a name=\"30i5og\"></a>\n#### [](#30i5og)Xcode控制台杂乱信息屏蔽\nXcode升级后，运行项目会打印一堆杂乱的log信息，虽然不影响App的功能，但是会对问题定位产生影响。为了解决这个我们可以在scheme里设置`os_activity_mode`为disable。这里有两个注意点：\n\n1. NSLog打印的信息也会被一并屏蔽掉  解决方案：使用printf替代NSLog\n\n```objectivec\n#ifdef DEBUG\n#define NSLog(format, ...) printf(\"\\n[%s] %s [第%d行] %s\\n\", __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);\n#else\n#define NSLog(format, ...)\n#endif\n```\n\n2. swift的print打印信息不受影响\n\n\n\n",
    "<br />categories": "开发技巧"
  },
  {
    "title": "iOS自动化打包脚本",
    "description": "tags: [iOS]categories: 开发技巧date: 2017-04-20 11:55:00注意：此方案打包OC项目没有问题，打包swift pod的项目，在export时会失败，目前还没找到解决方案，建议使用fastlane进行打包。fastlane指南iOS自动打包主要使用xc...",
    "created_at": "2018-11-15T05:06:48.000Z",
    "updated_at": "2018-11-20T02:03:19.000Z",
    "published_at": "2018-11-20T02:03:19.000Z",
    "format": "asl",
    "slug": "pfwwo0",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-15T06:29:48.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "教程"
    ],
    "categories": "开发技巧",
    "date": "2017-04-20 11:55:00 +0800",
    "body": "\n注意：此方案打包OC项目没有问题，打包swift pod的项目，在export时会失败，目前还没找到解决方案，建议使用fastlane进行打包。[fastlane指南](http://www.ileafly.com/2018/11/08/yuque/fastlane指南/)\n\niOS自动打包主要使用`xcodebuild`，在终端输入`xcodebuid --help`可以查看`xcodebuild`的参数。\n\n<a name=\"opaffn\"></a>\n#### [](#opaffn)xcodebuild核心语法\n<a name=\"80i4av\"></a>\n##### [](#80i4av)无workspace的工程\n```powershell\nxcodebuild [-project  name.xcodeproj][[-target targetname]...|-alltargets][-configuration  configurationname][-sdk  [sdkfullpath  |  sdkname]][action  ...][buildsetting=value  ...][-userdefault=value  ...]\n\nxcodebuild [-project  name.xcodeproj] -scheme schemename [[-destination  destinationspecifier]...][-destination-timeout  value][-configuration  configurationname][-sdk  [sdkfullpath  |  sdkname][action  ...][buildsetting =value  ...][-userdefault=value  ...]\n```\n<a name=\"sh64gz\"></a>\n##### [](#sh64gz)有workspace的工程\n```powershell\nxcodebuild -workspace name.xcworkspace -scheme schemename [[-destination  destinationspecifier]...][-destination-timeout  value][-configuration  configurationname][-sdk  [sdkfullpath  |  sdkname]][action  ...][buidsetting=value  ...][-userdefault=value  ...]\n```\n\n<a name=\"z4urwc\"></a>\n## [](#z4urwc)具体shell脚本\n<a name=\"chqbxy\"></a>\n#### [](#chqbxy)无workspace的工程\n```powershell\n#author by leafly\n\n#工程名字(Target名字)\nProject_Name=\"Target名字，系统默认和工程名字一样\"\n#配置环境，Release或者Debug\nConfiguration=\"Release\"\n\nDate=`date +%Y%m%d_%H%M`\nSourcePath=$( cd \"$( dirname %0)\" && pwd)\n\n#AdHoc版本的Bundle ID\nAdHocBundleID=\"com.xxx\"\n#AppStore版本的Bundle ID\nAppStoreBundleID=\"com.xxx\"\n#enterprise的Bundle ID\nEnterpriseBundleID=\"com.xxx\"\n\n# ADHOC\n#证书名#描述文件\nADHOCCODE_SIGN_IDENTITY=\"iPhone Distribution: xxxx\"\nADHOCPROVISIONING_PROFILE_NAME=\"xxxx-xxxx-xxxx-xxxx\"\n\n#AppStore证书名#描述文件\nAPPSTORECODE_SIGN_IDENTITY=\"iPhone Distribution: xxxx\"\nAPPSTOREROVISIONING_PROFILE_NAME=\"xxxx-xxxx-xxxx-xxxx\"\n\n#企业(enterprise)证书名#描述文件\nENTERPRISECODE_SIGN_IDENTITY=\"iPhone Distribution: xxxxx\"\nENTERPRISEROVISIONING_PROFILE_NAME=\"xxxx-xxxx-xxxx-xxxx\"\n\n#加载各个版本的plist文件\nADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plist\nAppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plist\nEnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plist\n\nADHOCExportOptionsPlist=${ADHOCExportOptionsPlist}\nAppStoreExportOptionsPlist=${AppStoreExportOptionsPlist}\nEnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist}\n\necho \"~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~\"\necho \"  1 appstore\"\necho \"  2 adhoc\"\necho \"  3 enterprise\"\n\n# 读取用户输入并存到变量里\nread parameter\nsleep 0.5\nmethod=\"$parameter\"\n\n# 判读用户是否有输入\nif [ -n \"$method\" ]\nthen\n\n#clean下\nxcodebuild clean -xcodeproj ./$Project_Name/$Project_Name.xcodeproj -configuration $Configuration -alltargets\n\n    if [ \"$method\" = \"1\" ]\n    then\n\n#appstore脚本\nxcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive clean archive build  CODE_SIGN_IDENTITY=\"${APPSTORECODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${APPSTOREROVISIONING_PROFILE_NAME}\" PRODUCT_BUNDLE_IDENTIFIER=\"${AppStoreBundleID}\"\nxcodebuild -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist $AppStoreExportOptionsPlist -exportPath ~/Desktop/$Project_Name-appstore.ipa\n    elif [ \"$method\" = \"2\" ]\n    then\n#adhoc脚本\nxcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-adhoc.xcarchive clean archive build CODE_SIGN_IDENTITY=\"${ADHOCCODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${ADHOCPROVISIONING_PROFILE_NAME}\" PRODUCT_BUNDLE_IDENTIFIER=\"${AdHocBundleID}\"\nxcodebuild -exportArchive -archivePath build/$Project_Name-adhoc.xcarchive -exportOptionsPlist $ADHOCExportOptionsPlist -exportPath ~/Desktop/$Project_Name-adhoc.ipa\n    elif [ \"$method\" = \"3\" ]\n    then\n#企业打包脚本\nxcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive clean archive build CODE_SIGN_IDENTITY=\"${ENTERPRISECODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${ENTERPRISEROVISIONING_PROFILE_NAME}\" PRODUCT_BUNDLE_IDENTIFIER=\"${EnterpriseBundleID}\"\nxcodebuild -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist $EnterpriseExportOptionsPlist -exportPath ~/Desktop/$Project_Name-enterprise.ipa\nelse\n    echo \"参数无效....\"\n    exit 1\n    fi\nfi\n\n#upload to pgyer\nif [ -e $IpaPath ]; then\n  #statements\n  echo \"Uploading the ipa file...\"\n  echo $IpaPath\n      response=`curl -F \"file=@$IpaPath/$IpaName\" -F \"uKey=$PGY_UKEY\" -F \"_api_key=$PGY_API_KEY\" $PGY_UPLOAD_URL`\n  echo response\n\n  # send email\n  echo \"蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/xxxx\" | mail -s \"测试包更新成功\" lu.zhiyong@sohu.com\nelse\n  echo \"创建ipa失败\"\nfi\n```\n\n<a name=\"uxwfdr\"></a>\n#### [](#uxwfdr)有workspace的工程\n```powershell\n#author by leafly\n\n#蒲公英账号信息\nPYG_DOMAIN=\"http://www.pgyer.com\"\nPGY_UPLOAD_URL=\"https://qiniu-storage.pgyer.com/apiv1/app/upload\"\nPGY_UKEY=\"196be923698226391e474dabefd2243d\"\nPGY_API_KEY=\"906192e72b27666926ba256da0f574dc\"\n\n#工程名字(Target名字)\nProject_Name=\"Target名字，系统默认和工程名字一样\"\n#workspace的名字\nWorkspace_Name=\"WorkSpace名字\"\n#配置环境，Release或者Debug,默认release\nConfiguration=\"Release\"\n\n#路径配置\nDate=`date +%Y%m%d_%H%M`\nSourcePath=$( cd \"$( dirname %0)\" && pwd)\nIpaPath=$SourcePath/AutoBuildIpa/$Date\nArchivePath=$SourcePath/AutoBuildIpa/$Date/$Project_Name_$Date.xcarchive\nIpaName=$Project_Name.ipa\n\n#AdHoc版本的Bundle ID\nAdHocBundleID=\"com.xxxx\"\n#AppStore版本的Bundle ID\nAppStoreBundleID=\"com.xxxx\"\n#enterprise的Bundle ID\nEnterpriseBundleID=\"com.xxxx\"\n\n# ADHOC证书名#描述文件\nADHOCCODE_SIGN_IDENTITY=\"iPhone Distribution: xxxxx\"\nADHOCPROVISIONING_PROFILE_NAME=\"xxxxx-xxxx-xxx-xxxx\"\n\n#AppStore证书名#描述文件\nAPPSTORECODE_SIGN_IDENTITY=\"iPhone Distribution: xxxxx\"\nAPPSTOREROVISIONING_PROFILE_NAME=\"xxxxx-xxxx-xxx-xxxx\"\n\n#企业(enterprise)证书名#描述文件\nENTERPRISECODE_SIGN_IDENTITY=\"iPhone Distribution: xxxx\"\nENTERPRISEROVISIONING_PROFILE_NAME=\"xxxxx-xxxx-xxx-xxxx\"\n\n#加载各个版本的plist文件\nADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plist\nAppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plist\nEnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plist\n\nADHOCExportOptionsPlist=${ADHOCExportOptionsPlist}\nAppStoreExportOptionsPlist=${AppStoreExportOptionsPlist}\nEnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist}\n\necho \"~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~\"\necho \"  1 adHoc\"\necho \"  2 AppStore\"\necho \"  3 Enterprise\"\n\n# 读取用户输入并存到变量里\nread parameter\nsleep 0.5\nmethod=\"$parameter\"\n\n# pod install\n\npod install\n\n# 判读用户是否有输入\nif [ -n \"$method\" ]\nthen\n    if [ \"$method\" = \"1\" ]\n    then\n#adhoc脚本\nxcodebuild -workspace $Workspace_Name.xcworkspace -scheme $Project_Name -configuration $Configuration -archivePath $ArchivePath clean archive build CODE_SIGN_IDENTITY=\"${ADHOCCODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${ADHOCPROVISIONING_PROFILE_NAME}\" PRODUCT_BUNDLE_IDENTIFIER=\"${AdHocBundleID}\"\nxcodebuild  -exportArchive -archivePath $ArchivePath -exportOptionsPlist ${ADHOCExportOptionsPlist} -exportPath $IpaPath\n\n    elif [ \"$method\" = \"2\" ]\n    then\n#appstore脚本\nxcodebuild -workspace $Workspace_Name.xcworkspace -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive archive build CODE_SIGN_IDENTITY=\"${APPSTORECODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${APPSTOREROVISIONING_PROFILE_NAME}\" PRODUCT_BUNDLE_IDENTIFIER=\"${AppStoreBundleID}\"\nxcodebuild  -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist ${AppStoreExportOptionsPlist} -exportPath ~/Desktop/$Project_Name-appstore.ipa\n\n    elif [ \"$method\" = \"3\" ]\n    then\n#企业打包脚本\nxcodebuild -workspace $Workspace_Name.xcworkspace -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive archive build CODE_SIGN_IDENTITY=\"${ENTERPRISECODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${ENTERPRISEROVISIONING_PROFILE_NAME}\" PRODUCT_BUNDLE_IDENTIFIER=\"${EnterpriseBundleID}\"\nxcodebuild  -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist ${EnterpriseExportOptionsPlist} -exportPath ~/Desktop/$Project_Name-enterprise.ipa\n    else\n    echo \"参数无效....\"\n    exit 1\n    fi\nfi\n\n#upload to pgyer\nif [ -e $IpaPath ]; then\n  #statements\n  echo \"Uploading the ipa file...\"\n  echo $IpaPath\n      response=`curl -F \"file=@$IpaPath/$IpaName\" -F \"uKey=$PGY_UKEY\" -F \"_api_key=$PGY_API_KEY\" $PGY_UPLOAD_URL`\n  echo response\n\n  # send email\n  echo \"蒲公英网站上的APP已更新，欢迎更新.下载地址：https://www.pgyer.com/xxxx\" | mail -s \"测试包更新成功\" lu.zhiyong@sohu.com\n else\n  echo \"创建ipa失败\"\n fi\n```\n\n<a name=\"bkeyhl\"></a>\n### [](#bkeyhl)plist文件\n```html\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>provisioningProfiles</key>\n\t<dict>\n\t\t<key>bundle  ID</key>\n\t\t<string>xxxxxxxx-xxxxxx-xxxxxxxxx</string>\n\t</dict>\n\t<key>method</key>\n\t<string>ad-hoc</string>\n</dict>\n</plist>\n```\n\n<a name=\"2afoai\"></a>\n### [](#2afoai)用法\n将shell脚本命名为`xpublish`，将文件存放到`/usr/local/bin`目录下，`chmod 777 xpublish`修改`xpublish`的权限。进入项目目录，执行`xpublish`即可。\n\n",
    "<br />categories": "iOS"
  },
  {
    "title": "导航栏隐藏白条问题调研",
    "description": "tags: [iOS、实战]categories: iOS问题背景阅读器页面需要一直隐藏导航栏，同时在正常阅读时隐藏状态栏，在调出上下菜单栏时显示状态栏，当菜单栏调出时可以push进入阅读器设置页面，当在阅读器设置页面快速手势返回进入阅读器页，再隐藏上下菜单栏时，在页面顶部留了一个20像素高的...",
    "created_at": "2018-11-20T08:44:39.000Z",
    "updated_at": "2018-11-20T10:00:01.000Z",
    "published_at": "2018-11-20T10:00:01.000Z",
    "format": "asl",
    "slug": "xgov46",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-15T06:29:48.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "实战"
    ],
    "categories": "iOS",
    "body": "\n<a name=\"nlepfh\"></a>\n### [](#nlepfh)问题背景\n阅读器页面需要一直隐藏导航栏，同时在正常阅读时隐藏状态栏，在调出上下菜单栏时显示状态栏，当菜单栏调出时可以push进入阅读器设置页面，当在阅读器设置页面快速手势返回进入阅读器页，再隐藏上下菜单栏时，在页面顶部留了一个20像素高的白色view。<br />![](https://cdn.nlark.com/yuque/0/2018/gif/183307/1542705090719-2362ae84-9806-442b-a8f8-02e2e2fc0a0f.gif#align=left&display=inline&height=690&originHeight=690&originWidth=388&status=done&width=268)\n\n<a name=\"cpoflq\"></a>\n### [](#cpoflq)解决思路\n\n1. 查看图层确认此白条是什么视图，经过确认是navigationBar里面的view\n\n2. 怀疑是因为我先隐藏导航栏，再隐藏状态栏导致的\n\n3. 考虑如何才能更好的管理隐藏导航栏和状态栏的流程\n\n4. 打算新建一个项目，重现此问题进行调试和分析\n\n\n<a name=\"91dsld\"></a>\n### [](#91dsld)问题重现\n我新建了[StatusBarDemo](https://github.com/luzhiyongGit/iOS_Demos/tree/master/StatusBarDemo)用来重现这个问题，通过Demo我发现并没有重现此问题，这就很奇怪了，为何又无法重现这个问题呢？为了进一步分析此问题，我又查看了Demo的图层，通过对比我发现Demo中并不存在那个多余的view。<br />![](https://cdn.nlark.com/yuque/0/2018/png/183307/1542706774003-9579d0ea-3066-44d0-8db0-997972b0c31d.png#align=left&display=inline&height=271&originHeight=271&originWidth=243&status=done&width=195)<br />![](https://cdn.nlark.com/yuque/0/2018/png/183307/1542706807574-2351eeaf-3ff0-4cd1-bd4c-3fc124e883db.png#align=left&display=inline&height=223&originHeight=223&originWidth=262&status=done&width=194)\n\n<a name=\"4ngnqh\"></a>\n### [](#4ngnqh)思路调整\n为何项目中的导航栏会多一个view？什么情况下会多？<br />顺着这个思路调研发现正常情况下导航栏是不会出现这个view的，一定是哪里添加了这个view，这时我想到了项目中添加的一个三方库[WRNavigationBar_swift](https://github.com/wangrui460/WRNavigationBar_swift)，将这个三方库添加到Demo中一试，果然问题重现了。找到了原因接下来也就好解决了，因为[WRNavigationBar_swift](https://github.com/wangrui460/WRNavigationBar_swift)只是用来设置导航栏的颜色和字体颜色，完全可以移除这个库，在基类中自己设置，这样这个问题就解决了。\n\n<a name=\"w9tpxf\"></a>\n### [](#w9tpxf)深入探究\n[WRNavigationBar_swift](https://github.com/wangrui460/WRNavigationBar_swift)为什么要添加这个view呢？原来它在NavigationBar上添加了一个backgroundView，这样即使保留translucent属性为true，也不会因为透视而看到最下层的下拉刷新的图标等内容。\n\n",
    "<br />categories": "iOS"
  },
  {
    "title": "ZYRouterManager--Swift",
    "description": "ZYRouterManager--Swift封装一个简易、灵活的路由中间件，适合小型项目使用--Swift版目的随着项目越来越大，页面之间的跳转逻辑也越来越复杂，加上有很多h5页面也存在着与原生页面跳转的逻辑，为了统一管理页面的跳转逻辑，封装了一个路由中间件的类预期提供一个类方法，解析传入的路...",
    "created_at": "2018-11-21T06:12:41.000Z",
    "updated_at": "2018-11-21T06:17:48.000Z",
    "published_at": "2018-11-21T06:17:48.000Z",
    "format": "asl",
    "slug": "eiulvg",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-15T06:29:48.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n\n<a name=\"YIIDE\"></a>\n# ZYRouterManager--Swift\n封装一个简易、灵活的路由中间件，适合小型项目使用--Swift版\n\n<a name=\"mzlzvo\"></a>\n## [](#mzlzvo)目的\n\n随着项目越来越大，页面之间的跳转逻辑也越来越复杂，加上有很多h5页面也存在着与原生页面跳转的逻辑，为了统一管理页面的跳转逻辑，封装了一个路由中间件的类\n\n<a name=\"ck62gs\"></a>\n## [](#ck62gs)预期\n\n提供一个类方法，解析传入的路径，跳转到相应的界面\n\n<a name=\"yg84rf\"></a>\n## [](#yg84rf)实现方案\n\n<a name=\"p1oqks\"></a>\n###### [](#p1oqks)提供一个统一的路由中间件入口\n\n提供了一个唯一对外开放的类方法，需要传入跳转的scheme。\n\n```swift\n/// 路由中间件入口方法\n///\n/// - Parameter schema: 需要跳转的scheme\n/// - Returns: 是否能跳转\nclass func routerWithSchema(_ schema: String) -> Bool {\n    guard schema.count > 0 else {\n        return false\n    }\n    if let urlString = schema.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) {\n        if let url = URL(string: urlString) {\n            return ZYRouterManager.analysisScheme(url)\n        }\n    }\n        \n    return false\n}\n```\n\n<a name=\"5n19nl\"></a>\n###### [](#5n19nl)分析传入的scheme\n\n分析传入的scheme，通过对比host判断跳转路径，通过解析请求参数，将传递的参数赋值给相对应的controller。\n\n```swift\n/// 分析传入的scheme\n///\n/// - Parameter url: 跳转的URL对象\n/// - Returns: 是否能跳转\nprivate class func analysisScheme(_ url: URL) -> Bool {\n    let routePattern = url.absoluteString\n    if let components = URLComponents(string: routePattern), let scheme = components.scheme {\n            \n        guard scheme == RootScheme else {\n            return false\n        }\n            \n        let host = components.host\n            \n        var queryParams = Dictionary<String, Any>()\n            \n        if let queryItems = components.queryItems {\n            for item in queryItems {\n                if item.value == nil {\n                    continue\n                }\n                queryParams[item.name] = item.value\n            }\n        }\n            \n        switch host {\n        case RouterPath.detailPath.rawValue:\n            do {\n                // 跳转到详情页\n                let vc = DetailViewController()\n                let currentVC = ZYRouterManager.getCurrentVC()\n                if let productId = queryParams[\"productId\"] as? String {\n                    vc.productId = productId\n                }\n                currentVC?.navigationController?.pushViewController(vc, animated: true)\n            }\n            break\n        case RouterPath.searchPath.rawValue:\n            do {\n                // 跳转到搜索页\n                let vc = SearchViewController()\n                let currentVC = ZYRouterManager.getCurrentVC()\n                currentVC?.navigationController?.pushViewController(vc, animated: true)\n            }\n            break\n        default: break\n                \n        }\n    }\n    return false\n}\n```\n\n<a name=\"xy09yi\"></a>\n###### [](#xy09yi)获取当前控制器\n\n为了方便使用者调用，`ZYRouterManager`内部实现了获取当前控制器的流程，大体思路是通过rootViewController一步一步向下查找，一直找到`UIViewController`对象，作为当前控制器返回\n\n```swift\n/// 获取当前控制器\n///\n/// - Returns: 当前控制器\nprivate class func getCurrentVC() -> UIViewController? {\n    if let rootVC = UIApplication.shared.keyWindow?.rootViewController {\n        return ZYRouterManager.findCurrentVC(rootVC)\n    }\n    return nil\n}\n    \n/// 在rootVC中查找currentVC\n///\n/// - Parameter parentVC: 父ViewController\n/// - Returns: 查找到的ViewController\nprivate class func findCurrentVC(_ parentVC: UIViewController) -> UIViewController? {\n    if parentVC.isKind(of: UINavigationController.self), let nav = parentVC as? UINavigationController {\n        // rootVC是UINavigationController\n        if let vc = nav.childViewControllers.last {\n          return ZYRouterManager.findCurrentVC(vc)\n        }\n        return nil\n    } else if parentVC.isKind(of: UITabBarController.self), let tabBar = parentVC as? UITabBarController {\n        // rootVC是UITabBarController\n        if let vc = tabBar.selectedViewController {\n            return ZYRouterManager.findCurrentVC(vc)\n        }\n        return nil\n    } else if let presentedVC = parentVC.presentedViewController {\n        return ZYRouterManager.findCurrentVC(presentedVC)\n    }\n    return parentVC\n}\n```\n\n<a name=\"7882cc\"></a>\n## [](#7882cc)思路扩展\n\n这里路由控制器的实现还是比较简单的，主要就是通过对比host判断加载对应的controller。比较适合中小型项目的使用，如果项目是组件化搭建的，应用场景相对更复杂，目前相关比较好的库是[JLRoutes](https://github.com/joeldev/JLRoutes)。<br />[JLRoutes](https://github.com/joeldev/JLRoutes)的主要实现思路是在启动时注册一组跳转map，当传递了对应的scheme后就会触发相应的block方法，在block中实现具体的跳转逻辑。\n",
    "tags": [
      "封装"
    ],
    "<br />categories": "iOS"
  },
  {
    "title": "QuickTime Player制作GIF",
    "description": "tags: [工具]categories: 教程打开QuickTime  Player，选择菜单栏上的屏幕录制如果需要录取手机上的界面，就选择影片录制，同时修改来源为手机录制完毕后可以在菜单栏上选择显示--显示剪辑 对视频进行片段剪辑选择编辑--分离剪辑，选择要保留的视频片段内容，不需要哪一个...",
    "created_at": "2018-11-20T11:00:20.000Z",
    "updated_at": "2018-11-20T11:07:57.000Z",
    "published_at": "2018-11-20T11:07:57.000Z",
    "format": "asl",
    "slug": "ptsvdr",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2018-11-15T06:29:48.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "工具"
    ],
    "categories": "教程",
    "body": "\n* 打开QuickTime  Player，选择菜单栏上的屏幕录制\n* 如果需要录取手机上的界面，就选择影片录制，同时修改来源为手机\n* 录制完毕后可以在菜单栏上选择显示--显示剪辑 对视频进行片段剪辑\n* 选择编辑--分离剪辑，选择要保留的视频片段内容，不需要哪一个就选哪一个\n* 选择编辑--删除 删除选中的那个不需要的片段\n* 保存视频\n* 进入[免费的gif制作网站](https://image.online-convert.com/convert-to-gif)上传视频片段，并生成gif图片\n\n"
  },
  {
    "title": "深入浅出CoreStore",
    "description": "CoreStore是一个使用Swift包装CoreData的框架，号称利用Swift语言的特性，优雅而又安全的释放CoreData的真正潜力。特性充分利用了Swift语言的优雅和安全的特点安全的并发架构 所有的更新都是通过串行事务完成的清晰、便捷的查询API类型安全，可以方便的配置监听支持高效...",
    "created_at": "2019-01-07T01:59:44.000Z",
    "updated_at": "2019-01-07T03:04:32.000Z",
    "published_at": "2019-01-07T03:04:32.000Z",
    "format": "lake",
    "slug": "glcni1",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-01-07T01:48:34.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n\n[CoreStore](https://github.com/JohnEstropia/CoreStore)是一个使用Swift包装CoreData的框架，号称利用Swift语言的特性，优雅而又安全的释放CoreData的真正潜力。\n\n<a name=\"c666ad11\"></a>\n### 特性\n\n- 充分利用了Swift语言的优雅和安全的特点\n- 安全的并发架构 所有的更新都是通过串行事务完成的\n- 清晰、便捷的查询API\n- 类型安全，可以方便的配置监听\n- 支持高效率的批量导入\n- 支持纯Swift代码声明安全的成员变量，无需维护**.xcdatamodeId**文件\n- 支持进阶式升级\n- 支持自定义升级\n- 支持一个**DataStack**管理多个存储对象\n\n<a name=\"704f29e0\"></a>\n### 基本用法\n<a name=\"ef56a618\"></a>\n#### 数据库插入\n```swift\nCoreStore.perform(\n  asynchronous: { (transaction) -> Void in\n        let person = transaction.create(Into<MyPersonEntity>())\n        person.name = \"John Smith\"\n        person.age = 42\n  },\n  completion: { (result) -> Void in \n        switch result {\n        case .success: print(\"success!\")\n        case .failure(let error): print(error)\n        }\n  }\n)\n```\n\n<a name=\"9d876ea2\"></a>\n#### 数据库查询\n```swift\nlet people = CoreStore.fetchAll(\n    From<MyPersonEntity>()\n        .where(\\.age > 30),\n        .orderBy(.ascending(\\.name), .descending(.\\age)),\n        .tweak({ $0.includesPendingChanges = false })\n)\n```\n\n```swift\nlet maxAge = CoreStore.queryValue(\n    From<MyPersonEntity>()\n        .select(Int.self, .maximum(\\.age))\n)\n```\n\n<a name=\"e1255531\"></a>\n#### 数据库更新\n```swift\nCoreStore.perform(asynchronous: { (transaction) -> Void in \n        let predicate = NSPredicate(format: \"name = leafly\")\n        let person = transaction.fetchOne(From<MyPersonEntity>(),\n                                          Where<MyPersonEntity>(predicate))\n        preson.age = 29\n  },\n  completion: { (result) -> Void in \n        switch result {\n        case .success: print(\"success!\")\n        case .failure(let error): print(error)\n        }\n  }\n)\n```\n\n<a name=\"7118290c\"></a>\n#### 数据库删除\n```swift\nlet predicate = NSPredicate(formate: \"age = 30\")\nCoreStore.perform(asynchronous: { (transaction) -> Void in\n     transaction.deleteAll(From<MyPersonEntity>(),\n                           Where<MyPersonEntity>(predicate)\n },\n completion: { (result) -> Void in \n        switch result {\n        case .success: print(\"success!\")\n        case .failure(let error): print(error)\n        }\n  }\n)\n```\n\n<a name=\"f895fc53\"></a>\n### 数据库升级\n```swift\n// 创建dataStack 需要指明迁移路径\nlet dataStack = DataStack(xcodeModelName: \"Model\", \n                          bundle: Bundle.main, \n                          migrationChain: [\"Model\", \"ModelV2\"])\n// sqlite的路径\nlet sqliteFileURL = FileManager.default.urls(for: systemDirectorySearchPath, in: .userDomainMask).first!.appendingPathComponent(Bundle.main.bundleIdentifier, isDirectory: true).appendingPathComponent(\"Model.sqlite\")\n// addStorate\n_ = dataStack.addStorage(\n  SQLiteStore(\n    fileURL: sqliteFileURL,\n    localStoreageOptions: .recreateStoreOnModelMismatch\n  ),\n  completion: { (result) -> Void in\n               switch result {\n                 case .success(let storage):\n                    // 做一些数据库创建后的操作\n                 case .failure(let error):\n                    // 数据库创建失败\n               }\n              }\n)\n\nCoreStore.defaultStack = dataStack\n```\n\n",
    "categories": "iOS"
  },
  {
    "title": "iOS应用内购买开发流程",
    "description": "前期准备完善协议、税务和银行业务等信息 具体可参考此文章为app添加内购产品 一般而言产品ID使用bundleId+产品信息添加沙箱技术测试员客户端代码流程封装内购单例 AppDelegate中应用启动时调用在单例的init方法中注册对购买结果的监听用户点击充值时，调用SKProductsRe...",
    "created_at": "2018-12-25T02:30:27.000Z",
    "updated_at": "2018-12-25T09:30:53.000Z",
    "published_at": "2018-12-25T09:30:53.000Z",
    "format": "asl",
    "slug": "pivvlb",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-01-07T01:48:34.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n\n<a name=\"o659uw\"></a>\n## 前期准备\n\n1. 完善协议、税务和银行业务等信息 [具体可参考此文章](https://juejin.im/post/5a7b0e97f265da4e8e784c9e)\n\n2. 为app添加内购产品 一般而言产品ID使用bundleId+产品信息\n\n3. 添加沙箱技术测试员\n\n\n<a name=\"3za6sp\"></a>\n## [](#3za6sp)客户端代码流程\n\n1. 封装内购单例 AppDelegate中应用启动时调用\n\n2. 在单例的init方法中注册对购买结果的监听\n\n3. 用户点击充值时，调用SKProductsRequest发起一个请求，请求商品信息\n\n4. 商品信息查询成功，请求支付\n\n5. 处理payment的监听回调\n\n6. 交易完成 向服务器端发送凭证\n\n\n<a name=\"yp2bsd\"></a>\n## [](#yp2bsd)服务端代码流程\n\n1. 接受iOS端发送过来的购买凭证\n\n2. 判断凭证是否已经存在或验证过，存储凭证\n\n3. 将凭证发送到苹果服务器验证\n\n4. 根据验证结果修改用户的会员权限\n\n\n<a name=\"7cg3rw\"></a>\n## [](#7cg3rw)自动续期订阅的注意点\n\n1. 启动针对自动续期订阅的服务器通知\n\n2. 客户端启动时可能会收到苹果给的续期成功的回调\n\n\n<a name=\"gax1xn\"></a>\n## [](#gax1xn)恢复购买\n\n\n<a name=\"fcq5mb\"></a>\n## [](#fcq5mb)漏单、退单的处理\n\n<a name=\"8gvxvb\"></a>\n## [](#8gvxvb)参考文章\n[链接](https://juejin.im/post/5c204bdf5188256d98331363)\n\n",
    "categories": "iOS"
  },
  {
    "title": "ElementUI之Card卡片",
    "description": "",
    "created_at": "2018-11-30T07:13:42.000Z",
    "updated_at": "2018-11-30T07:14:22.000Z",
    "published_at": null,
    "format": "asl",
    "slug": "wg94e3",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-01-07T01:48:34.000Z",
      "_serializer": "v2.user"
    },
    "body": ""
  },
  {
    "title": "Instrument三板斧",
    "description": "Instrument提供了很多功能，这里主要总结三个最常用的功能：Time Profiler: 分析代码的执行时间，找出导致程序变慢、过于消耗CPU的原因Allocations: 监测内存的使用/分配情况 内存消耗过大可以让程序很快被系统杀死，所以要多加防范Leaks: 找到引发内存泄漏的起点",
    "created_at": "2018-11-21T06:18:50.000Z",
    "updated_at": "2018-11-21T06:30:32.000Z",
    "published_at": "2018-11-21T06:30:32.000Z",
    "format": "asl",
    "slug": "qh8x6r",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png",
      "large_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-01-07T01:48:34.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n作为开发，不仅仅要会开发功能，还需要关注产品的性能，苹果为我们提供了强大的性能检测功能Instrument。这里总结一下Instrument的三个常用功能。\n\n<a name=\"u7avsg\"></a>\n#### [](#u7avsg)CPU性能\nInstrument有一个**Timer Profiler**选项，选择**Timer Profiler**模块运行你想要检测的应用即可得到它的CPU性能的结果：\n\n![](https://cdn.nlark.com/yuque/0/2019/png/183307/1548062488952-32b82364-c834-417d-be0e-5c6c065f6e53.png#align=left&display=inline&height=442&originHeight=532&originWidth=900&status=done&width=747)\n\n- 可以在时间轴里选择一段时间查看该段时间更为细节的CPU性能\n\n- 可以在Call Tree里选择调用栈的展现形式，更加方便问题定位\n\n- 如果CPU过高会导致手机耗电甚至发热，列表滚动中CPU过高也有可能导致掉帧\n\n\n<a name=\"bysosy\"></a>\n#### [](#bysosy)图形性能\n图形性能方面最关注的应该就是「帧率」了，也就是我们常说的FPS。在Instrument中使用**Core Animation** + **Time Profiler**来评估图形性能。<br />除了观察时间轴上的FPS情况，也可以在控制台中选择Core Animation FPS Measurements来观察FPS的情况，在屏幕滑动时，FPS越高表示性能越好，帧率过低则意味着屏幕可能会出现卡顿。<br />![](https://cdn.nlark.com/yuque/0/2019/png/183307/1548063371611-be58f216-99e0-49fa-9920-e631f3771c5a.png#align=left&display=inline&height=512&originHeight=548&originWidth=800&status=done&width=747)\n\n除了FPS还有很多选项可以检测图形性能，在Xcode 9之前这些选项在右下角的区域（如上图），Xcode 9之后这些选择在Xcode的Debug菜单中<br />![](https://cdn.nlark.com/yuque/0/2019/png/183307/1548064256231-96434508-1f01-4d2b-b52e-cbfba03a1ddf.png#align=left&display=inline&height=387&originHeight=676&originWidth=1306&status=done&width=747)\n\n下面着重介绍一下这些选项的作用：\n\n- Color Blended Layers 这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明的图层叠加引起\n\n- Color Hits Green and Misses Red 当开启栅格化时，耗时的图片绘制会被缓存，当做一个简单的扁平图片来呈现，如果页面的其他区块使用缓存直接命中，就显示绿色，反之就显示红色。红色越多，性能越差，因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体会降低开销，反之则意味着频繁生成新的缓存，这会让性能问题雪上加霜\n\n- Color Copied Images 对于GPU不支持的色彩格式的图片只能由CPU处理，这样的图片会标为蓝色，蓝色越多性能越差\n\n- Color Immediately 通常以每毫秒10次的频率更新图层调试颜色，对某些效果来说可能太慢了，这个选项可以用来设置每帧都更新\n\n- Color Misaligned Images 这个选项用来检查图片是否被缩放以及像素是否对齐，被缩放的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差\n\n- Color Offscreen-Rendered Yellow 这个选项会把离屏渲染的图层显示为黄色，黄色越多，性能越差，这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize来优化\n\n- Color OpenGL Fast Path Blue 这个选项会把任何直接使用OpenGL绘制的图层显示为蓝色。蓝色越多，性能越好\n\n- Flash Update Regions 这个选项会把重绘的内容显示为黄色，不该出现的黄色越多，性能越差。\n\n\n<a name=\"2ekfyu\"></a>\n#### [](#2ekfyu)内存性能\n\n- 全局内存使用情况：从全局的角度监测应用的内存使用情况，捕捉非预期的或大幅度的内存增长\n\n- 内存泄漏：未被程序引用，同时也不能被使用或释放的内存\n\n- 废弃内存：被程序引用，但是没有任何作用的内存\n\n- 僵尸对象：对应的内存已经被释放并且不再会使用到，但是程序依然指向它的引用\n\n\n![](https://cdn.nlark.com/yuque/0/2019/png/183307/1548068035204-9b36b29a-e575-4149-a2db-f9500e7fbf32.png#align=left&display=inline&height=479&originHeight=513&originWidth=800&status=done&width=747)\n<a name=\"uxuyny\"></a>\n#### [](#uxuyny)注意点\n\n- 如果使用Instrument查看调用栈时看到的都是地址而不是函数名，这就需要在项目的Build Settings - Debug Information Format的Debug 和 Release里设置为**DWAF with dSYM File**，这样才能将对应的堆栈信息符号化显示\n\n\n",
    "tags": [
      "iOS"
    ],
    "categories": "iOS",
    "date": "2018-11-21 11:55:00 +0800",
    "<br />categories": "开发技巧"
  },
  {
    "title": "Flutter--状态管理",
    "description": "重点知识有些widgets是有状态的，有些是无状态的如果用户与widget交互，widget会发生变化，那么它就是有状态的widget的状态保存在一个State对象中，它和widget的布局显示分离当widget状态改变时，State对象调用setState()，告诉框架去重绘widget创建...",
    "created_at": "2019-01-07T06:24:28.000Z",
    "updated_at": "2019-01-07T07:03:14.000Z",
    "published_at": "2019-01-07T07:03:14.000Z",
    "format": "lake",
    "slug": "kby622",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-01-22T09:21:24.000Z",
      "_serializer": "v2.user"
    },
    "body": "\n> \n> 重点知识\n> - 有些widgets是有状态的，有些是无状态的\n> - 如果用户与widget交互，widget会发生变化，那么它就是有状态的\n> - widget的状态保存在一个State对象中，它和widget的布局显示分离\n> - 当widget状态改变时，State对象调用setState()，告诉框架去重绘widget\n\n\n<a name=\"37c07438\"></a>\n#### 创建一个有状态的widget\n> - 要创建一个自定义有状态的widget，需要创建两个类：StatefullWidget和State\n> - 状态对象包含widget的状态和build()方法\n> - 当widget的状态改变时，状态对象调用setState(), 告诉框架重绘widget\n\n\n```\nclass MyApp extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    // TODO: implement createState\n    return _MyAppState();\n  }\n}\n\nclass _MyAppState extends State<MyApp> {\n\n  int counter;\n\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n    counter = counter ?? 0;\n  }\n\n  void _decrementCounter(_) {\n    setState(() {\n      counter--;\n      print('decrement: $counter');\n    });\n  }\n\n  void _incrementCounter(_) {\n    setState(() {\n      counter++;\n      print('increment: $counter');\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    return MaterialApp(\n      title: \"flutter_app\",\n      home: new Home(\n        title: 'My Home Page',\n        counter: counter,\n        decrementCounter: _decrementCounter,\n        incrementCounter: _incrementCounter,\n      ),\n    );\n  }\n}\n```\n\n<a name=\"6f17667e\"></a>\n#### 管理状态\n> - 有多种方法可以管理状态\n> - 选择使用何种管理方法\n> - 如果不是很清楚时，那就在父widget中管理状态吧\n\n<a name=\"161fbf07\"></a>\n##### 常见的状态管理方法有：\n\n1. widget管理自己的state\n1. 父widget管理widget状态\n1. 混搭管理\n<a name=\"37812ab7\"></a>\n##### 如何决定使用哪种管理方法？\n\n1. 如果状态是用户数据，如复选框的选中状态、滑块的位置等，该状态最好由父widget管理\n1. 如果状态是有关界面外观效果的，如动画，该状态最好由widget本身管理\n",
    "categories": "Flutter"
  },
  {
    "title": "无标题",
    "description": "",
    "created_at": "2019-05-08T08:25:10.000Z",
    "updated_at": "2019-05-08T08:25:31.000Z",
    "published_at": null,
    "format": "lake",
    "slug": "rgasd0",
    "last_editor": {
      "id": 183307,
      "type": "User",
      "login": "leafly",
      "name": "leafly",
      "description": "iOS、vue、koa",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/183307/1548140932816-avatar/d1ad6b29-775c-4eef-a0f0-54aa6fcca445.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2018-09-27T09:52:55.000Z",
      "updated_at": "2019-05-25T14:37:46.000Z",
      "_serializer": "v2.user"
    },
    "body": ""
  }
]