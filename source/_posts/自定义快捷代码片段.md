title: 自定义快捷代码片段
tags:
  - iOS技巧
  - ''
categories:
  - iOS
date: 2017-12-14 19:07:00
---
Xcode为我们提供了一种可以快速输入一段代码的快捷方式，这里对如何通过自定义快捷代码片段来提升开发效率进行一个总结

## 如何创建自定义代码片段

在Xcode的右下角有一个代码片段区域，如图所示：
![QQ20171102-163351.png](http://upload-images.jianshu.io/upload_images/1479547-77d2438767fb5b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这里面已经有了很多代码片段，这些代码片段是Xcode为我们提前准备的。
我们先来看一看里面的结构，点开第一个代码片段`C Block typedef - Define a block as a type`，这个代码片段是我们通常用来给一个block声明一个别名的
![QQ20171102-163706.png](http://upload-images.jianshu.io/upload_images/1479547-a8ef0cc59ef647fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图所示的代码片段有很多很多，感兴趣的可以自己去看一看，接下来就是本文的重点，如何创建属于我们的代码片段呢？

- 在编辑区写上你要添加的片段代码
- 将代码选中拖拽到Code Snippets区域
![QQ20171102-165121.png](http://upload-images.jianshu.io/upload_images/1479547-d2155adf5857e5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 在弹框里对代码片段进行编辑，将想要方便更换的内容以`<# #>`包裹，对应的内容就是可变内容啦
![QQ20171102-170317.png](http://upload-images.jianshu.io/upload_images/1479547-0896076c1ab410bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 在`Completion Shortcut`一栏中可以填入快捷标记
- 完成以上步骤后，我们在需要使用相关代码片段时只需要输入快捷标记就能选中啦
![QQ20171102-170644.png](http://upload-images.jianshu.io/upload_images/1479547-9a97bed7868a1254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 常用代码片段

腾讯QMUI Team开源了一个他们经常使用的代码片段，非常好用，大家可以直接去下载，存放在`~/Library/Developer/Xcode/UserData/CodeSnippets`目录下

[qmui-ios-codesnippets](https://github.com/QMUI/QMUI_iOS_CodeSnippets)

#### 快捷键汇总

*NSObject*
- `pa` - 定义一个 `assign` 的 property
- `pc` - 定义一个 `copy` 的 property
- `ps` - 定义一个 `strong` 的property
- `psr` - 定义一个 `strong, readonly` 的property
- `pw` - 定义一个 `weak` 的property
- `propertySwizzleAssign` - 用 `swizzle` 的方式定义一个 `assign` 的property
- `propertySwizzleCopy` - 用 `swizzle` 的方式定义一个 `copy` 的property
- `propertySwizzleStrong` - 用 `swizzle` 的方式定义一个 `strong` 的property
- `propertySwizzleWeak` - 用 `swizzle` 的方式定义一个 `weak` 的property
- `sharedInstance` - 为当前类创建一个实现单例功能的 `sharedInstance` 方法
- `replaceMethod` - 重写当前类的 `load` 方法并在其中用 `swizzle` 替换方法实现
- `replaceMethod_QMUI` - QMUI 重写当前类的 `load` 方法并用 `ReplaceMethod()` 函数替换方法的实现


*Block*
- `blockArguments` - 声明一个用于方法参数的 block
- `blockproperty` - 声明一个用于 property 的 block
- `blocktypedef` - 用 `typedef` 定义一个 block
- `blockvar` - 定义一个作为局部变量的 block


*Method & Function*
- `fnv` - 定义一个返回值为 `void` 的方法
- `fnv:` - 定义一个返回值为 `void` 且带参数的方法
- `fnblock` - 定义一个返回值类型为 block 的方法
- `fnv_handleEvent` - 定义一个用于 `UIControl` 事件回调的方法
- `fnv_longPress` - 定义一个用于 `UILongPressGestureRecognizer` 的回调方法（你就不用每次都去拼写那个很长的手势名字了）
- `fnv_pan` - 定义一个用于 `UIPanGestureRecognizer` 的回调方法
- `fnv_tap` - 定义一个用于 `UITapGestureRecognizer` 的回调方法


*UIView*
- `setFrame` - 为 `UIView` 设置 `frame`
- `setFrame_QMUI` - QMUI 使用像素对齐的 `CGRectFlatMake()` 为 `UIView` 设置 `frame`
- `setFrameX` - QMUI 使用 `CGRectSetX()` 修改 `UIView` 的 `frame.origin.x`
- `setFrameY` - QMUI 使用 `CGRectSetY()` 修改 `UIView` 的 `frame.origin.y`
- `setFrameXY` - QMUI 使用 `CGRectSetXY()` 修改 `UIView` 的 `frame.origin`
- `sizeThatFits` - 为当前 view 创建 `sizeThatFits:` 方法
- `layoutSubviews` - 展开 `layoutSubviews` 方法
- `updateConstraints` - 展开 `updateConstraints` 方法
- `getWidth` - 展开 `CGRectGetWidth()`
- `getHeight` - 展开 `CGRectGetHeight()`
- `getMinX` - 展开 `CGRectGetMinX()`
- `getMinY` - 展开 `CGRectGetMinY()`
- `addtarget` - 调用 `UIControl addTarget:action:forEvents:` 方法
- `setImageForButton` - 为 `UIButton` 设置图片
- `setTitleColorForButton` - 为 `UIButton` 设置文字颜色
- `setTitleForButton` - 为 `UIButton` 设置文字

*UITableView*
- `initWithStyle` - 展开 `initWithStyle:` 方法
- `initWithStyleForCell` - 展开 `UITableViewCell initWithStyle:reuseIdentifier:` 方法
- `tableViewDelegate` - 展开常用的几个 `UITableViewDelegate` 方法
- `numberOfSectionsInTableView` - 展开 `numberOfSectionsInTableView:`方法
- `numberOfRowsInSection` - 展开 `tableView:numberOfRowsInSection:` 方法
- `cellForRowAtIndexPath` - 展开 `tableView:cellForRowAtIndexPath:` 方法
- `heightForRowAtIndexPath` - 展开 `tableView:heightForRowAtIndexPath:` 方法
- `didSelectRowAtIndexPath` - 展开 `tableView:didSelectRowAtIndexPath:` 方法


*UICollectionView*
- `collectionViewDelegate` - 展开常用的几个`UICollectionViewDelegate` 方法
- `numberOfSectionsInCollectionView` - 展开 `numberOfSectionsInCollectionView:`
- `numberOfItemsInSection` - 展开 `collectionView:numberOfItemsInSection:`
- `cellForItemAtIndexPath` - 展开 `collectionView:cellForItemAtIndexPath:`
- `sizeForItemAtIndexPath` - 展开 `collectionView:layout:sizeForItemAtIndexPath:` 方法
- `didSelectItemAtIndexPath` - 展开 `collectionView:didSelectItemAtIndexPath:` 方法
- `didDeselectItemAtIndexPath` - 展开 `collectionView:didDeselectItemAtIndexPath:` 方法


*UIViewController*
- `loadView` - 展开 `loadView` 方法
- `viewDidLoad` - 展开 `viewDidLoad` 方法
- `viewWillAppear` - 展开 `viewWillAppear:` 方法
- `viewDidAppear` - 展开 `viewDidAppear:` 方法
- `viewWillDisappear` - 展开 `viewWillDisappear:` 方法
- `viewDidDisappear` - 展开 `viewDidDisappear:` 方法
- `viewDidLayoutSubviews` - 展开 `viewDidLayoutSubviews:` 方法
- `updateViewConstraints` - 展开 `updateViewConstraints:` 方法
- `addChildViewController` - 在当前 `UIViewController` 里添加 `childViewController`
- `removeFromParentViewController` - 将 `childViewController` 从当前的 `UIViewController` 里移除
- `initSubviews` - QMUI 展开 `initSubviews` 方法
- `setNavigationItems` - QMUI 重写 `QMUICommonViewController` 里的 `setNavigationItemsIsInEditMode:animated:` 方法
- `setToolbarItems` - QMUI 重写 `QMUICommonViewController` 里的 `setToolbarItemsIsInEditMode:animated:` 方法
- `leftBarButtonItemImage` - QMUI 用 `QMUINavigationButton` 的方法创建一个用于 `navigationItem.leftBarButtonItem` 的 `UIBarButtonItem`
- `rightBarButtonItemImage` - QMUI 用 `QMUINavigationButton` 的方法创建一个用于 `navigationItem.rightBarButtonItem` 的 `UIBarButtonItem`


*Other*
- `pragma` - 展开一个用于 Xcode 导航的 `#pragma mark -` 宏
- `externRefInH` - 在 `*.h` 文件里声明一个 `extern const` 的指针
- `externRefInM` - 在 `*.m` 文件里为一个 `extern const` 的指针赋值
- `externValueInH` - 在 `*.h` 文件里声明一个 `extern const` 的值变量
- `externValueInM` - 在 `*.m` 文件里为一个 `extern const` 的变量赋值
- `static reference` - 定义一个 `static` 的指针
- `static` - 定义一个 `static` 的值变量
- `__weakSelf` - 定义一个 `weak` 的 `self` 指针
- `__strongSelf` - 将 `weakSelf` 指针改为 `strong` 的 `self` 指针
- `logCallStackSymbols` - 用 `NSLog` 打出当前的方法调用栈信息
- `timeConsuming` - 展开一段用 `CACurrentMediaTime()` 来计算方法耗时的代码


