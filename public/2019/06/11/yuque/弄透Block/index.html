<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Leafly的博客"><title>弄透Block | Leafly</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">弄透Block</h1><a id="logo" href="/.">Leafly</a><p class="description">talk is cheap, show me the code</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">弄透Block</h1><div class="post-meta">Jun 11, 2019<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>本文重点：</p>
<ul>
<li>Block是什么？</li>
<li>总结Block的使用场景</li>
<li>为什么Block属性需要用copy修饰？</li>
<li>__block修饰后为何就可以修改？</li>
<li>Block循环引用是怎么产生的？</li>
</ul>
<p><a name="d9d97201"></a></p>
<h1 id="Block是什么？"><a href="#Block是什么？" class="headerlink" title="Block是什么？"></a>Block是什么？</h1><blockquote>
<p>Block：带有自动变量的匿名函数，它是C语言的拓展功能，之所以是扩展，是因为C语言不允许存在这样的匿名函数</p>
</blockquote>
<ol>
<li>匿名函数</li>
</ol>
<p>匿名函数是指不带函数名称的函数</p>
<ol start="2">
<li>带有自动变量</li>
</ol>
<p>这是因为Block拥有捕获外部变量的功能，在Block中访问一个外部的局部变量，Block会持有它的临时状态，自动捕获变量值，外部局部变量的变化不会影响它的状态</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">  printf(<span class="string">"val=%d\n"</span>, val);</span><br><span class="line">&#125;;</span><br><span class="line">val = <span class="number">2</span>;</span><br><span class="line">blk(); <span class="comment">// 这里输出的值是10，而不是2，因为block在实现时就会对它所在方法中定义的栈变量进行一次只读拷贝</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>为了解决block不能修改自动变量的值，可以使用 <code>__block</code> 修饰</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"> printf(<span class="string">"val=%d\n"</span>, val);</span><br><span class="line">&#125;;</span><br><span class="line">val = <span class="number">2</span>;</span><br><span class="line">blk(); <span class="comment">// 这里输出的值是2</span></span><br></pre></td></tr></table></figure>
<p><a name="e3d6ac67"></a></p>
<h1 id="Block的使用场景"><a href="#Block的使用场景" class="headerlink" title="Block的使用场景"></a>Block的使用场景</h1><ol>
<li>声明Block属性 利用Block属性响应事件或传递数据</li>
</ol>
<blockquote>
<p>UIViewController 需要监听TableView中Cell的某个按钮的点击事件，既可以通过Delegate回调，也可以利用Block回调<br>Block回调的思路：<br>声明一个Block属性，注意这里要用copy。<br>利用Block属性进行回调</p>
</blockquote>
<ol start="2">
<li>方法参数为Block 利用Block实现回调</li>
</ol>
<blockquote>
<p>以 <code>[UIView animateWithDuration:animations:]</code> 为例，animations是一个block对象，利用block实现调用者与UIView之间的数据传递</p>
</blockquote>
<ol start="3">
<li>链式语法</li>
</ol>
<blockquote>
<p>链式编程思想：将block作为方法的返回值，且返回值的类型为调用者本身，并将该方法以setter的形式返回，从而实现连续调用</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  CaculateMaker.h</span></span><br><span class="line"><span class="comment">//  ChainBlockTestApp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CaculateMaker</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回类型 CaculateMaker</span></span><br><span class="line"><span class="comment">* 传入参数 CGFloat num</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (CaculateMaker *(^)(<span class="built_in">CGFloat</span> num))add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  CaculateMaker.m</span></span><br><span class="line"><span class="comment">//  ChainBlockTestApp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CaculateMaker.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CaculateMaker</span></span></span><br><span class="line"></span><br><span class="line">- (CaculateMaker *(^)(<span class="built_in">CGFloat</span> num))add;&#123;</span><br><span class="line">    <span class="keyword">return</span> ^CaculateMaker *(<span class="built_in">CGFloat</span> num)&#123;</span><br><span class="line">        _result += num;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">CaculateMaker *maker = [[CaculateMaker alloc] init];</span><br><span class="line">maker.add(<span class="number">20</span>).add(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p><a name="fd60c885"></a></p>
<h1 id="为什么Block属性需要用copy修饰？"><a href="#为什么Block属性需要用copy修饰？" class="headerlink" title="为什么Block属性需要用copy修饰？"></a>为什么Block属性需要用copy修饰？</h1><p><strong>因为在MRC情况下如果Block属性不使用copy修饰，在使用中会出现崩溃，在ARC情况下，Block属性使用strong修饰会被默认进行copy，所以ARC情况下，Block属性可以使用strong或copy修饰，不然会出现崩溃。</strong><br>**<br>为何会有这种现象出现？</p>
<p>Block在内存中的位置分为三种类型：</p>
<ul>
<li><strong>NSGlobalBlock</strong> 是位于全局区的block，它是设置在程序的数据区中。</li>
<li><strong>NSStackBlock</strong> 是位于栈区，当超出变量作用域时，栈上的Block以及__block变量都会被销毁。</li>
<li><strong>NSMallocBlock</strong> 是位于堆区，在变量作用域结束时不受影响。</li>
</ul>
<p>这三种类型对应以下三种情况：</p>
<ol>
<li>Block中没有截获自动变量时Block类型是<strong>NSGlobalBlock</strong></li>
<li>Block中截获自动变量时Block类型是<strong>NSStackBlock</strong></li>
<li>堆中的Block无法直接创建，当对<strong>NSStackBlock</strong>类型的Block进行copy时，会将Block放到堆中，Block类型变为<strong>NSMallocBlock</strong></li>
</ol>
<p>当Block类型是<strong>NSStackBlock</strong>时，一旦超出了变量作用域，栈上的Block以及__block变量就会被销毁，从而导致调用Block回调时崩溃。因此，Block属性需要用copy修饰来避免这种情况。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)click:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">        TestClass *test = [[TestClass alloc] init];</span><br><span class="line">        </span><br><span class="line">        __block <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 弱引用，block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS</span></span><br><span class="line">        test.weakBlock = ^() &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"ok"</span>);</span><br><span class="line">            a = <span class="number">2</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// block类型是__NSStackBlock__  当TestClass执行回调时必崩 EXC_BAD_ACCESS</span></span><br><span class="line">        test.assignBlock = ^() &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"ok"</span>);</span><br><span class="line">            a = <span class="number">3</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// block类型是__MallocBlock__ 正常执行</span></span><br><span class="line">        test.copyBlock = ^() &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"ok"</span>);</span><br><span class="line">            a = <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// block类型是__MallocBlock__ 正常执行</span></span><br><span class="line">        test.strongBlock = ^() &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"ok"</span>);</span><br><span class="line">            a = <span class="number">5</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"copy property: %@"</span>, test.copyBlock);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"assign property: %@"</span>, test.assignBlock);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"weak property: %@"</span>, test.weakBlock);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"strong property: %@"</span>, test.strongBlock);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        [test start];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a name="7a61fc63"></a></p>
<h1 id="block修饰后为何就可以修改局部变量？"><a href="#block修饰后为何就可以修改局部变量？" class="headerlink" title="__block修饰后为何就可以修改局部变量？"></a>__block修饰后为何就可以修改局部变量？</h1><p>首先，需要弄明白一个概念，static声明的静态局部变量是可以在block内进行修改的，为何会有这种区别呢？<br>因为，静态局部变量存在于应用程序的整个生命周期，而非静态局部变量仅存在于一个局部上下文中，绝大多数情况下，block都是延后执行的，这就有可能出现非静态局部变量被回收的情况，为了避免这个问题，苹果在设计block时，block中非静态局部变量是值传递，这也解释了为何block会持有变量的临时状态，后续再修改，block中的变量值也不再改变。</p>
<p>加上<strong>block修饰的局部变量，被block捕获时，就不再是传递局部变量的值了，而是变成了一个结构体实例。比如：<br>定义一个 `</strong>block int a = 10;<code>会变成</code><strong>Block_byref_a_0 *a;<code>&lt;br /&gt;</code></strong>Block_byref_a_0` 的结构体如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_a_0 &#123;</span><br><span class="line"> <span class="keyword">void</span> *__isa;</span><br><span class="line"> __Block_byref_a_0 *__forwarding; <span class="comment">// forwarding指针</span></span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">int</span> a; <span class="comment">// 原变量同类型变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中有一个<strong>forwarding指针，此指针指向转换后变量本身，结构体中也有一个原变量一样类型的变量。此后代码中涉及到原变量的地方，都会转换成新变量-&gt;forwarding-&gt;原变量同类型变量</strong></p>
<p>如果在block中直接修改变量的值，实质的过程是新变量-&gt;__forwarding-&gt;原变量同类型变量，最终修改的其实是结构体中原变量同类型变量，很明显这个结构体内的变量已经不属于block的外部变量了，所以能在block内修改。</p>
<p>这个新变量也是非静态局部变量，所以如果没有copy，block执行时，新变量有可能已经被栈回收</p>
<p>总结：<br><strong>block修饰的变量转换成了结构体，结构体内有一个forwarding指针和一个与原变量相同类型的成员变量，forwarding指针指向结构体内的成员变量。无论在block内外，都是通过forwarding来访问的。</strong></p>
<p><a name="0eccb7a1"></a></p>
<h1 id="Block的循环引用是怎么产生的？"><a href="#Block的循环引用是怎么产生的？" class="headerlink" title="Block的循环引用是怎么产生的？"></a>Block的循环引用是怎么产生的？</h1><p>我们先看一段block导致循环引用的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TestClass *test = [[TestClass alloc] init]; </span><br><span class="line"></span><br><span class="line">test.copyBlock = ^() &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ok: %d"</span>, test.result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们写完这段代码后，Xcode就会提醒我们，这段代码存在循环引用，事实上也确实存在循环引用。接下来我们就来分析一下为什么会产生循环引用。<br>test的属性block强引用了SecondViewController中的block，SecondViewController中的block又强引用了test的属性result，从而导致了循环引用。</p>
<p>并非所有的block都存在循环引用，下面列举一些常见的block使用的示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// self--&gt;requestModel--&gt;block--&gt;self </span></span><br><span class="line">[<span class="keyword">self</span>.requestModel requestData:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"leafly"</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然存在引用环，但是通过主动释放requestModel打破了循环</span></span><br><span class="line">[<span class="keyword">self</span>.requestModel requestData:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"leafly"</span>;</span><br><span class="line">    <span class="keyword">self</span>.requestModel = <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// t--&gt;block--&gt;self 不存在循环引用</span></span><br><span class="line">Test *t = [[Test alloc] init];</span><br><span class="line"></span><br><span class="line">[t requestData:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"leafly"</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFNetworking--&gt;block--&gt;self 不存在循环引用</span></span><br><span class="line">[AFNetworking requestData:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@"lealfy"</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/原理/">原理</a></div><div class="post-nav"><a class="pre" href="/2019/06/24/yuque/复盘一次内存优化/">复盘一次内存优化</a><a class="next" href="/2019/06/11/yuque/xopen快捷脚本/">xopen快捷脚本</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '672129204f49cd5664c7',
  clientSecret: '57735927f823cfa24256debfb225c5935c2894f9',
  repo: 'ileafly.github.io',
  owner: 'ileafly',
  admin: ['ileafly'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://ileafly.github.io/ileafly"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/教程/" style="font-size: 15px;">教程</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/原理/" style="font-size: 15px;">原理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/02/yuque/阅读器翻页动画优化总结/">阅读器翻页动画优化总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/01/yuque/iOS封装SDK/">iOS封装SDK</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/28/yuque/iOS高效开发/">iOS高效开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/24/yuque/复盘一次内存优化/">复盘一次内存优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/yuque/弄透Block/">弄透Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/yuque/xopen快捷脚本/">xopen快捷脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/10/yuque/Github+Hexo搭建个人博客详细教程/">Github+Hexo搭建个人博客详细教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/09/yuque/使用语雀管理博客/">使用语雀管理博客</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Leafly.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>